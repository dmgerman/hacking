#+AUTHOR: daniel m german
#+TITLE: A quick tutorial of how to use Perl within Org version 0.1

* Preamble

This document is licensed under the same terms as Org-mode.

* Org-mode and Perl

Perl is one of the languages that is supported by Org. Unfortunately
it is not very documented, so it might be hard to get a hand on how to use it.

One of the many advantages of Org is that it is capable of working
with source code within a document. It can be used in two main modes:

1. Small scripts. Each relatively independent from each other. But one might feed output to the next.
1. Literate programming. You write a larger script by breaking into a set of many different ones.

And of course, you can use a combination of both.

* Getting Started

Let us get started. Let us simply create a script that writes numbers from 1 to 10. 

#+begin_src perl :results output
foreach $a (1..10) {
   print "$a\n";
}
#+end_src

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
#+end_example

Org supports several :results types. In this case  ~:results output~
indicates that the results should be considered literal and simply embedded into the document.

You can also name the block where the results are expected:

#+name: countingTo10
#+begin_src perl :results output
foreach $a (1..10) {
   print "$a\n";
}
#+end_src

This means you can move the ~#+RESULTS:~ block somewhere else. It does
not have to follow immediately after the code any more.

#+RESULTS: countingTo10
#+begin_example
1
2
3
4
5
6
7
8
9
10
#+end_example


* Other types of output

Perl scripts might generate data that is parsed by Org. Unfortunately
its current support is not very powerful but hopefully it will improve
over time. The simplest is to use the result of the last expression in
the script:

#+name: sampleList
#+begin_src perl :results list
my @array;
foreach $a (1..10) {
   print "$a\n";
   push @array, $a;
}
@array;
#+end_src

#+RESULTS: sampleList
#+begin_example
- 1
2
3
4
5
6
7
8
9
10
#+end_example

I hope that the support for Perl increases and it allows more complex types of outputs to be parsed by Org.


* Input data to the script

For me the killer feature of using Perl within org is that I can use
tables as input to my scripts. The tables can be created by hand, or
generated by other scripts. I often use SQL to create tables within
Org. This means I can use Org as a meta-programming language. A glue
that lets me piece together different languages. Yes, I can use DBI to
call SQL directly, but this is way cooler :)

Let us assume we have the following table:

#+NAME:example-table
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |

We want to use this table as input. Org passes tables to perl as a
reference to an array of anonymous arrays. In a nutshell, you can
access an element of a table using ~$$nameTable[row][column]~. Remember,
in perl indexes are zero based: For instance:

#+name: example1usingTable(data=example-table)
#+begin_src perl :results output
print $$data[2][1], "\n";
print $$data[0][0], "\n";
#+end_src

#+RESULTS: example1usingTable
#+begin_example
c
1
#+end_example

One challenge, however, is to know how big the table is. It is a bit
complicated, given the type of data structure created by org to represent the table.
I found that the best solution is to use two functions: one that
returns the number of rows, and another the number of tuples. Let us transpose the table

#+name: example2usingTable(data=example-table)
#+begin_src perl :results output
  # first we need to define two functions that will make your life easier
  sub org_columns
  {
      my ($table) = @_;
      my $y = $$table[0];
      return scalar(@$y);
  }
  
  sub org_rows
  {
      my ($table) = @_;
      return scalar(@$table);
  }
  
  for (my $i=0;$i<org_columns($data); $i++) {
      for (my $j=0;$j<org_rows($data); $j++) {
          print "| $$data[$j][$i] ";
      }
      print "|\n";
  }
  
#+end_src

#+RESULTS: example2usingTable
#+begin_example
| 1 | 2 | 3 | 4 |
| a | b | c | d |
#+end_example


* Using literate programming features

Another beauty of org is that you can reuse code snippets. In org, if
you use the option ~:noweb yes~, then the special sequence ~<<name>>~ is
expanded to the source snippet called ~name~. For example, let us
assume we want to transpose again the result of our previous
script. First, let us deal with a problem with org. First, remove the
~+begin_example~, ~+end_example~ from the table example2usingTable, to create a new one:

#+RESULTS: example2usingTableClean
| 1 | 2 | 3 | 4 |
| a | b | c | d |

Now, let us use this as input in the same script example2usingTable:

#+name: example3usingTable(data=example2usingTableClean)
#+begin_src perl :results output :noweb yes
<<example2usingTable>>
#+end_src

Voil√°, by transposing the transposed table, we have recreated the original:

#+RESULTS: example3usingTable
#+begin_example
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |
#+end_example

