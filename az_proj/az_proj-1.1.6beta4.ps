%AZ_PROJ.PS v1.1.6beta4
%%Creator: Joseph Mack NA3T (ex VK2ZJM/VK2BME) and Michael Katzmann NV3Z/VK2BEA/G4NYV
%%Title: az_proj.ps v1.1.6beta4
%%CreationDate: 1 Nov 98
%
% Last modification Feb 2001 (JM)
%
%--------------------------------------
% Notes for v1.0 (Jul 95)
% A 'beta' version was released at the Central States and
% the Eastern States VHF Conferences, 1994 for evaluation purposes.
% This is the first general release version.
% You may freely redistribute this version.
% Note: the data file format is incompatible with that of the beta release -
%	don't mix versions.
%
% Notes for v1.01, not publically released
% Allows shading of the night time part of the earth
%
% Notes for v1.02, not publically released
% Allows plotting of grids worked by propagation mode
%
% Notes for v1.03, (Jul 96) publically released
% Fixes major bug in v1.00 where a grid.dat file could not
% be sent to a postscript printer before a .wdb file.
% The great circle path for qso's between pairs of stations
% can be plotted, to determine the scattering center, as
% for an auroral or Es opening.
%
% Notes for v1.04
% Enhanced greyline features
%
%v1.04 beta1
%
%	1. Orthographic orientation option (South at the top of
%the page). Needed for people in the Southern Hemisphere (-:
%
%	2. ARRL grid square labelling style added. The ARRL
%style has much smaller labels for the grid squares and puts the
%letter square labels in the bottom left of the square.  The grid
%square labelling style used in v1.00-v1.03 is now called az_proj
%style.
%
%	3. Several different options added for shading worked
%grid squares (different colors, different cross hatching
%methods) so that it's possible to mark grid squares worked by
%two (or more) different people. See the sample grid.dat file for
%more info. You can also use the same options for marking the
%grids at the ends of a qso (see qso.dat for examples).
%
%	4. Plotting TV stations for North America (NA) and
%Europe. A full list of NA stations broadcast stations (MW, FM,
%TV) in machine readable format has been produced by Colin K4SSO.
%A separate file consisting of only the NA Channel 2 stations
%(55.25MHz useful as 6m propagation markers) has been added. A
%list of European TV stations (from Geoff Brown and Emil W3EP)
%has been converted to machine readable format, for 6m
%propagation markers.
%
%	5. DAT file formats are still changing (sorry).
%Anything which is a transmitter (TV station, rover, beacon,
%repeater) all have the same format. The only thing which changes
%is the symbol displayed. Please note the changes detailed in
%each .DAT file (at most you will have to add an extra colon or
%two to your old files if you want to update them).
%
%	6. GRID2.DAT file format of v1.03 is now standard (and
%called the GRID format, with no 2). The old format from v1.00
%which had been used in parallel, has been dropped.
%
%	7. An install.bat file has been added to install AZ_PROJ
%and Ghoscript onto a DOS machine with a VGA or SVGA monitor.
%Sample batch files for testing both Ghostscript and AZ_PROJ are
%included.
%
%	8. Easier method for choosing when to draw grid square
%borders and compass (in az_ini.ps). (Also clearer explanation
%of what's happening).
%
% Notes for v1.1 Oct 97
%	1. Added city.dat file, ability to display cities/names
%	2. Option to display lower resolution data for large maps
%thus decreasing drawing time. (Important on server, probably
%irrelevent at home).
%	3. Added cross at QTH, so you could see it if no compass drawn
%	4. Bug in sunrise/set fixed. Date was off by 12days ;-/
%	5. Fixed bug in cross routine
%	6. Added cities, call areas for VK, ZL, VE
%	7. Can input gridlocator instead of lat/lon (required changing inputs to strings)
%
% -------------------------------------
% AZ_PROJ.PS (C) 1994-2000 Joseph Mack NA3T and Michael Katzmann NV3Z/VK2BEA/G4NYV
%
% AZ_PROJ.PS is freely distributable software for non-commercial use;
% you can redistribute it and/or modify it under the terms of the GNU 
% General Public License as published by the Free Software Foundation; 
% either version 2, or (at your option) any later version. 
% All commercial rights belong to us.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with AZ_PROJ.PS; see the file COPYING.	If not, write to
% the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
%

% AZ_PROJ.PS - A program to print Azimuthal equidistant map projections
% on a Postscript device or via a Postscript interpreter (e.g. ghostscript)

% If you find any bugs or have ideas for enhancements, please code them
% and send them to us. We will post updates occasionally, and include
% your code with acknowledgment.

% We are contactable at -
%
% Jun 00
% 332 Summerfield Crossing
% Chapel Hill, NC, 27514-1828 (FM05lw)
% 919-929-1642
%
% e-mail: mailto:mack@ncifcrf.gov	%best, I'll have this address on a long time scale
%
% Michael Katzmann NV3Z / VK2BEA / G4NYV, (FM18rx)
% 501 Defense Highway
% Annapolis, MD. 21410-6923
%
% Michael has a stable life style, you can always get him
% e-mail: michaelk@ieee.org
% packet: nv3z@w3zh.md
% ph: USA (410) 672-3900 (work EST, UTC -5hrs)

%--------------------------------------

% PostScript is a trademark of Adobe Systems, Incorporated.
% Ghostscript is Copyright (C) 1990, 1992, 1993 Aladdin Enterprises.
% DesqviewX is a trademark of Quarterdeck.

% Note: the az_proj files are PostScript. They run on any platform
% that understands PostScript, eg a PostScript printer or a PC, Mac,
% or Unix box running a PostScript interpreter (eg Ghostscript).
%
% The az_proj files have run on these platforms:
% OS
%
% DOS5.0, DesqViewX v2.0, OS/2, Win3.1
% Linux (1.1.92 -> 2.0.29 X11R6), Unix (SGI Irix 5.3,6.2; HPUX 9.0 X11R5)
% Mac Quadra 950, System 7 (just sent to printer)
%
% Interpreters
% Ghostscript 2.61, 3.33, 4.01, 5.01/5.10, 
%
% Printers
%
% - NEC LC890 Silentwriter with Adobe Postscript (Level 1)
% - HP1200C/PS Color deskjet with Adobe Postscript (Level 2)
% - Phaser II color printer (Tektronics ?)
% - HP Deskjet 500, HP Deskjet550C HP Deskjet855C (fed with 550C code).
%
%
% CPUs
% Intel 486, Pentium
% HP9000/380
% SGI MIPS
%
% Ghostscript is freely available (with the GNU License) from
% ftp.cs.wisc.edu:/pub/ghost, and from the GNU servers everywhere.
%
% The Jul '94 price for Ghostscript on PC diskettes is US$48
% (includes shipping, handling, etc) payable by check or money
% order to Aladdin Enterprises and mailed to:
%
%	Aladdin Enterprises
%	203 Santa Margarita Ave.
%	Menlo Park, CA, 94025, USA
%
% The author of ghostscript, L. Peter Deutsch is contactable at
%	Aladdin Enterprises
%	P.O.Box 60264,
%	Palo Alto, CA 94306, USA
% or at
%	ghost@aladdin.com
%	decwrl!aladdin!ghost
%	voice USA (415)-322-0103
%	fax   USA (415)-322-1734
%
%--------------------------------------
%
% n.b. Execution times vary greatly with platforms. Many Postscript
%	printers are not be equipped with floating point hardware and
%	will consequently be slow. (also consider the time taken to
%	send in excess of 4MB of data files to the printer!)
%
% some benchmarks (full world database & annotations):
%	Ghostscript on HP9000/380 X11R5 -	8 mins
%	Ghostscript on i486 (66MHz) VGA -	7 mins
%	HPLaserJet 5MP, 3Mb		-	1.25 hrs
%	HP1200C/PS printer		-	2.1 hrs
%	NEC LC890 PS printer		-	6.7 hrs
%

%--------------------------------------
% Modus operandi for
% a) native Postscript printers
% b) Postscript Interpreters running on host computers,
%	which output native print codes for the target printer.
%
%Input files:
% If you have a native Postscript Printer
%	A real postscript printer can only listen to the line down which
%	the postscript file itself is sent. Postscript printers don't,
%	in general, know about files (the exception is Display PS)
%	When a PS printer gets an EOF it knows it has come to
%	the end of the job. If you want to print a map of the whole
%	world on a real postscript printer you must make ONE file by
%	concatonating "az_proj.ps" and, all of the data files (eg ".wdb",
%	dxcc.dat, beacon.dat). i.e. the data must appear as an uninterrupted
%	stream.
%
%	Note that the data will be drawn on the page in the order received
%	by the printer. e.g. One beacon is on the edge of the Great Lakes.
%	If beacons are drawn first, this beacon will be overwritten by the
%	lake (if drawn in "fill" mode). So send beacons after lakes and countries.
%
%	for DOS:
%	The command line would then be something like
%		C:\> PRINT AZ_COMB.PS
%	where AZ_COMB.PS is the combined data file. The combined data
%	file can be produced by a file similar to makworld.bat
%	(supplied with AZ_PROJ) that has the one line instruction -
%
%	C:\>copy az_ini.ps+az_proj.ps+africa.wdb+antarct.wdb+eurasia.wdb+n_amer.wdb+
%		oceania.wdb+s_amer.wdb+dxcc.dat+beacon.dat+ctrld.ps az_comb.ps
%		(all on one line)
%
%	for UNIX:
%		$ cat az_ini.ps az_proj.ps *.wdb dxcc.dat |lp
%
%	n.b. when using an Adobe Postscript equipped printer, You MUST
%	have an EOF character (ctrl D, ^D) at the end of the data stream .
%	Most printer spoolers designed for a PS printer will do this
%	but if they don't, you must explicitly supply it. The file
%	'ctrld.ps' (supplied with azproj), can be used for this task,
%	as in the DOS example above.
%
%Ghostscript processed files
%	Ghostscript is a program, run on a computer, which interprets
%	the Postscript language and outputs print codes suitable for
%	specific printers and screens.
%	Ghostscript knows about files. You can send multiple .WDB
%	files to ghostscript as command line parameters.
%
%	MS-DOS:
%	The command line for screen viewing (see AZVIEW.BAT), would then be
%	C:\> gs386 -q az_ini.ps -- az_proj.ps n_amer.wdb dxcc.dat
%
%	To create to a print file `n_amer.cdj' (see AZPRINT.BAT),
%	which can then be sent to a HP deskjet 550 (all on one line)
%	gs386 -q -sDEVICE=cdj550 -sOutputFile=n_amer.cdj az_ini.ps --
%		az_proj.ps n_amer.wdb dxcc.dat
%
%	Note that the MSDOS command PRINT will only work for ascii files.
%	The file n_amer.cdj is binary must be printed using something like
%	C:>copy/b n_amer.cdj lpt1:
%	(Better to use a good DOS spooler like the shareware dmp)
%
%	The following command sends directly to PRN
%	gs386 -q -sDEVICE=cdj550 az_ini.ps -- az_proj.ps n_amer.wdb dxcc.dat
%
%	UNIX: to send directly to the printer
%	(without creating an intermediate file):
%	gs -q -sDEVICE=cdj550 '-sOutputFile=|lp -or -onb' \
%		-r300 -dNOPAUSE az_ini.ps -- az_proj.ps n_amer.wdb dxcc.dat

%--------------------------------------
% Credits, Thanks and more explanations

% WDB files
%	The data files come from the Micro World Data Bank II (MWDB-II).
%	Mike Owen W9IP pointed us to this resource.
%	The binary data was converted by one of the utility programs
%	in the set, to the ASCII form used here (the .wdb files).
%	Each line in the .wdb files has the form
% integer	lat	lon	comment
%	representing a point on the earth's surface. If the integer
%	is a 4 digit number then this point is the start of
%	a new path (ie line) to be drawn on the earth's surface.
%	1.1.6 make this 5 digits
%	The four digit integer is a label showing -

	% 1xxx, coast lines
	% 2xxx, country borders
	% 3xxx, Canadian Provinces
	% 4xxx, US state borders
	% 5xxx, islands
	% 6xxx, lakes
	% 7xxx, rivers
	% 8xxx, Australian States
	% 9xxx, USA call areas (subset of USA states)
	%11xxx, county borders (only data for USA so far)

%	A new 4 digit integer terminates an old path and starts a new one.
%
%	If the integer is a single digit, it has the value 1..5 and
%	represents the resolution level (1 - highest detail, 5 - least detail).
%	If you want faster (and less detailed) plotting, then only the lower
%	resolution data need be used. We haven't had time to implement this
%	feature, consequently all data is plotted everytime. Anything in
%	the data line after the first three numbers is ignored by this
%	program. Comments or names of the features (eg `% Lake Baikal')
%	can be put at the end of the data line.
%
%	The original .wdb files, as extracted from the database, are sorted
%	into separate files for countries, coasts, rivers, lakes, islands etc.
%	If you are a VHF operator, you are more likely to be using data for
%	one continent, so I have manually sorted the data into continent files
%	(n_amer.wdb, oceania.wdb etc), each file having the coastlines,
%	countries, islands, states, rivers, lakes for that continent.
%	If you are plotting the top of Siberia using the file eurasia.wdb
%	and want N.A. to appear in the same plot, then you will have to
%	send the file n_amer.wdb to the printer as well.

%	Originally the lower numbered lines (eg 2xxx) were first in
%	the .wdb files. However if a river (6xxx) or lake (7xxx) is also
%	a political border, then the black political line is later
%	covered over with a green (river) or blue (lake) line.
%	In case you're looking for a black political borders, and don't
%	want them covered by a colored river, I've moved the rivers and lakes
%	to an earlier part of the WDB files. Thus the Rio Grande is a (green)
%	river in New Mexico, but as it travels south it becomes a (black)
%	border between Texas and Mexico. It looks a little weird to see a
%	colored line change back and forth to a black line. It's my best
%	solution so far. If you've any better ideas, let me know. If you're
%	watching the map being drawn on a screen, you will see the rivers
%	and lakes drawn before country and state borders.
%	A partial solution is to make the state borders dashed
%	(see /state_borders_dashed).
%
%	Mar 97, I've made the rivers wider than the political borders.
%	Since the political borders are drawn last, both colors are visible
%
%	The lines which describe the lakes are have been hand modified
%	so that they are now closed paths. So it is now possible to fill
%	a lake with one color or just to stroke the outline (see the
%	variable /lake_fill). (Anyone have the co-ords for Lake
%	Champlain, Lake Fromme... ?)
%
%	Here are some of the notations that come with the WDB -
%
%	"The full WDB-II is a digital map data base produced by the
%	Central Intelligence Agency (CIA) and distributed by the National
%	Technical Information Service (NTIS), U.S. Department of Commerce,
%	5285 Port Royal Road, Springfield, VA, 22161.
%	...
%
%	This documentation and the associated files are placed in the
%	public domain and may incorporated into other products without fee so
%	long as appropriate credits are included. An appropriate credit line
%	would be - "This product contains/uses data and/or code placed in the
%	public domain by Fred Pospeschil and Antonio Riveria. Original
%	coordinate data was created by the Central Intelligence Agency."
%
%	ALL USERS OF THESE MATERIALS ARE TOTALLY RESPONSIBLE FOR THEIR
%	USE AS THESE MATERIALS ARE PROVIDED WITHOUT EITHER EXPRESS OR IMPLIED
%	WARRANTIES OF ANY KIND."
%
%	- end of excerpt from the WDB docs.

% Routine GC
%	The routine gc was adapted from gc.c, Ver 1.01
%	S. R. Sampson, N5OWK, Public Domain (p) November 1989,
%	Ref: Air Force Manual 51-40, "Air Navigation", 1 February 1987

%	Astronomical Routines from sci.astro.faq.3-8
%	lazio@spacenet.tn.cornell.edu
%	http://astrosun.tn.cornell.edu/students/lazio/sci.astro.html
%	Since Postscript is only single precision, most of the
%	subtleties of these equations will be lost.

% Call/zone file (dxcc.dat):
%	The ARRL list of dxcc call zones in machine readable form
%	is maintained by Bill Brelsford, K2DI.
%	The file is available by ftp to
%	ftp.cs.buffalo.edu:/pub/ham-radio/dxcc-k2di
%	or by sending e-mail containing the line
%		send dxcc-k2di
%	to info@arrl.org
%	The listing we are using was updated in 1 Jul 94. Note that
%	while the .WDB files have been broken down into continents,
%	the dxcc.dat file is for the whole world. If you combine
%	only one continent file and the dxcc file, you will get
%	some dxcc names printed in the "sea".

%Annotation file (annotation):
%	To add a notation to the map, supply data in the form
%		annotate:Notation:Lat:Lon
%	eg.	annotate:NV3Z:38.98847N:76.58033W

%Beacon File
%	To add a beacon to the map, supply data in the form
%	beacon:frequency Callsign Grid_locator Power Direction
%	eg.	beacon:144.170 KH6HME BK29go 60 90 1
%	(if no beam direction is given or if it is 360, then it is omni)
%	(the trailing '1' is a flag to print the info below the symbol,
%	rather than on top, which is the default. The flag is optional)
%	The beacon file, bea_w3ep.dat, is maintained by Emil Pocock, W3EP.
%	Emil writes the `World above 50MHz' column in QST. Please send
%	beacon updates to Emil and we will get them from him.
%	Sorry, this file we have only has US beacons.
%	The 6m beacon file, bea_6m.dat, is from
%	M. Harrison, <poa01@cc.keele.ac.uk>.
%
%	CAVEAT: Some of the beacons are directional. Unless the
%	beacon is relatively close (say 500-100km depending on
%	the accuracy you're interested in), then the path of the
%	radio wave (which is following a great circle) will be
%	curved on the map (like the lines of constant longitude).
%	Only the great circle lines to and from the QTH are straight
%	on this projection. So if the beacon is pointing at you on
%	the azimuthal projection map it will be pointing at you in
%	physical reality too. However if the map says it is pointing
%	somewhere else, you may not even be able to guess the path
% 	of the radio wave on the map surface. For that you should do
%	a projection from the beacon's site.
%
%Repeater files:
%	A repeater file has the same format as a beacon file.
%	The lines start with r: and R: (rather than b: and B:),
%	so that repeaters can be differentiated from beacons.
%	Unfortunately the ARRL is not allowed to release the contents
%	of their repeater directory, because of a non-release clause
%	required by most repeater coordinators before parting with
%	their lists. Apparently repeater information is regarded as
%	proprietary by repeater coordinators. If you are able to pry
%	your local repeater coordinator's fingers off his list then
%	you can put repeaters on your map.
%

% NMEA capabilities - suggested by Paul Wade N1BWT, and with help
%	on the code specs by Mike Owen W9IP, an article by Wayne Simpson
%	forwarded by Paul, and a lead to a WWW site by Jim KC7MJ
% 	only GLL (Geog Lat/Lon)
% 	and BWC (bearing to waypoint along Great Circle) are implemented.
%
% 	for info on NMEA, see the file simpson.doc included in this package
%
%--------------------------------------
% Bugs & Caveats:
%
%Limitations
%1:	Can't do maps from the poles (directions are south and north
%	to everywhere respectively). You can make a map that looks just fine
%	from say (89.9,180.0) though. Be careful of the longitude
%	you pick as this will define the reference direction.

%2:	Reference Latitude and Longitude lines near the antipodes will
%	wrap around by crossing back across the map. If your QTH is exactly
%	on a plotted reference latitude, e.g. 15.00000 deg N, then try
%	entering 15.001 deg N instead.

%3:	Postscript can be very slow when implimented in some printers.
%	For a real postscript printer, maps take 20mins to 8hrs depending
%	on what you plot. Ghostscript running under DesqviewX
%	on a 33MHz 486 computer	takes *about* 1/2hr for plotting Nth America.
%	Running under MS-DOS, it takes just over 2 mins. The Ghostscript
%	screen viewer only takes a few minutes for small parts of the
%	earth's surface. Remember that if you send it the whole map
%	for Europe and are only looking at your local 100km, the
%	program still has to calculate the whole of Europe and Asia.
%	You might want to split off a particular part of your files
%	if you're going to do a lot of plots of one area.
%	If you re-sort any files like this into useful groupings
%	please send us the new files, as it may save someone doing
%	the same thing again.

%Problems near the poles:
%	Due to what appears to be the single precision arithmetic
%	of postscript, the routine "gc" cannot differentiate points close
%	together near the poles. It becomes impossible to calculate the
%	orientation of number labels near the pole for instance. These
%	calculations, when they result in a divide by 0 error, are trapped
%	and those labels are not drawn.

%Bugs:
%1:	Get a numeric exception if QTH = (0,0) and DEST = (90,90)
%
%2:	Elapsed time doesn't work in DesqviewX 2.0, with ghostscript 2.6.1
%
%3:	There are lots of comments to help you understand the code.
%	However this slows down operation when used on a native
%	Postscript printer particularly when fed by a serial line.
%	Solution: Create a copy and strip out all the comments.
%	You can remove comments with utilities like the freeware
%	CLNCODE2, available on your local BBS.


%Fiddles:
%Close points:
%	There are lots of problem points and discontinuities on a sphere
%	Points "near" the antipodes are given a bearing of 0 deg
%	Points closer than the numerical precision (= very_small_distance)
%	are given a bearing of 0 deg. To be safe, I've defined
%	"very_small_distance" to be just smaller than the resolution
%	of the data. The resolution of the WDB, is 1min of arc = 0.016 deg
%	(1 mile at the equator). The ASCII translation of the database
%	is given to 3 figs i.e. 0.001 deg, although the original data
%	is only accurate to 0.016 degree.
%
%	"very_small_distance" is the distance in degrees at which the
%	routines will assume that DEST=QTH. This trap is to stop the
%	bearing determining routine from blowing up when trying
%	to determine the bearing to yourself from yourself, with
%	limited precision calculations. In choosing this quantity,
%	anything less than the smallest interval being plotted is OK.
%

%Distant points:
%	The bearing to points at the antipodes is not defined.
%	Distances close to the antipodes are trapped and a
%	bearing of 0 will be returned.



%--------------------------------------

/starttime usertime def
	% gives bogus chars (nulls?) which cause a crash in Irix
	% gives a nonsense value with ghostscript running under DesqviewX
	% but sensible numbers everwhere else

%--------------------------------------

%initialise and declare a few things

%strings, defined here to stop it chewing up VM
/grid_string 10 string	def
/name	10	string	def
/COMMA	(,)	def
/CR	(\r)	def
/LF	(\n)	def
/temp_string 10 string def

%Conversions	% Distances: All distance calculations are done in degrees
							% along great circles, assuming a spherical earth.

/km2deg		{ 10000 div 90 mul }	def
/deg2km		{ 10000 mul 90 div }	def
/NM2deg 	{360 mul 21600 div} 	def	%Nautical Miles
/M2deg 		{360 mul 25000 div} 	def	%Statute Miles (25000 or whatever the circumference is)
/cm		{ 28.35 mul }		def	% points in a centimeter
/points2cm	{ 28.35 div }		def


%Routines
% Only define arccos if it is not built in (as in ghostscript)
systemdict /arccos known not { /arccos /Arccos cvx def } if

%other useful things
/very_small_distance	0.001 def
/distance_to_antipodes	180.0 very_small_distance sub def
/incr_lim 1.0e-3 def
/pi	3.1415927	def

% we need to remember the scale in km/cm
scale_type {map_scale_deg /map_scale_km exch def} if

%--------------------------------------
% send_notices used to be defined separately in az_ini.ps
% now I make them the same and just turn everything on or off all at once
%
/send_notices verbose def
%--------------------------------------
/print_notice	% will send notices to stdout if send_notices true
{
	send_notices { print flush }{ pop } ifelse
} bind def

%--------------------------------------
/verbose_notice	% will send notices to stdout if send_notices & verbose true
{
	send_notices verbose and { print flush }{ pop } ifelse
} bind def
%--------------------------------------
%Grid square nomenclature:
% The 2x1 degree "squares" are described by a pair of letters,
% eg. FM for Mid Atlantic USA.
% In this program the 2x1 deg squares are called "letter_squares"
%
% The 0.2x0.1 degree squares are described by a pair of numbers,
% eg. 19 for Washington, DC area.
% In this program the 0.2x0.1 deg squares are called "number_squares"
% The number squares are useful for VHF operators operating over
% short distances. If drawing a large map (radius > 50 degrees)
% then the number squares are turned off automatically.
% Irrespective of the scale being plotted, all (i.e. the whole
% world) of the letter grid squares are calculated (even if you
% are only plotting 100 km out from your QTH). We haven't
% figured an automatic way that can short circuit this process.

%--------------------------------------
% linewidths of map features (in atom units = 1/2000 * picture height)
/feature_width
[
	2.0	% coast lines
	1.0	% country borders
	1.0	% Canadian Provinces
	1.0  	% US state boundaries
	2.0	% islands
	1.0	% lakes
	1.5	% rivers, countries are written after rivers, make rivers wider
	1.0	% Australian State boundaries
	1.5	% USA call areas
	1.0	% not used
	1.0	% county borders
] def

%--------------------------------------
/center_show
%centers string in x on current point
%string on stack, have current point, font, fontsize etc
{
      dup stringwidth pop 2 div neg 0 rmoveto
      show
} def

%--------------------------------------
/centerxy_show
%never got this to work
%centers string in x and y on current point
%string on stack, have current point, font, fontsize etc
{
	%dup stringwidth pop 2 div neg 0 rmoveto
	%dup stringwidth
	%%fix vertical
	%1 div neg
	%%fix horizontal
	%exch 2 div neg
	%exch rmoveto

	dup
	false charpath % add path of string
	pathbbox	% find bbox of path
	%on stack  llx lly urx ury
	exch	%now llx lly ury urx
	3 1 roll	%now llx urx lly ury

	sub 2 div  	%average y
	3 1 roll	%push it below llx urx
	sub 2 div
	exch
	rmoveto	%move back half of pathbbox
      show
} def

%--------------------------------------
% handy numbers to make code readable

/coast_line		1	def
/country_border		2	def
/political_states	3	def
%/not_used		4	def
/island			5	def
/lake			6	def
/river			7	def
/opposite_countries	8	def
/USA_call_areas		9	def
/county_border		11	def

%--------------------------------------
%Symbols: The routines for symbols have been written on a one-by-one basis.
%Each data type (beacon, repeater, mountain...) thus has its own way
%of handling the problem of drawing a symbol. Clearly it would be a lot
%simpler if the handling of symbols followed one scheme. Obviously I should
%rewrite them. However, under the constraints of limited time, when I have
%to choose between writing some new code that would be useful or fixing
%something that works (but is inelegant), I've chosen to write new code.
%I will probably keep doing that. Ce la vie. Joe
%
%--------------------------------------
% resolution bins
% The wdb map data has a resolution parameter with each point.
% 1 highest resolution, 5 lowest resolution.
% At one stage I think I knew what resolutions they were
% (1 maybe about a mile, 5 about 20miles) but I've forgotten now.
% Drawing high resolution data for a map of the whole world
% on a map 20cm across is a waste of computing time, if you're
% in a hurry. Here the cutoffs for each resolution are set. It was all
% done emperically, till I could see no improvement in the maps.
% Unless you change the size of the paper on which you draw your
% maps, you won't need to change these.
%
% Note that points (say) 100km apart are much further apart on the projection
% if they happen to be further away from the center of the projection. So to
% get good resolution at the edge of the map, points need to be plotted
% at higher resolution than needed for just the center of the map.
% For maps of just local areas where the mapping is much more linear,
% then the distances separating points is about the same over the whole
% displayed area.
%
% With the defaults shown here, a map of scale 250km/cm will display
% points of resolution 3,4 and 5, but not 1 or 2.
% If you want to display only resolution_5 for a map of scale==100km/cm
% then set the numbers for resolution bins 1-4 to be < 100.
%
% To force use of only lowest resolution data (resolution_5)
% then change scale_to_include_resolution_x where x==1..4 to a
% number less than your map scale (say make it 50)
% To force high resolution, change all numbers to >=2000

plotting_resolution (auto) eq
	{
	%(plotting_resolution: auto) print_notice
	%Set to maximize drawing speed
	/scale_to_include_resolution_1  50 def
	/scale_to_include_resolution_2  200 def
	/scale_to_include_resolution_3  800 def
	/scale_to_include_resolution_4  20000 def
	/scale_to_include_resolution_5  20000 def
	} if

plotting_resolution (high) eq
	{
	%(plotting_resolution: high) print_notice
	%This set forces high resolution for all scales
	/scale_to_include_resolution_1  20000 def
	/scale_to_include_resolution_2  20000 def
	/scale_to_include_resolution_3  20000 def
	/scale_to_include_resolution_4  20000 def
	/scale_to_include_resolution_5  20000 def
	} if

plotting_resolution (low) eq
	{
	%(plotting_resolution: low) print_notice
	%This set forces low resolution for all scales
	/scale_to_include_resolution_1  1 def
	/scale_to_include_resolution_2  1 def
	/scale_to_include_resolution_3  1 def
	/scale_to_include_resolution_4  1 def
	/scale_to_include_resolution_5  20000 def
	}if

%--------------------------------------
/mod_360
%takes number on stack (angle)
%adds or subtracts 360, till it's in the range 0.0-359.9
%pushes back on stack

{
%(mod_360: start \n) print_notice pstack

	{
	%(mod_360: start 1\n) print_notice pstack
	dup 360 lt {exit}{360 sub} ifelse
	%(angle > 360: lowering \n) print_notice pstack
	} loop

	{
	%(mod_360: start 2\n) print_notice pstack
	dup 0.0 ge {exit}{360 add} ifelse
	%(angle < 0.0: raising \n) print_notice pstack
	} loop
%(mod_360: end \n) print_notice pstack
}def %mod_360


%--------------------------------------
/mod_180
%takes number on stack (angle)
%adds or subtracts 360, till it's in the range -179.99 to 180
%pushes back on stack

{
%(mod_180: start \n) print_notice pstack

	{
	%(mod_180: start 1\n) print_notice pstack
	dup -180 le {360 add mod_180}{exit} ifelse
	%(angle > -180: OK \n) print_notice pstack
	} loop

	{
	%(mod_180: start 2\n) print_notice pstack
	dup 180 gt {360 sub mod_180}{exit} ifelse
	%(angle < 180: OK \n) print_notice pstack
	} loop
%(mod_180: end \n) print_notice pstack
}def %mod_180

%--------------------------------------
/mod_90
%takes number on stack (angle)
%adds or subtracts 180, till it's in the range -89.99 to 90
%pushes back on stack

{
%(mod_90: start \n) print_notice pstack

	{
	%(mod_90: start 1\n) print_notice pstack
	dup -90 le {180 add mod_90}{exit} ifelse
	%(angle > -90: OK \n) print_notice pstack
	} loop

	{
	%(mod_90: start 2\n) print_notice pstack
	dup 90 gt {180 sub mod_90}{exit} ifelse
	%(angle < 90: OK \n) print_notice pstack
	} loop
%(mod_90: end \n) print_notice pstack
}def %mod_90

%--------------------------------------
%Gridsquare Lat/Lon line switches

lat_lon_lines (none) eq
	{
	%(lat_lon_lines: none ) print_notice
	%turn everything off
	/draw_lat_lon_lines 		off	def
	/draw_letter_square_borders	off	def
	/draw_letter_square_labels	off	def
	/draw_number_square_borders	off	def
	/draw_number_square_labels	off	def
	} if % no lat/lon lines, turn everything off

lat_lon_lines (lat_lon) eq
	{
	%(lat_lon_lines: lat_lon ) print_notice
	%turn on lat/lon lines
	/draw_lat_lon_lines 		on	def
	} if %

lat_lon_lines (gridsquares) eq
	{
	%(lat_lon_lines: gridsquares ) print_notice
	%turn off lat/lon lines
	%the routines which draw gridsquares will then look
	%at the values of draw_letter_square_borders etc
	%to see what to draw.

	/draw_lat_lon_lines 		off	def
	} if %

%--------------------------------------

/draw_tower
%originally designed as symbol for Broadcast Stations.
%However beam heading info is available for US TV stations
%so the symbol originally used for beacons can be substituted (see az_ini.ps for /draw_BC_symbol)
%
%requires global /transmitter_power (int, parsed from data line of .dat file, unit=Watts)
%         global /tower_size 	%int, width of tower base
				%defined in az_ini.ps,
				%displayed in units of atoms
%
%when this routine is called, lat/lon for the currentpoint are globals
%
%The symbol is a self supporting (un-guyed) needle type tower, with the base of the tower at the transmitter location.
%Transmitter power is shown in the symbol by one section for each 10^n W of power
%(minimum of one section of tower). Thus
% 1W->1 section
% 10W->1 section
% 100W -> 2 sections
% 5000W -> 3 sections
% 9999W _> 3 sections
% 10000W -> 4 sections
%

{
	%(draw_tower: \n) print_notice pstack

	%use transmitter_power to set number of sections of tower
	transmitter_power dup 0.0 le {pop 0}{log cvi} ifelse /number_of_tower_sections exch def %

	newpath
	fine_gl_width master_line_width_factor mul 0.5 mul setlinewidth

	lat lon lat_lon2xy moveto


	%make base of tower (horizontal line)
	%at center of base, move to LH edge
	tower_size neg 2 div 0 rmoveto
	%draw to RH bottom of base
	tower_size 0 rlineto

	%loop, putting in tower sections, 1 for each power of 10^n Watts

	number_of_tower_sections -1 1
	{
		pop	% loop counter
		%(draw_tower: section \n) print_notice
		0 tower_size 2 mul rlineto
		tower_size neg 0 rlineto
        	tower_size tower_size neg rlineto
        	tower_size neg tower_size neg rlineto
		0 tower_size 2 mul rlineto
		tower_size 0 rlineto
	} for %make sections
	stroke

	az_dict /number_of_tower_sections undef
} def
%--------------------------------------
/draw_nested_circles
%code derived from Print_Beacon (AZ_PROJ v1.00)
%
%
% Draws nested circles as a transmitter symbol.
% If the station is directional, then at 70deg wide fan is drawn, for each radiated lobe
%
% For Ham beacons, which are relatively low power, ie 1mW < P < 100W
%draws one circle for each bm (bell miliwatt),
%1 circle for 1mw
%4 circles for 10W (also for 99W)
%4 circles for 99W (also for 99W)
%5 circles for 100W
%
% For TV stations which are high power, ie 1000W < P <100,000W (generally)
% one circle for each bW (bell W)
%1 circle for 1W
%3 circles for 1000W
%3 circles for 9999W
%4 circles for 10000W
%
% If a ham beacon and a TV station are plotted on the same map
% then a 10W ham beacon, will have the same size as a 10KW TV station
% To differentiate the two symbols, a thicker black complete circle is drawn
% at the 1W level for both symbols.

%
%requires the global variable transmitter_power
%requires the globals lat/lon for the symbol location
%color is set in calling routine, so can be called for different colors
%requires the global beam_heading_array
%	(list of int, one for each lobe,
%	most ants are omni, a few have one lobe,
% 	even fewer have several lobes,
%	mostly 2 from a horizontal dipole)
{
	% This routine was originally written for beacons with at most
	% one main lobe (the rest being omnidirectional)
	% A multilobed radiator (the only examples being dipoles radiating NW,SE say)
	% was handled by 2 entries in the transmitter list.
	% The beam heading was a global variable /beam_heading.
	%
	% With v1.04 multiple lobes are handled by a comma separated list
	% in the transmitter line, which becomes /beam_heading_array in
	% the routine /draw_transmitter.
	%
	% Here /beam_heading_array is parsed, one int at a time, and the nested
	% circles are drawn again for each entry. This duplicates some
	% of the drawing done on the page, but what the hell, the computer
	% is doing it, not me, and it saves rewritting a routine that works.

	beam_heading_array
	{
		% Draw a nested circle symbol for each beam_heading.
		% much of the symbol will be drawn multiple times
		% but this seems the easiest way of implementing
		% multiple beam_headings
		%
		%(draw_nested_circles: \n) print_notice pstack
		/beam_heading exch def

		%(draw_nested_circles: beam_heading \n) print_notice beam_heading pstack pop

		beam_heading -1 eq
			{
			%omnidirectional
			/beam_half_width 179.999 def
			/beam_heading 360 exch def
			}
			{
			%directional, assume a 70deg beam width
			/beam_half_width 35 def
			%boost power a bit to show antenna gain
			transmitter_power 3 mul /transmitter_power exch def
			} ifelse

		% correct directional distortion for points not near center of map
		% eg a beacon pointing 270 deg, will be plotted pointing to the LHS of the paper
		% rather than pointing parallel to a latitude line
		% you can check that this is working by making all the beacon beam_heading to be 0,90,180,270
		% and seeing that the beacon is pointed parallel to adjacent lat and lon lines
		correct_azimuth

		%one circle for each 10^n W of power
		%power levels go from 1mW (10GHz beacons) to 100KW (TV stations)
		%number_of_circles is -3 to >5
		/number_of_circles transmitter_power dup beacon_default_power le { pop 0 }{ log cvi } ifelse  def

		% if beacon or repeater, increase number of circles by 3
		transmitter_type dup (beacon) eq exch (repeater) eq or {number_of_circles 3 add /number_of_circles exch def} if


		%(draw_nested_circles: number_of_circles transmitter_power \n) print_notice transmitter_power number_of_circles pstack pop pop

		gsave
			lat lon lat_lon2xy translate

			% N for compass is -90 in cartesian
			450 beam_heading sub rotate

			% draw thick circle for 1 Watt level
			gsave	% save current color
				%coarse_gl_width master_line_width_factor mul 2 mul setlinewidth
				fine_gl_width master_line_width_factor mul 2 mul setlinewidth
				newpath
				black setrgbcolor
				0 0 nested_circle_size
				% set circle size, if beacon, is 3th ring, else is 0th ring
				transmitter_type dup (beacon) eq exch (repeater) eq or {3}{0} ifelse
				1 add % give a radius of 1 to the 0th circle
				mul 0 360 arc stroke
			grestore

			fine_gl_width master_line_width_factor mul setlinewidth
			% draw circles down to 1mW level

			number_of_circles -1 1
			{
				/counter exch def
				newpath
				0 0 nested_circle_size counter 1 add mul 360 beam_half_width sub beam_half_width arc
				stroke
			} for
		grestore
	}forall % beam_headings in beam_heading_array
} def

%--------------------------------------
/draw_repeater_symbol
{
	%assuming that repeaters and beacons will not be drawn on same map
	%as they have the same symbol
	%(you can give them different colors in az_ini.ps)_
	draw_nested_circles
}def

%--------------------------------------
% Greyline switches:
% As of v1.1 these have been moved here from az_ini.ps
% The switches are read from az_ini.ps or the map server
% and are sorted out here. The actual greyline routines
% are somewhere else.

%GREYLINE (border between day and night)
% Part A, Greyline at any particular date/time
%
% The Greyline is the line of day/night on the earth's surface. Enhanced
% propagation occurs along this line in the lower HF bands. The location
% of this line varies not only for the time of day, but throughout the year
% as the sun goes from the northern to the southern hemisphere.
% The greylines are greatcircles and look much like the longitude
% greatcircle lines.
%
% The program allows you to draw a single greyline
% for a particular date/time(UTC)/QTH and to shade/not_shade
% the nighttime part of the earth.
% You can use this feature to tell whether it's
% day or nighttime at some location of interest.
% The algorythm used for this is simple and quick
% It asumes an earth in a circular orbit about the sun
% and assumes that the sun crosses the meridian at local noon.
% It also assumes that the earth is in the same position
% in its orbit on the same date each year
% (ignores 1/4 day difference each year due to leap years).
% Thus the algorythm doesn't need to know the year.
% The algorythm can be in error by upto 16 mins.
% This is not a particularly large error (IMHO) if you're just
% trying to see if it's day or night somewhere.

%Greylines drawn in arbitary positions on the earth's surface
%

%/greyline_type	(none)				def	% default
%%/greyline_type	(greyline_by_date_time)		def	% draw greyline for date/time below (see /month /day /hour), these greylines may have no particular relationship to sunrise/set at your QTH.
%%/greyline_type	(sunrise_at_QTH)		def	% draw sunrise and sunset lines for date below (hour is ignored)
%%/greyline_type	(sunset_at_QTH)			def	% draw greyline at sunset for your QTH throughout the year
%%/greyline_type	(sunrise_and_sunset_at_QTH_by_date)	def	% draw greyline at sunset for your QTH throughout the year



(none) greyline_type eq
(sunrise_at_QTH) greyline_type eq or
(sunset_at_QTH) greyline_type eq or
(sunrise_and_sunset_at_QTH_by_date) greyline_type eq or
{
/draw_greyline_by_timedate	off	def	% day/night border, drawn at arbitary position on earths surface
} if

(greyline_by_date_time) greyline_type eq
{
/draw_greyline_by_timedate 	on	def
} if
				% off - no terminator
				% on  - draw line on earth where the sun is rising/setting
				% time and date chosen below

% This next one is for my debugging - you can leave this next one alone.
/greyline_draft_mode	off	def	%on  - jaggy  edges of greylines
					%off - smooth edges of greylines

%--------------------------------------
% More Greyline
% Part B, The position of the Greyline at a QTH throughout the year.
% Options available in v1.03.
%
% Mad 80 an 160m DX hunters can draw greylines through 
% your QTH for various times of the year to see
% when or if it's even possible to work that 317th country by greyline.
% For this I've used a model with an eliptic orbit for the earth.
% To remind you that the sun it not always at the meridian at
% noon, I've included some optional visual candy, the analemma,
% a series of dots at 1/2 month intervals, which trace a figure "8"
% showing the locus of the sun at clock noon (! sun on the meridian).
% A fidicidal mark is provided, by a larger dot for 22 March,
% to allow you to determine the direction the sun takes
% along the analemma during the year.
%
% If the earth were in a circular orbit around the sun then
% the dawn greyline for a particular date will be the same
% as the evening greyline for a date 6months later
% (the day and night sides of the line are exchanged though).
% In the circular orbit case, all the useful greyline
% information is available by plotting either dawn or
% evening greylines at 1 month intervals for (say) Jun-Dec
% and interpolating the greyline positions for dates in between.
% In this way a single map with 7 greylines could give all
% information needed to see if a country is "greyline-able".
% However in the more accurate model, the earth is at a different
% distance from the sun for dates 6 months apart and the greylines are
% different (not much, but you can see the difference in the maps).
% As well the maps are different for dates symmetrical about
% the solstices (again not much). I haven't been able to
% check whether the differences I see are correct or not.
%
% I would suggest initially making one map at one month intervals
% for Jun-Dec and another for Dec-Jun. You can make separate
% maps for dawn and evening (since you're unlikely to be doing
% both at the same time) and see what the differences are.
%
% I haven't figured a convenient way of labelling each greyline.
% For the moment I've drawn the position of the sun for each greyline.
% The line from the sun to your QTH will be normal to the greyline.
% You can figure the date of the greyline from the declination of the sun
% (22 Jun +23.5 deg, 22 Mar and Sep 0 deg, 22 Dec -2.35 deg).
%
% BUGS:
% 1. It is not possible in the routine used here to do the azimuthal
% projection to plot a point at the poles. Thus it's not possible to
% draw a greyline that goes through the poles (the routine will draw
% a random mess and recover so that the program will continue
% executing). So don't draw greylines for the exact equinoxes
% (one day either side is OK though).
%
% Trapped conditions:
% Sometimes there is no sunrise/set at a particular QTH/date (near the poles)
% Requests to calculate these times are trapped and the routines will not be
% executed. Neither the sun position nor the terminator will be drawn.
%

% Terminator lines drawn through your QTH (ie at sunrise and sunset).
%
% if you want to see the whole greyline, set scale to show the whole world, ie 2000km/cm
%

% greyline_type will be one of the following (from az_ini.ps)
%/greyline_type	(greyline_by_date_time)		def	% draw greyline for date/time below (see /month /day /hour), these greylines may have no particular relationship to sunrise/set at your QTH.
%/greyline_type	(sunrise_at_QTH)		def	% draw sunrise and sunset lines for date below (hour is ignored)
%/greyline_type	(sunset_at_QTH)			def	% draw greyline at sunset for your QTH throughout the year
%/greyline_type	(sunrise_and_sunset_at_QTH_by_date)	def	% draw greyline at sunset for your QTH throughout the year



(sunrise_at_QTH) greyline_type eq
(sunrise_and_sunset_at_QTH_by_date) greyline_type eq or
{
/draw_sunrise_greylines on	def
}
{
/draw_sunrise_greylines	off	def	%off/on
}ifelse

(sunset_at_QTH) greyline_type eq
(sunrise_and_sunset_at_QTH_by_date) greyline_type eq or
{
/draw_sunset_greylines  on	def
}
{
/draw_sunset_greylines	off	def	%off/on
} ifelse

(sunrise_and_sunset_at_QTH_by_date) greyline_type eq
{
/greyline_months_plotted_array
[
month
]def

/greyline_days_plotted_array
[
day
] def
} if

%{
%/greyline_months_plotted
%% mask for selecting months for plotting greylines
%% must contain only integers in the range 1..12
%%
%% the greylines will be drawn at 1 month intervals on the 21st of the month
%% (or you can change the code in /calculate_sunrise_sunset)
%% suggest draw 6 months at a time e.g. jun-dec.
%%
%% This array can have any number of elements (including none).
%% Only one element allowed per line, lines in any order.
%% Add, remove or comment (have "%" in front of number) out elements to suit.
%[
%%1
%%2
%%3
%%4
%%5
%6
%7
%8
%9
%10
%11
%12
%]def	% (1..12)
%}ifelse %if drawing one month in particular, or all of them

%--------------------------------------
/day_number
% needs year, month (1..12), day (1..31) (int)
% and UT (real, hours.decimal)
% pushes day_number on stack
% to test, day_number is 0.0 at 2000-01-00 (0 Jan 2000)
{
	year 367 mul
	730530 sub
	%(day_number: \n) print_notice pstack
	month 9 add 12 idiv year add 7 mul 4 idiv sub
	%(day_number: \n) print_notice pstack
	month 275 mul 9 idiv add
	%(day_number: \n) print_notice pstack
	day add
	%minute 60 div hour add 24 div add
	%bug fixed in v1.1beta3, was UT add,
	%which added 12 days to dates for sunrise/set at any QTH
	%whoops
	UT 24 div add
	%(day_number: \n) print_notice pstack pop
}def

%--------------------------------------
/suns_RA_DEC
% new in v1.04
% takes day_number from stack
% returns suns_RA, suns_DEC as globals
{
%(suns_RA_DEC: day_num \n) print_notice pstack
/day_num exch def

%the obliquity of the ecliptic (23.5 deg, the tilt that causes the seasons)
23.4343 3.563 10000000 div day_num mul add /obl_ecl exch def
%(suns_RA_DEC: obl_ecl \n) print_notice pstack

%arguement of perihelion
282.9494 4.70935 100000 div day_num mul add /arg_perihelion exch def
%(suns_RA_DEC: arg_peri \n) print_notice pstack

%mean anomaly
356.0470 0.9856002585 day_num mul add /mean_anomaly exch def
%(suns_RA_DEC: mean_anom \n) print_notice pstack

%eccentricity
0.016709 1.151 1000000000 div day_num mul add /eccentricity exch def
%(suns_RA_DEC: eccent \n) print_notice pstack

%eccentric anomaly
mean_anomaly
eccentricity 180 mul pi div mean_anomaly sin mul
eccentricity mean_anomaly cos mul 1.0 add mul add
/eccentric_anomaly exch def
%(suns_RA_DEC: eccent_anom \n) print_notice pstack

% the intermdiate quantities "A" and "B"
eccentric_anomaly cos eccentricity sub /A exch def
eccentric_anomaly sin eccentricity dup mul neg 1.0 add sqrt mul /B exch def
%(suns_RA_DEC: A,B \n) print_notice pstack

%sun's distance
A dup mul B dup mul add sqrt /suns_distance exch def
%sun's true anomaly
B A atan /suns_true_anomaly exch def
%sun's true longitude
suns_true_anomaly arg_perihelion add /suns_true_lon exch def
%(suns_RA_DEC: dist, lon \n) print_notice pstack


%we're getting there
%suns declination
suns_true_lon sin obl_ecl sin mul arcsin /suns_DEC exch def
%(suns_RA_DEC: DEC \n) print_notice suns_DEC pstack pop

%suns right ascension
suns_true_lon sin obl_ecl cos mul suns_true_lon cos atan /suns_RA exch def
%(suns_RA_DEC: RA \n) print_notice suns_RA pstack pop

% clean up dict

az_dict /day_num undef
az_dict /obl_ecl undef
az_dict /arg_perihelion undef
az_dict /mean_anomaly undef
az_dict /eccentricity undef
az_dict /eccentric_anomaly undef
az_dict /A undef
az_dict /B undef
az_dict /suns_distance undef
az_dict /suns_true_anomaly undef
az_dict /suns_true_lon undef

} def
%--------------------------------------
/sidereal_time
%v1.04
% calls day_num,
% pushes sidereal_time on the stack
{
	%(sidereal_time: day_number \n) print_notice day_number pstack pop
	%Jan 1 - Mar 22 = 81, fudge factor because year doesn't start at 22 Mar
	%varies approx -.25 day/yr and is reset for each leap yr
	99 % 180 - 81 *(360/365.2422) ca 100, is fudged to park the analemma on the prime meridian
	360 365.2422 div day_number mul add
	UT 15 mul add %orig code
	%UT 15 mul sub % if want analemma at local noon

	lon_QTH add %orig code
	%lon_QTH sub %if want analemma on lon=0 line
	%lon_QTH sub %if want analemma on lon=0 line

	mod_360 %sidereal time on stack
	%(sidereal_time: \n) print_notice pstack

}def %sidereal_time

%--------------------------------------
/day_number2az_alt
{
	%needs
	% on stack: day_number,
		%day_number being calculated for UT=12 (indirectly gives lon_QTH)
	% global: lat_QTH
	%
	%returns
	% global: azimuth	- sun's azimuth
	% global: altitude	- sun's altitude


	%(day_number2az_alt: day_number \n) print_notice pstack
	suns_RA_DEC	%generates suns_RA and suns_DEC (globals)
	sidereal_time suns_RA sub /hour_angle exch def
	hour_angle mod_360 /hour_angle exch def
	%(calculate_sunrise_sunset: hour_angle of sun \n) print_notice hour_angle pstack pop

	%azimuth of sun
	hour_angle sin
	hour_angle cos lat_QTH sin mul
	suns_DEC tan lat_QTH cos mul sub
	%(calculate_sunrise_sunset: tan_az 1,2 \n) print_notice pstack
	atan /azimuth exch def
	% by this convention, south is 0 deg
	180 azimuth add dup 360 gt {360 sub /azimuth exch def}{/azimuth exch def} ifelse
	% now north is 0 deg
	%(calculate_sunrise_sunset: azimuth \n) print_notice azimuth pstack pop



	%altitude of sun
	lat_QTH sin suns_DEC sin mul
	%(calculate_sunrise_sunset: sin_h 1\n) print_notice pstack
	lat_QTH cos suns_DEC cos mul hour_angle cos mul
	%(calculate_sunrise_sunset: sin_h 2\n) print_notice pstack
	add
	/sin_h exch def
	sin_h arcsin /altitude exch def
	%(calculate_sunrise_sunset: altitude  \n) print_notice altitude pstack pop
	% calculate altitude
	% there's a trap here. as orig written, the altitude is measured
	% from the southern horizon if the sun is in the south
	% and from the northern horizon if the sun is in the north,
	% i.e. altitude < 90 deg. Altitude thus corresponds to elevation as I know it
	% If the sun were only on the meridian,
	% then it would make sense to have the altitude
	% increase monotonically as the sun goes from
	% south to north over your head.
	% To get this numerical answer you would have to flip the
	% altitude to 180-altitude as the sun went overhead.
	% However if you leave the altitude as it is,
	% it is possible to draw loops of iso-altitude on a map.
	% This is not possible if you do an altitude flip.
	% Loops that were drawn on points directly E or W
	% would run into problems
	% (haven't thought about the full ramifications although it looks nasty).
	%
	% However if you want to measure altitude from the southern horizon
	% If the DEC of the sun puts it north of the lat_QTH then use (180-altitude)

	%suns_DEC lat_QTH gt
	%	{
	%	180 altitude sub /altitude exch def
	%	(calculate_sunrise_sunset: inverting altitude \n) print_notice altitude pstack pop
	%	} if

}def	%day_number2az_alt

%--------------------------------------
/analemma
{
%draw an analemma for the sun
% only do on 7th and 21st of month
12 /UT exch def
1 1 12
	{
	/month exch def
	7 14 30	%do on 7th 21st of month
		{
		/day exch def
		day_number
		day_number2az_alt


		%altitude and azimuth of the sun, at noon
		%are the same for mapping purposes as distance and bearing,
		%ie they're in degrees and you can plot the position of the sun
		black setrgbcolor
		newpath
		90 altitude sub azimuth distance_bearing2xy moveto
		90 altitude sub azimuth distance_bearing2xy
		% make the radius of the dot bigger for 21 Mar
		% numbers inside squiggly breackets are sizes of dots in atoms
		%month 3 eq day 21 eq and {5}{2.5} ifelse
		month 3 eq day 21 eq and {5}{2.5} ifelse
		atom mul 0 360 arc fill closepath
		} for % days of month
	} for % each month
} def %analemma

%--------------------------------------
/sunrise_greyline
%needs globals: lon_QTH, HA0 (hour angle 0), suns_DEC (from suns_RA_DEC)
%output: draws line on map

% to calculate terminator position
% 1. calculate position of sun at sunrise or sunset
% 2. calculate bearing to sun
% 3. draw line with bearing at 90deg to position of sun

{
  	%sunrise sun position
  	lon_QTH HA0 add mod_360
  	/sun_lon exch def
	%(sunset_sunrise: sunrise sun_lon \n) print_notice sun_lon pstack
  	suns_DEC /sun_lat exch def
	greyline_sunrise_color setrgbcolor
  	/sun_color 	/greyline_sunrise_color cvx def
  	draw_sun_symbol

	%sunrise terminator
	newpath
	fine_gl_width master_line_width_factor mul setlinewidth
	sun_lat sun_lon
	%(sunset_sunrise: sun_lat sun_lon \n) print_notice pstack
	gc
	%(sunset_sunrise: dist bearing \n) print_notice pstack
	90 add /suns_bearing exch def % bearing
	pop % distance
	180 % distance
	suns_bearing
	distance_bearing2xy
	%(sunset_sunrise: x y \n) print_notice pstack
	moveto
	180 suns_bearing 180 add distance_bearing2xy
	%(sunset_sunrise: x y \n) print_notice pstack
	lineto
	stroke
}def %sunrise_greyline

%--------------------------------------
/sunset_greyline
%needs globals: lon_QTH, HA0 (hour angle 0), suns_DEC (from suns_RA_DEC)
%output: draws line on map

% to calculate terminator position
% 1. calculate position of sun at sunrise or sunset
% 2. calculate bearing to sun
% 3. draw line with bearing at 90deg to position of sun
{
  	%sunset sun position
  	lon_QTH HA0 sub mod_360
  	/sun_lon exch def
	%(sunset_sunrise: sunset sun_lon \n) print_notice sun_lon pstack
  	suns_DEC /sun_lat exch def
	greyline_sunset_color setrgbcolor
  	/sun_color 	/greyline_sunset_color cvx def
  	draw_sun_symbol


	%sunset terminator
	newpath
	fine_gl_width master_line_width_factor mul setlinewidth
	sun_lat sun_lon
	%(sunset_sunrise: sun_lat sun_lon \n) print_notice pstack
	gc
	%(sunset_sunrise: dist bearing \n) print_notice pstack
	90 add /suns_bearing exch def % bearing
	pop % distance
	180 % distance
	suns_bearing
	distance_bearing2xy
	%(sunset_sunrise: x y \n) print_notice pstack
	moveto
	180 suns_bearing 180 add distance_bearing2xy
	%(sunset_sunrise: x y \n) print_notice pstack
	lineto
	stroke
} def %sunset_greyline

%--------------------------------------
/calculate_HA0
%needs: globals lat_QTH, suns_DEC

%if this exists then we have sunrise/set at this location
%if not then we are in the land of eternal night/day (near the poles)

{
% find hour_angle
%
lat_QTH tan suns_DEC tan mul neg
% if the difference between lat_QTH and suns_DEC is > 90 deg
% then there is no sunrise or sunset (ie we're near the poles)
% If such a condition occurs then a number >1 or <-1 will
% be on the stack now.
dup abs 1.0 gt % is there a sunrise/set?
	{
	pop
	% if no sunrise/set at that date, then leave a flag by undef'ing HA0
	az_dict /HA0 known {az_dict /HA0 undef} if
	%(calculate_sunrise_sunset: no sunrise/set at this date/QTH. \n) print_notice lat_QTH suns_DEC pstack pop pop
	} % if no sunrise/set possible
	{
	% sunrise/set is possible
	arccos /HA0 exch def
	%(calculate_sunrise_sunset: HA0 \n) print_notice HA0 pstack pop
	}ifelse % HA0 exists

} def %calculate_HA0

%--------------------------------------
/calculate_sunrise_sunset

%Routine to plot sunrise and/or sunset lines at a particular location
%The routine doesn't explicitly know the times of these events.
%It only calculates where the sun would have to be, to be 90deg
%away from you in either direction, at that time of year.
% The routine needs the day of the year, but the time of day
% is ignored. Instead /UT is used for the time of day.

%The routine will be called with two arrays
%/greyline_months_plotted
%/greyline_days_plotted
%
%This routine is normally called in 2 ways
% 1) plot all sunrise and/or sunsets for 22nd of month from Jun-Dec.
% This covers the whole range of the sun's travel throughout the year
% and lets people get a reasonable idea of locations accessable by greyline.
% In this case the arrays will look like
% /greyline_months_plotted [ 6 7 8 9 10 11 12 ] def
% /greyline_days_plotted [ 22 ] def

%
%
% 2). plot sunrise and sunset on a particular day.
% This would be for a 160m contest or a DXpedition operating over a weekend.
% In this case the arrays will look like
% /greyline_months_plotted_array [ integer_month ] def
% /greyline_days_plotted_array [ integer_day ] def

%
% Presumably I don't need an array for greyline_days_plotted,
% but I'll put it in just incase.
%

%(calculate_sunrise_sunset: begin \n) print_notice pstack
12 /UT exch def
%12 /hour exch def	%needed for local sunrise/set
%hour /UT exch def
%2000 /year exch def	%your year, defined in az_ini.ps if not here
%
%These are now in az_ini.ps
%/greyline_months_plotted_array [ 6 7 8 9 10 11 12 ] def
%/greyline_days_plotted_array [ 22 ] def
{
	greyline_months_plotted_array
	{
		%pstack
		/month exch def
		%(calculate_sunrise_sunset: month \n) print_notice month pstack


		greyline_days_plotted_array
		{
			/day exch def
			%(calculate_sunrise_sunset: day month year \n) print_notice day month year pstack pop pop pop
			day_number
			day_number2az_alt
			calculate_HA0

			draw_sunrise_greylines
			az_dict /HA0 known and
			{
				sunrise_greyline
			} if %draw_sunrise_greylines

			draw_sunset_greylines
			az_dict /HA0 known and
			{
				sunset_greyline
			}if %draw_sunset_greylines
		}forall %greyline_days_plotted
	}forall % greyline_months_plotted
az_dict /hour_angle undef
az_dict /sun_h undef
az_dict /altitude undef
az_dict /HA0 undef
az_dict /sun_lon undef
az_dict /sun_lat undef
az_dict /suns_bearing undef
}def %calculate_sunrise_sunset

%--------------------------------------
% calculate sun_lat from day of year
% 88 days to 22 March
% sun_lat is 23.5 sin (((day_of_year -88)/365)x360)
%
% calculate sun_lon from UTC
% sun_lon is (0.5-(minutes_of_day/1440))x360
% sun_lon is (0.5-(hour of day /24))x360


% no leap years
/days_in_month  [0 31 28 31 30 31 30 31 31 30 31 30] def
/calculate_sun_position
{
az_dict /month known
az_dict /day   known and
az_dict /hour  known and
%az_dict /minute   known and
	{
		%(calculating sun position \n) print_notice
		0 1 month 1 sub
		{
			%array index is on stack
			days_in_month %array name
			exch	%get in right order to retrieve array element
			get
			%(days in month ) print_notice pstack
			day add /day exch def
		}for
		% day now contains day of year
		day
		%(day of year ) print_notice pstack
		88 sub
		365.25 div 360 mul
		sin
		23.5 mul
		/sun_lat exch def
		%sun_lat (calculat_sun_position: sun_lat ) print_notice pstack pop

		%hour 60 mul minute add 1440 div 0.5 sub neg 360 mul /sun_lon exch def
		UT 24 div 0.5 sub neg 360 mul /sun_lon exch def
		%sun_lon (calculat_sun_position: sun_lon ) print_notice pstack pop
	}	if
}def

%--------------------------------------
% Error function for greyline
% If this function is zero then the terminator lat (term_lat)
% and lon (term_lon) are correct.
% This is used in a Newton iteration to find term_lat, given term_lon
% formula supplied by Chris Cosgrove at Sydney Uni.

/terminator_error
{
	% term_lat on stack
	% term_lon global
	% sun_lat, sun_lon are globals
	% error is left on the stack on exit
	/term_lat exch def

	sun_lat cos term_lat cos mul
	sun_lon term_lon sub cos mul
	sun_lat sin term_lat sin mul
	add
	%(terminator_error: ) print_notice pstack
}def

%--------------------------------------
% draw sun symbol at sun_lat, sun_lon
/draw_sun_symbol
{
	/dot_radius	5 atom mul def
	/sun_radius	20 atom mul def
	/inner_end_of_ray 30 atom mul def
	/ray_length 10 atom mul def
	fine_gl_width master_line_width_factor mul setlinewidth
	sun_color setrgbcolor


	sun_lat sun_lon lat_lon2xy moveto
	newpath
	sun_lat sun_lon lat_lon2xy dot_radius 0 360 arc closepath fill
	newpath
	%sun_lat sun_lon lat_lon2xy moveto
	sun_lat sun_lon lat_lon2xy sun_radius 0 360 arc stroke

	%draw rays around sun
	7 /number_of_rays_around_sun exch def
	0 360 number_of_rays_around_sun div 360
	{
		newpath
		sun_lat sun_lon lat_lon2xy moveto
		dup rotate
		inner_end_of_ray 0 rmoveto
		ray_length 0 rlineto stroke
		neg rotate
	} for

az_dict /dot_radius undef
az_dict /sun_radius undef
az_dict /inner_end_of_ray undef
az_dict /ray_length undef
az_dict /number_of_rays_around_sun undef

}def


%--------------------------------------
% Calculate UT (decimal hours) from hour entered in 24 hr format in az_ini.ps or configxx.ps
% comments show results if hour == 1230

hour 100 div 		% stack is 12.30
hour 100 div truncate 	% stack is 12 12.30
%(calculate UT: \n) pstack pop
dup
3 1 roll 		% stack is 12 12.30 12
sub 			% stack is 0.30 12
100 mul 60 div		% stack is 0.50 12
add			% stack is 12.50
%pstack
/UT exch def

%--------------------------------------
% Greyline routine
% calculates position of greyline using the global values, sun_lat, sun_long
% being the point at which the sun is directly overhead.
% assumes a spherical earth.
%
%	sun_lat, sun_lon come from az_ini.ps
% or are calculated from  date/time in az_ini.ps
% or date/time from NMEA codes (whenever that gets put in)
%
% for sun overhead at sun_lat, sun_lon the equation of the terminator
% (term_lat, term_lon) is
% cos(sun_lat).cos(term_lat).cos(sun_lon - term_lon)
%                     + sin (sun_lat).sin(term_lat) = 0
% not easy to get the answer explicitely, (due to div by zero)
% so do it iteratively
%
% BUGS:
% This is a quick and dirty routine.
% 1. It has trouble with terminators going through the poles,
% eg at the equinoxes (will execute but produce garbage).
% i.e. when sun_lat=0.0
% this is trapped below
%
% 2. The terminator line is calculated at even intervals of term_lon rather
% than using the contour_draw algorythm (even intervals of plotting space).
% So lines of most interest to some, ie where the greyline goes through
% your QTH, will have jaggy lines around the antipodes,
% while the lines near the QTH will be drawn in unnecessary detail. Oh well.
%

/greyline
{
	mark
	(Drawing Greyline \r) print_notice
	%sun_lat (sun_lat ) print_notice pstack pop
	%sun_lon (sun_lon ) print_notice pstack pop


	%/Helvetica findfont bearing_fontsize scalefont setfont
	fine_gl_width master_line_width_factor mul setlinewidth
	greyline_color setrgbcolor
	0.01 /inc exch def % inc for newton iteration

	% where terminator crosses equator, ie where term_lat=0
	% (ie term_lat and term_lon are known - a good place to start calculating)
	%sun_lon = (sun_lon) print_notice
	sun_lon 90 sub /phase_of_node exch def
	% make sure starting point is -180<phase_of_node<180
	phase_of_node -180 lt {phase_of_node 180 add /phase_of_node exch def} if
	phase_of_node 180 gt {phase_of_node 180 sub /phase_of_node exch def} if
	%phase_of_node = (phase_of_node) print_notice
	% initialise lat_term, will get new value each iteration along terminator
	0.0 /term_lat exch def % = 0.0 for first iteration

	%trap sun_lat == 0.0
	0.0 sun_lat eq {0.5 /sun_lat exch def} if % much smaller and you get garbage

	newpath

	% go to node

	term_lat phase_of_node lat_lon2xy moveto

	%draw path of greyline
	%go 360 deg starting at equatorial crossing of terminator
	/phase_incr 2.0 def
	phase_of_node /term_lon exch def
	%(greyline: start loop \n) print_notice phase_of_node pstack pop


	{
		phase_of_node 360 add term_lon le {exit} if

		%(greyline: in loop \n) print_notice term_lon phase_incr pstack pop pop
		%(Greyline: ) print term_lat temp_string cvs print COMMA print term_lon temp_string cvs print CR print
		%/term_lon exch def

		{
			% find slope i.e. d(terminator_error)/d(term_lon)
			term_lat terminator_error dup /y1 exch def	%	y1
			term_lat inc add terminator_error						% y2
			sub			% y1 - y2
			inc div /error_slope exch def
			%(error_slope ) print_notice error_slope pstack pop
			error_slope dup mul 0.00000001 lt {exit} if % in case are at a stationary point
			y1 error_slope div /shift exch def	%calculate Newton Shift
			term_lat shift add /term_lat exch def		% calculate new term_lat
			shift 0.0001 lt {exit} if						% exit if done
			%term_lat (term_lat ) print_notice pstack pop
			%(going around again \n) print_notice
		} loop % till Newton has converged

		%term_lon mod_360 /term_lon exch def
		term_lon 360 gt %some of these numbers go very high, causing glitches in drawing
			{
			term_lon 360 sub /term_lon exch def
			phase_of_node 360 sub /phase_of_node exch def
			}if

		term_lat term_lon lat_lon2xy lineto
		% test if we're getting close to antipodes
		term_lat term_lon gc pop % pop bearing
		%distance on stack
		%(greyline: end loop - distance on stack \n) print_notice pstack
		dup 160 lt {2.0 /phase_incr exch def} if
		dup 170 lt {1.0 /phase_incr exch def} if
		dup 172 lt {0.2 /phase_incr exch def} if
		greyline_draft_mode not
			{
			dup 175 lt {0.025 /phase_incr exch def}{0.005 /phase_incr exch def} ifelse
			} if
		pop
		term_lon phase_incr add /term_lon exch def


		%term_lat term_lon pstack pop pop
	} loop % for
	closepath

	%If greyline is called by draw_sunset_greylines etc,
	% then need to be able to turn this off with draw_greyline_by_timedate
	shade_night_time draw_greyline_by_timedate and
	{
		%have greyline path, save it
		gsave
		night_color setrgbcolor

		%see if sun is inside greyline path
		sun_lat sun_lon lat_lon2xy infill
			{
			%sun is in center portion of map inside the greyline line
			%fill the annulus between greyline and outer_border
			%have greyline path as current path
			%add path of outer border
			0 0 180 0 360 arc closepath
			eofill
			}
			{
			%sun is in annulus between greyline and outer_border
			%fill area bound by greyline with night_color
			fill
			}ifelse
		grestore
	}if %shade_night_time

	% greyline
	fine_gl_width master_line_width_factor mul setlinewidth
	%newpath
	greyline_color setrgbcolor
	stroke
	cleartomark %as I said, just in case
	(\n) print_notice

az_dict /inc undef
az_dict /term_lat undef
az_dict /term_lon undef
az_dict /shift undef
az_dict /error_slope undef

}def

%--------------------------------------
%Instruction to execute to display a "special" dxcc country
% ie one marked with a D: in dxcc.dat
/dxcc_special_country_2
	{
	/outlineshow {true charpath stroke} def
	atom 10 div setlinewidth
	/Helvetica-BoldOblique findfont
	/dxcc_font_size { atom 30 mul} def	% as a fraction of screen width
	dxcc_font_size scalefont setfont
	dxcc_special_color_2 setrgbcolor
	} def

%Instruction to execute to display a dxcc country in that you've worked
/dxcc_special_country
	{
	/outlineshow {true charpath stroke} def
	atom 10 div setlinewidth
	/Helvetica-BoldOblique findfont
	/dxcc_font_size { atom 25 mul} def	% as a fraction of screen width
	dxcc_font_size scalefont setfont
	dxcc_special_color setrgbcolor
	} def


%Instruction to execute to display a dxcc country in default mode
% eg for a country that you haven't worked

/dxcc_country
	{
	/outlineshow {show} def
	/Helvetica findfont
	/dxcc_font_size	{ atom 25 mul } def	% as a fraction of screen width
	dxcc_font_size scalefont setfont
	dxcc_color setrgbcolor
	} def

%--------------------------------------
% special cases

/island_in_lake
% these islands are in a lake.
% they have to be drawn after the lake and filled with white
% otherwise they will be blue (or whatever color your lake is)
[
5173
5174
5175
5200
]def

/big_lakes	% big enough to have borders in black
		% I've somewhat arbitrarily decided which lakes are in this list
		% you can put them all in if you like.
		% it's an ad hoc solution otherwise small lakes become all edge
		% entries one per line, you can take a lake out of this list,
		% by putting a comment (%) symbol at the start of the line
[
6001	% Aral Sea
6002	% L. Balkash Kazakstan
6005	% L. Onega
6007	% L. Ladoga
6012	% L. Baikal, USSR
6018	% Rybinsk Resevoir, USSR
%6023	% also part of Rybinsk Res.
%6022	%
6032	% L. Tana, Ethiopia
6033	% L. Victoria, Kenya, Tanzania, Uganda, Rwanda
6034	% L. Turkana (L. Rudolf), Kenya, Ethiopia
6035	% L. Edward, Uganda, Zaire
6037	% L. Kiva, Rwanda, Zaire
6043	% L. Tanganika, Tanzania, Zaire, Zambia
6044	% L. Mweru, Zambia, Zaire
6051	% L. Malawi, Mozambique, Malawi, Tanzania
6058	% L. Winnipeg
6059	% Great Slave Lake
6060	% L. Athabasca
6061	% L. Ontario
6062	% L. Erie
6063	% Thunder Bay
6069	% Great Bear Lake
%6070	% Teslin Lake (border BC and Yukon)
%6071	% Lake in BC
6072	% part of L. Winnipeg
6073	% Caspian Sea
6074	% L. Ontario
6086	% Great Salt Lake, Utah, USA
6087	% L. Okeechobee
6096	% L. Nicaragua
6100	% L. Titicaca
6501	% L. Nettilling (in Baffin Is.)
]def


%--------------------------------------
%Things to do:
%Cities
% It would be nice to be able to display cities, in a way that only
% important (whatever that means) towns are displayed on large scale
% maps while on small scale maps, less important towns are brought in.
% In the hopes of using populations as a measure of importance, I
% unsuccessfully scoured the universe for computer readable files of
% town names, lat/lon and populations. They weren't available, despite
% all the population planning that is done by organisations like the UN.
% Presumably planning is still done with pencils and erasers. The
% hardcopy available (several hundred pages), which indeed does have
% all the info needed, was dual language Fr/Eng and in a format and
% range of fonts designed to outwit any scanning hardware/software
% combination known to man. Apparently this hardcopy was produced without
% any computer intervention as there is no trace of the original data.
%
% The author of Traksat, Paul Traufler kindly offered his traksat.cty
% file for non-commercial use, but this list does not have a method
% for ranking the cities. We've put the problem off till a later
% version of the program. If anyone would like to go through
% Paul's file of 1690 cites and rank them in importance from
% say 1..5 in a way that's compatible with Paul's planned future
% use of the file, and send it to us, we would be very happy indeed.

%--------------------------------------
%Start of routines
%--------------------------------------

/process_options_manual
{
	az_dict /scale_type known
	{
		scale_type
		{
		/kms_per_cm map_scale_deg def
		} if
	} if
}def


%--------------------------------------
% Printer problems - weird and otherwise
/setup_specific
{

% The ghostscript3.2.8 printer driver for the Color HP DJ550c gives the wrong
% clippath for the printable region. The driver for this printer ignores
% the 1/4" or so of paper at the end of the page that the rollers need
% to hold the paper. The clippath is used to locate labels currently
% at the bottom left of the page and the Title. It is also used to determine
% font size.

% If your printer has similar problems, modify this routine for your
% printer and send it to us (address above)

	/printer_fiddle {} def % your routine
	% Default routine to modify the the values of LLx LLy URx URy
	% returned from the bounding box of clippath. Several Ghostscript
	% printer drivers (cdj500 and Epson) are known to give erronious
	% values.
	% It is executed in "setup_dimensions"

statusdict /product get (Ghostscript) search	% are we running Ghostscript?
	{
		% code contains Ghostscript specific instructions
		pop pop pop
		%the devicename call changed at gs3xx (was devicename, now is .devicename)
		currentdevice revision 300 lt	{devicename}{.devicename} ifelse
		{
	 		dup (cdj550) eq	% are we outputting for a cdj550c ?
			{
				% routine def's /printer_fiddle as one of two values depending on orientation
				/printer_fiddle
				orientation dup (landscape) eq exch (orthographic-landscape) eq or
				%landscape
				{
					% fix clippath for landscape mode
					(landscape clippath fix for HP deskJet 550 \n) print_notice
					{ 4 -1 roll 0.28 cm add 4 1 roll }
				} if
				orientation dup (portrait) eq exch (orthographic-portrait) eq or
				{
					% fix clippath for portrait mode
					(portrait clippath fix for HP DeskJet 550 \n) print_notice
					{ 3 -1 roll 0.28 cm add 3 1 roll }
				} if
				def

				% also do gamma correction
				(gamma correction for HP DeskJet 550 \n) print_notice
				{ 0.33 exp } dup dup
				currenttransfer
				setcolortransfer
				exit
			} if % cdj550

			dup (djet500) eq	% outputting to a HP Deskjet 500 ?
			{
				% this gives a better grey scale than the default screen I think
				60.0 45.0
				{
					abs exch abs 2 copy add 1 gt
					{ 1 sub dup mul exch 1 sub dup mul add 1 sub }
					{ dup mul exch dup mul add 1 exch sub } ifelse
				} setscreen
				(grey scale correction for HP DeskJet 500 \n) print_notice
				%pstack
				{ 2 exp } settransfer
				%pstack
				pop exit
			} if %djet500


			% The epson driver gives wrong values for the clippath, so a
			% a similar 'printer fiddle' as the cdj550 is needed here.
			% We've found no problems with the (limited number of)
			% other drivers we've tried (add them here and send them to us).

			pop exit
		} loop	% all printers
	} %if Ghostscript
	{
		pop
	} ifelse % not Ghostscript



%Do gamma correction for color PostScript printers

%A word or two about gamma correction
%(only for those outputing to color printers).

%	A printer gives a brightness that is linearly dependant on input
%(much as you would expect), i.e if you send {1,0,0} setrgbcolor
%to the printer, it will produce a red that is twice as bright
%(measured presumably in electric field) as will sending
%{0.5,0,0} setrgbcolor. A screen however, due to the physics
%of phosphors, will give output proportional to input^^gamma,
%where 2.2<gamma<2.5, i.e. the output increases faster than
%linearity. Since the brightness at red =0 and red =1 are
%normalised for both printer and screen, the difference in
%output on the two devices will be noticed at mid-intensity
%output. The printer output will be darker than the screen.
%Thus the color lightblue as used here ({0.33,0.33,1} setrgbcolor),
%which is the default lake color, looks skyblue on a screen,
%but dark blue on a printer.
%
%	So there's a printer convention and a screen convention.
%No attempt has been made to make the output colors device
%independant. You send your output device the instructions
%and take what you get. If you want the color on the printer
%to look the same as the color on the screen preview you
%can do a gamma correction. The problem is to detect whether
%you need to correct or not. There isn't any way (that we know
%of) for the code to know whether it's running on a color
%printer or a screen, or whether a color printer has the
%color or the B&W cartridge installed.
%
%	The way we've chosen to handle this is to ask the name
%of the output device ("/product"). If it's a non Postscript
%printer and you are using Ghostscript then you look up the
%Ghostscript manual to find that the HP DeskJet 550C is called
%a cdj550. If it's a real Postscript printer (e.g. HP DeskJet
%1200C or Tektronics Phaser IISDX) then you look up the printer
%manual to see what string will be returned when you ask for
%the "/product" string. Once you've found this, duplicate,
%for your printer, an appropriate piece of code found below
%(and send it to us so we can put it in the our code for future
%releases). You have to chose a value for inverse gamma
%(suggest 0.3-0.4) that gives the same color on the printer
%as you see on your screen. A test would be the light blue
%used to fill lakes. To make the printer output a lighter
%color, chose a smaller number for inverse gamma.
%
%Note gs2.61 cannot handle the gamma correction routine below.
%gs3.33 can.
%I don't know if it's a bug in the code or just that gs2.61
%can't do it. So you can draw color maps on a screen with
%gs2.61, but you cannot gamma correct the color for printing.
% JM Aug 96


	statusdict /product get (DeskJet 1200C) eq
	{
		% Gamma correction for DeskJet 1200C
		(gamma correction for DeskJet 1200C \n) print_notice
		{ 0.333 exp } dup dup currenttransfer setcolortransfer
	} if

	statusdict /product get (Phaser IISDX) eq
	{
		% Gamma correction for color printers
		(gamma correction for Phaser IISDX \n) print_notice
		{ 0.333 exp } dup dup currenttransfer setcolortransfer
	} if

} def

%--------------------------------------

% Print the Amateur Call (or any other field in dxcc_info).
% To change the output (eg if you want time zones instead of Amateur Prefix),
% change the field in dxcc_info
% syntax --	DXCC_ARRAY Print_Call -
/Print_Call
{
	%(Print_call: start \n) print_notice pstack

	/Dxcc_array exch def
	Dxcc_array LAT get dup
	Dxcc_array LON get dup

	% don't print calls with invalid lat/lon
	NO_LATLON eq 3 -1 roll NO_LATLON eq or not
	{
		%(Print_call: valid lat/lon \n) print_notice pstack

		gc
		/bearing exch def
		/distance exch def

		% flush stuff off stack
		%exch pop
		%exch pop

		%suggested by Igor UA9CDC/N3TOD
		%(Print_call \n) print_notice bearing pstack pop
		dxcc_labels_around_border
		{
			gsave
	     		%(Print_call: 2 \n) print_notice bearing pstack pop
			% we'll use the bearing from gc,
			% but we'll use a number just outside the outer_border (=180) for distance
			195 /distance exch def

			bearing rotate
			distance 0 distance_bearing2xy moveto
			90 rotate
    			Dxcc_array dxcc_info get
			%dup stringwidth pop 2 div neg
    			%dxcc_font_size neg rmoveto
    			outlineshow
			-90 rotate
			bearing neg rotate
			grestore

			%pop pop

		} %dxcc country names drawn around border of map
		{
      	    		circle_dxcc
      	    		{	% required to print in circular text
      	    			/bearing
      	    			bearing 450.0 exch sub dup 360.0 ge {360.0 sub} if
      	    			def


      	    			0 0 moveto
      	    			% call outside printing for lower hemisphere
      	    			% & inside printing for upper hemisphere
      	    			Dxcc_array dxcc_info get dxcc_font_size bearing distance
      	    			bearing 0.0 gt bearing 180.0 lt and
      	    			{
      	    				% tweek distance so that label is in middle
      	    				dxcc_font_size 2 div sub
      	    				outsidecircletext
      	    			}{
      	    				% tweek distance so that label is in middle
      	    				dxcc_font_size 2 div add
      	    				insidecircletext
      	    			} ifelse
      	    		} % dxcc country names drawn in curves
      	    		{
      	    			distance bearing distance_bearing2xy moveto
      	    			Dxcc_array dxcc_info get dup stringwidth pop 2 div neg
      	    			dxcc_font_size neg rmoveto
      	    			%dxcc_color setrgbcolor
      	    			outlineshow
      	    		} ifelse % dxcc country names drawn horizontally
		}ifelse % dxcc country names drawn inside map on top of country Capitol
	}{
		pop pop
	} ifelse
%(Print_call: end \n) print_notice pstack
}def


%--------------------------------------
/plot_waypoint
{

	rover_font findfont rover_font_size scalefont setfont

	%draw line
	newpath
	black setrgbcolor
	2.5 atom mul setlinewidth
	0 0 moveto
	waypoint_distance waypoint_bearing distance_bearing2xy lineto % waypoint location
	stroke

	%draw circle at waypoint
	newpath
	waypoint_distance waypoint_bearing distance_bearing2xy % waypoint x,y
	10 atom mul %radius of circle
	0 360 arc
	closepath
	stroke

	%show_bearing

	%go to half way out
	%divide distance by half, and keep copy of dist
	waypoint_distance 2 div waypoint_bearing
	distance_bearing2xy moveto	%go there
	%convert compass origin and direction of rotation to cartesian system
	waypoint_bearing neg 90 add rotate
	0 10 atom mul rmoveto
	waypoint_bearing cvi temp_string cvs dup stringwidth pop 2 div neg 0 rmoveto show
	0 10 atom mul neg rmoveto
	waypoint_bearing 90 sub rotate

	%show_distance

	waypoint_distance 2 div bearing distance_bearing2xy moveto	%go there
	waypoint_bearing neg 90 add rotate
	0 30 atom mul neg rmoveto
	%convert deg to km, find string width, offset, show
	waypoint_distance deg2km cvi temp_string cvs dup stringwidth pop 2 div neg 0 rmoveto show
	( km) show
	0 30 atom mul rmoveto
	waypoint_bearing 90 sub rotate

}def % plot_waypoint
%--------------------------------------
/extract_GLL
{
%GLL=Geographic Lat Lon
%on stack - a string like (4130.34,N,7135.42,W)
% pop % one line dummy routine to pop string off stack - for testing
%pstack (extract_GLL \n) print_notice
/error 0 def

(,) search
	{
		%pstack (extract_GLL \n) print_notice
		%on stack (4130.34), then (,) then (N,7135.42,W)
		exch pop % get rid of (,)
		cvr dup	cvi 100 idiv %41
		/lat_GLL exch def
		100 div lat_GLL sub %0.3034
		10 mul 6 div lat_GLL add /lat_GLL exch def
		%pop

		%N or S?
		(,) search
		{
			%on stack: (N) or (S), then (,) then (7135.42,W)
			exch pop % pop (,)
			{

			dup	(N) eq
				{
					pop % (N)
					%lat_GLL = (lat_GLL is N \n) print_notice
					exit
				} if % N do nothing

			dup (S) eq
				{
					pop % (S)
					% make -ve for southern hemisphere
					lat_GLL neg /lat_GLL exch def
					%lat_GLL = (lat_GLL is S \n) print_notice
					exit
				} if % S invert sign

			/error -1 def
			/bad_string exch def
			(bad GLL lat string: ) print bad_string print  ( - expect N or S \n) print
			exit
			}loop % N,S, or ?
		} % if of ifelse, (,) found
		{
		/error -1 def
		%pstack (bad GLL lat string, expect `,' before N or S \n) print
		pop
		} ifelse %(,) not found ,
	}% if of ifelse
	{
		/error -1 def
		%pstack (bad GLL lat string, expect `,' somewhere \n) print
		pop
	} ifelse %(,) not found in string


(,) search
	{
		%on stack (7135.42) (,) (W)
		exch pop % get rid of (,)
		%pstack (lon_GLL \n) print_notice
		cvr dup	cvi 100 idiv %71
		/lon_GLL exch def
		100 div lon_GLL sub %0.3542
		10 mul 6 div lon_GLL add /lon_GLL exch def

		%E or W?
		%on stack: (E) or (W)
		%(GLL: E or W? \n) print_notice
		% or if passing stuff from BWC then the string will be
		% (W,175,T,185,M,252.5,N,####)

 		{ % loop

		(,) search
		{
			% pstack (found BWC type string in GLL \n) print_notice
			% we've found a longer string presumably from BWC
			% find the (E) or (W) and leave the rest on the stack
			% on stack (W) (,) (175,T,185,M,252.5,N,####)
			exch pop % pop (,)
		} if

		dup	(E) eq
			{
				pop % (E)
				%lon_GLL = (lon_GLL is E \n) print_notice
				exit
			} if % (E) do nothing

		dup	(W) eq
			{
				pop % (W)
				% make -ve for western hemisphere
				lon_GLL neg /lon_GLL exch def
				%lon_GLL = (lon_GLL is W \n) print_notice
				exit
			} if % (W) invert sign of lon

			/error -1 def
			/bad_string exch def
			(bad GLL lon string: ) print bad_string print  ( - expect E or W \n) print
			exit
		} loop % through E,W or error string
	}% if of ifelse (,) found
	{
		/error -1 def
		/bad_string exch def
		%pstack (bad GLL lon string: ) print bad_string print ( - expect `,' \n) print
		pop
	} ifelse %(,) not found in string


	error 0 eq
	{
	lat_GLL /lat_QTH exch def
	lon_GLL /lon_QTH exch def
	%lat_QTH = (lat_QTH \n) print_notice
	%lon_QTH = (lon_QTH \n) print_notice
	%pstack (heads up: \n) print_notice %check stack, should be empty

	%Have to get lat_QTH, lon_QTH to the outside world
	%We're currently down inside a save/restore
	%See the write up near the string "Bigbang restore"

	} %if of ifelse - if we have a new QTH
	{
		(Error in nmea GLL statement, lat/lon not recovered \n) print_notice
	}ifelse

az_dict /bad_string undef
az_dict /lon_GLL undef
az_dict /lat_GLL undef
} def


%--------------------------------------
/extract_BOD
{
% Bearing Origin to Dest
%pstack
%(extract_BOD - not implemented \n) print_notice
($GP data type BOD - not implemented \n) print_notice
pop
} def

%--------------------------------------
/extract_BWC
{
%	Bearing to waypoint along great circle
%pstack
%(extract_BWC \n) print_notice
%pop % dummy routine for testing call.

/error 0 def
/BWC_distance -1 def

% on stack string like (235959,4359.00,N,7459.00,W,175,T,185,M,252.5,N,####)

(,) search
	{
		% on stack (235959) (,) (4359.00,N,7459.00,W,175,T,185,M,252.5,N,####)
		exch pop % (,)
		%time info is used in greyline routines
		cvr 10000 div
		dup cvi /hour exch def
		%hour = (BWC_hour \n) print_notice
		hour sub 100 mul cvi /minute exch def
		%min = (BWC_min \n) print_notice
		minute 60 div hour add /UT exch def
		% on stack (4359.00,N,7459.00,W,175,T,185,M,252.5,N,####)
		extract_GLL

		% on stack string like (175,T,185,M,252.5,N,####)

		%pstack (BWC string 2\n) print_notice

		(,) search
		{
			% on stack string like (175) (,) (T,185,M,252.5,N,####)
			exch pop % pop (,)
			cvr /BWC_bearing exch def
			%BWC_bearing = (BWC_bearing \n) print_notice

			(T,) search
			{
				% on stack string like () (T,) (185,M,252.5,N,####)
				pop % pop ()
				pop % pop (T,)
				%(BWC_bearing is True \n) print_notice

				(M,) search
				{
					% on stack string like (185,) (M,) (252.5,N,####)
					% the first two represent the magnetic bearing which we aren't interested in
					pop pop
					(,) search
					{
						% on stack string like (252.5) (,) (N,####)
						exch pop % pop (,)
						cvr /BWC_distance exch def
						%BWC_distance = (BWC_distance \n) print_notice

						(,) search
						{
							% on stack string like (N) (,) (####)
							exch pop % pop (,)
							exch pop % (####)

							{ % loop
								dup (N) eq
								{
									% Nautical miles
									%(BWC distance is in nautical miles \n) print_notice
									% turn into degrees
									BWC_distance NM2deg /BWC_distance exch def
									pop % (N)
									exit
								} if

								dup (M) eq
								{
									% Statute miles
									%(BWC distance is in Statute miles \n) print_notice
									% turn into degrees
									BWC_distance M2deg /BWC_distance exch def
									pop % (M)
									exit
								} if

								/error -1 def
								/bad_string exch def
								(bad BWC distance units string: ) print bad_string print  ( - expect N or M \n) print
								pop
								exit
							} loop

						} % if of ifelse
						{
							/error -1 def
							/bad_string exch def
							%pstack (bad BWC string: ) print bad_string print ( - expect `,' after N/M \n) print
						} ifelse
					}
					{
						/error -1 def
						/bad_string exch def
						%pstack (bad BWC string: ) print bad_string print ( - expect `M,' \n) print
					} ifelse
 				}
				{
					/error -1 def
					/bad_string exch def
					%pstack (bad BWC string: ) print bad_string print ( - expect `M,' \n) print
				} ifelse
 			}
			{
				/error -1 def
				/bad_string exch def
				%pstack (bad BWC string: ) print bad_string print ( - expect `T,' \n) print
			} ifelse
 		}% if of ifelse (,) found
		{
			/error -1 def
			/bad_string exch def
			%pstack (bad BWC string: ) print bad_string print ( - expect `,' \n) print
		}ifelse % (,) not found
 	}	% if of ifelse, (,) found
	{
		/error -1 def
		/bad_string exch def
		%pstack (bad BWC string: ) print bad_string print ( - expect `,' \n) print
	}ifelse % (,) not found

	error 0 eq BWC_distance -1 eq not and
	{
	BWC_bearing /waypoint_bearing exch def
	BWC_distance /waypoint_distance exch def
	%waypoint_bearing = (waypoint_bearing \n) print_notice
	%waypoint_distance = (waypoint_distance \n) print_notice
	%pstack (heads up \n) print_notice %check stack, should be empty

	plot_waypoint

	%Have to get to the outside world
	%We're currently down inside a save/restore
	%See the write up near the string "Bigbang restore"

	} %if of ifelse - if we have a valid Bearing/Dist
	{
		(Error in nmea BWC statement, bearing/dist not recovered \n) print_notice
	}ifelse

az_dict /bad_string undef
az_dict /BWC_distance undef
az_dict /BWC_bearing undef
} def

%--------------------------------------
/annotation_fields
[
	() 0.0 0.0
] def

/extract_annotation_old
% Parse the line of input that we suspect to be an annotation
{
	{	% look for annotation string
		(:) search
		{
			annotation_fields 0 3 -1 roll put pop
		}{
			pop exit	% bad line
		} ifelse

		% Latitude. Convert N to positive real and S to negative real
		(:) search
		{
			(N) search
			{
				token
				{
					dup type dup /integertype eq exch /realtype eq or
					{
						cvr annotation_fields 1 3 -1 roll
						dup 90.0 le	% check for legal value
						{
							put
						}
						{
							pop NO_LATLON put
						} ifelse
						pop pop pop pop
					}
					{
						pop pop pop pop pop exit % bad LAT
					} ifelse
				}
				{
					pop pop pop exit
				} ifelse
			}
			{
				(S) search
				{
					token
					{
						dup type dup /integertype eq exch /realtype eq or
						{
							cvr annotation_fields 1 3 -1 roll neg
							dup -90.0 ge	% check for legal value
							{
								put
							}
							{
								pop NO_LATLON put
							} ifelse
							pop pop pop pop
						}
						{
							pop pop pop pop pop exit	% bad LAT
						} ifelse
					}
					{
						pop pop pop exit
					} ifelse
				}
				{
					annotation_fields 1 NO_LATLON put pop
				} ifelse
			} ifelse
		}
		{
			pop exit
		} ifelse

		% Longitude. Convert E to positive real and W to negative real

		(E) search
		{
			token
			{
				dup type dup /integertype eq exch /realtype eq or
				{
					cvr annotation_fields 2 3 -1 roll
					dup 180.0 le	% check for legal value
					{
						put
					}
					{
						pop NO_LATLON put
					} ifelse
					pop pop pop
				}
				{
					pop pop pop pop exit	% bad LON
				} ifelse
			}
			{
				pop pop exit
			} ifelse
		}
		{
			(W) search
			{
				token
				{
					dup type dup /integertype eq exch /realtype eq or
					{
						cvr annotation_fields 2 3 -1 roll neg
						dup -180.0 ge	% check for legal value
						{
							put
						}
						{
							pop NO_LATLON put
						} ifelse
					pop pop pop
					}
					{
						pop pop pop pop exit	% bad LON
					} ifelse
				}
				{
					pop pop exit
				} ifelse
			}
			{
				annotation_fields 2 NO_LATLON put pop
			} ifelse
		} ifelse
		% Uncomment to print each array as it is parsed (We only get here on good lines)
		% annotation_fields { = } forall
		annotation_fields Print_annotation
		exit
	} loop
} def	%extract_annotation

%--------------------------------------
/extract_annotation_new
% Parse the line of input that we suspect to be an annotation
{
%reset each time to flush data from last annotation line 
%(incase you have an empty annotation string in the line about to be analysed)
/annotation_fields
[
	() 0.0 0.0
] def

	%(extract_annotation: start \n) print_notice pstack
	{	% look for annotation string
		(:) search
		{
			annotation_fields 0 3 -1 roll put pop
		}{
			pop exit	% bad line
		} ifelse
		
		%(extract_annotation: annotation string \n) print_notice pstack
		%annotation_fields { = } forall
		
		(:) search
		{
			exch pop % the (:)
			%(extract_annotation: extract location \n) print_notice pstack
			location_to_lat_lon
			lat cvr annotation_fields 1 3 -1 roll 
			put 
			%(extract_annotation: extracted lat \n) print_notice pstack
			%pop   

			%(extract_annotation: extracting lon \n) print_notice pstack
			lon cvr annotation_fields 2 3 -1 roll 
			put 
			%(extract_annotation: extracted lon \n) print_notice pstack
		} if
			
		% Uncomment to print each array as it is parsed (We only get here on good lines)
		%annotation_fields { = } forall
		annotation_fields Print_annotation
		exit
	} loop
	%comment is on top of stack
	pop
	%(extract_annotation: exiting \n) print_notice pstack
} def	%extract_annotation

%--------------------------------------
/extract_annotation {extract_annotation_new} def
%--------------------------------------
/Print_annotation
{
  %(Print_annotation: start \n) print_notice pstack
  {} forall

  dup 1 index

  % don't print calls with invalid lat/lon
  NO_LATLON eq exch NO_LATLON eq or not
  {
    gsave
      2 copy 5 2 roll

      % write label
      lat_lon2xy moveto
      annot_font findfont annot_font_size 2 mul scalefont setfont
      dup stringwidth pop 2 div neg
      atom 8 mul
      rmoveto

	% This erases the screen around the annotation (creates a white
	% background), so that the string is readable
	% We write the character outlines with a very thick white pen first.

      currentpoint 1.0 setgray  25 atom mul setlinewidth
      2 index true charpath stroke moveto

      annot_color setrgbcolor show

      % draw a blob here
      newpath lat_lon2xy atom 6 mul 0 360 arc fill

    grestore
  }{
    pop pop pop
  } ifelse
  %(Print_annotation: end \n) print_notice pstack
} def

%--------------------------------------
% Parse the line of input that we suspect to be a dxcc entry

/Dxcc_fields % This is the form of the 'DXCC' array
[
	() () 0 () () 0 0.0 0.0 () ()
] def

% These are the fields within the array
/Am_Call	0 def
/Cntry		1 def
/Cont		2 def
/ITUzns		3 def
/CQzns		4 def
/Time		5 def
/LAT		6 def
/LON		7 def
/ITUcall	8 def
/Am_more	9 def

/dxcc_info Am_Call def	% this is the default field printed from DXCC entry
			% all of the above fields are strings,
			% (except LAT, LON). Any of the string fields can be
			% substituted for Am_Call for output.

/big_D false def	%needs to be defined before first entry into extract_dxcc

%error flags
/NULL_FIELD	-1 def
/NO_TIME	-100 def
/NO_LATLON	-200.0 def


/extract_dxcc
{
	%(extract_dxcc: begin \n) print_notice pstack
	{ %loop
		big_D	% if symbol is DXCC and not dxcc
		{
			%(big D \n) print
			%(special country 2 \n)print
			dxcc_special_country_2
		} if

	% look for primary amateur call sign
	(:) search
		{
		(*) search
			{
				pop pop pop pop pop
				%(deleted call) print
				exit	% deleted call
			} if % *
		Dxcc_fields Am_Call 3 -1 roll put pop
		}
		{
			pop
			%(bad line \n) print
			exit	% bad line
		} ifelse

	% look for country name
	(:) search
		{
			%(country name \n) print pstack
			Dxcc_fields Cntry 3 -1 roll put pop
		}
		{
			pop
			%(bad line 2) print
			exit % bad line
		} ifelse

	% look for continent and choose one of 7
	(:) search
		{
		dup length 2 ge { 0 2 getinterval } if (EuAfAsOcAnNASA) exch search
			{
			length 2 idiv
			exch length 0 eq
				{
				pop -1 % null continent
				%(bad line 3\n) print pstack
				} if
			%(found continent \n) print
			Dxcc_fields Cont 3 -1 roll put pop pop
			}
			{
			pop pop pop exit
			} ifelse
		} % ifelse (:) found
		{
		pop
		%(bad line 4) print
		exit		% bad line
		} ifelse % (:) not found

	% ITU zone. This can be numbers in the form "21-24",
	% so we keep it as a string, rather than numbers
	% so we can further break it down if necessary
	(:) search
		{
			Dxcc_fields ITUzns 3 -1 roll put pop
		}{
			pop
			%(bad line 5) print
			exit % bad line
		} ifelse

	% CQ zones. This can be numbers in the form "21-24",
	% so we keep it as a string.
	% We can further break it down if necessary
	(:) search
		{
			Dxcc_fields CQzns 3 -1 roll put pop
		}{
			pop
			%(bad line 6) print
			exit		% bad line
		} ifelse


	% Time (from UTC). Convert to a real
	(:) search
		{
		Dxcc_fields Time 3 -1 roll token
			{
			exch pop
			dup type dup /integertype eq exch /realtype eq or
			% should be an int or a real
				{
				cvr put pop
				}{
				pop pop pop pop
				%(bad line 7) print
				exit		% bad zone, drop entry
				} ifelse
			}{
			NO_TIME put pop	% no zone supplied
			} ifelse
		}
		{
		pop exit
		} ifelse

	% Latitude. Convert N to positive real and S to negative real
	(:) search
		{
		(N) search
			{
			token
				{
				dup type dup /integertype eq exch /realtype eq or
					{
					cvr	Dxcc_fields LAT 3 -1 roll
					dup 90.0 le		% check for legal value
						{
						put
						}
						{
						pop NO_LATLON put
						} ifelse
					pop pop pop pop
					}
					{
					pop pop pop pop pop exit	% bad LAT
					} ifelse
				}
				{
				pop pop pop exit
				} ifelse
			}
			{
			(S) search
				{
				token
					{
					dup type dup /integertype eq exch /realtype eq or
						{
						cvr	Dxcc_fields LAT 3 -1 roll neg
						dup -90.0 ge	% check for legal value
							{
							put
							}
							{
							pop NO_LATLON put
							} ifelse
						pop pop pop pop
						}
						{
						pop pop pop pop pop exit	% bad LAT
						} ifelse
					}
					{
					pop pop pop exit
					} ifelse
				}
				{
				Dxcc_fields LAT NO_LATLON put pop
				} ifelse
			} ifelse
		}
		{
		pop exit
		} ifelse

	% Longitude. Convert E to positive real and W to negative real
	(:) search
		{
		(E) search
			{
			token
				{
				dup type dup /integertype eq exch /realtype eq or
					{
					cvr	Dxcc_fields LON 3 -1 roll
					dup 180.0 le	% check for legal value
						{
						put
						}
						{
						pop NO_LATLON put
						} ifelse
					pop pop pop pop
					}
					{
					pop pop pop pop pop exit	% bad LON
					} ifelse
				}
				{
				pop pop pop exit
				} ifelse
			}
			{
			(W) search
				{
				token
					{
					dup type dup /integertype eq exch /realtype eq or
						{
						cvr	Dxcc_fields LON 3 -1 roll neg
						dup -180.0 ge	% check for legal value
							{
							put
							}
							{
							pop NO_LATLON put
							} ifelse
						pop pop pop pop
						}
						{
						pop pop pop pop pop exit	% bad LON
						} ifelse
					}
					{
					pop pop pop exit
					} ifelse
				}
				{
				Dxcc_fields LON NO_LATLON put pop pop
				} ifelse
			} ifelse
		}
		{
		pop exit
		} ifelse

	% ITU Call assignment
	(:) search
		{
		Dxcc_fields ITUcall 3 -1 roll put pop
		}
		{
		%(bad line ITU call \n) print pstack
		pop exit		% bad line
		} ifelse

	% Final field is the additional amateur calls
	Dxcc_fields Am_more 3 -1 roll put

	% We only get here on good lines. Uncomment next line
	% to print each array as it is parsed
	%	Dxcc_fields { = } forall

	%(extract_dxcc: end \n) print_notice pstack
	Dxcc_fields
	%(extract_dxcc: call Print_call \n) print_notice pstack
	Print_Call
	exit
	} loop
} def	%extract_dxcc

%--------------------------------------

/extract_band_mode
{
% a string will be on top of the stack.
% if band mode info is present - eg "20 CW" the line will be like
%
% 20 CW:1S:Spratly Is:As:50:26:+7:9N:112E:1S~:9M0
%
% otherwise the string on the stack will be like
%
% 1S:Spratly Is:As:50:26:+7:9N:112E:1S~:9M0
%
% get string in front of ":" and look for blank
%(extract_band_mode: entry string \n)print_notice pstack
dxcc_line
%pstack
(:) search
	{
	%(extract_band_mode: begin \n) print_notice pstack
	%have either country code or band/mode info
	%(looking for blank\n) print
	( ) search % look for blank
		{	%band/mode info found
		%(found band_mode \n) print
		%pstack
		/band_worked false def	%initialise
		% should be a number then blank then mode eg "20 CW"
		% extract the number
		cvi % convert string representing freq into integer
		/dxcc_band_entry_found exch def	% variable for entry found in DXCC line
		%pstack
		%dxcc_bands_plotted	%array of bands to be plotted, from az_ini.ps
		bands_plotted	%array of bands to be plotted, from az_ini.ps
			{
			dup dxcc_band_entry_found eq exch (*) eq or	%check the entry found
				{
				/band_worked true def	%if found set flag
				%(band entry found\n) print
				} if
			}forall % dxcc_bands

		%parse mode
		/mode_worked false def	% initialise
		%(mode \n) print
		pop % remove blank
		%pstack
		/dxcc_mode_entry_found exch def %the mode in the input line
		dxcc_modes_plotted	%the ones requested to plot in az_ini.ps
			{
			dxcc_mode_entry_found eq	% the ones in the dxcc.dat file
				{
				/mode_worked true def	% did we get a hit?
				%(mode is to be plotted\n) print
				} if
			}forall %dxcc_modes_plotted

		mode_worked band_worked and
			{
			% both band and mode are OK, so mark it in special mode
			dxcc_special_country
			}
			{
			% not a dxcc country to be specially marked
			dxcc_country
			} ifelse
		pop %remove colon
		%(going to extract_dxcc\n) print
		%pstack
		extract_dxcc
		} %found blank, ie band/mode info found in line
		{
		%(no blank found, not band mode pair\n) print
		% pop dismembered line
		pop pop pop
		% put back fresh copy
		dxcc_line
		%pstack
		% have a country code on top of stack
		extract_dxcc % do it whether we find an band/mode or not
		} ifelse % blank not found
	} % colon found
	{
	%(bad line, no :) print
	%pstack
	exit	% bad line
	} ifelse

az_dict /band_worked undef
az_dict /dxcc_band_entry_found undef

} def


%--------------------------------------
% routine: Circular Text from the 'Blue Book'
% This prints text around a circle.
/outsidecircletext
{ $circtextdict begin
	/radius exch def
	/centerangle exch def
	/ptsize exch def
	/str exch def
	/xradius radius ptsize 4 div add def
	gsave
	centerangle str findhalfangle
	add rotate
	str
	{ /charcode exch def
		( ) dup 0 charcode put
		outsideshowcharandrotate
	} forall
	grestore
	end
} def

%--------------------------------------
/insidecircletext
 { $circtextdict begin
	/radius exch def
	/centerangle exch def
	/ptsize exch def
	/str exch def
	/xradius radius ptsize 3 div sub def
	gsave
	centerangle str findhalfangle
	sub rotate
	str
	{
		/charcode exch def
		( ) dup 0 charcode put
		insideshowcharandrotate
	} forall
	grestore
	end
az_dict /radius undef
az_dict /centerangle undef
az_dict /ptsize undef
az_dict /str undef
az_dict /xradius undef

 } def

%--------------------------------------
/$circtextdict 16 dict def
$circtextdict begin
/findhalfangle
	{
		stringwidth pop 2 div
		2 xradius mul pi mul div 360 mul
	} def

%--------------------------------------
/outsideshowcharandrotate
{
	/char exch def
	/halfangle char findhalfangle def
	gsave
	halfangle neg rotate
	radius 0 translate
	-90 rotate
	char stringwidth pop 2 div neg
	0 moveto char outlineshow
	grestore
	halfangle 2 mul neg rotate

az_dict /char undef
az_dict /halfangle undef

} def

%--------------------------------------
/insideshowcharandrotate
{
	/char exch def
	/halfangle char findhalfangle def
	gsave
	halfangle rotate
	radius 0 translate
	90 rotate
	char stringwidth pop 2 div neg
	0 moveto char outlineshow
	grestore
	halfangle 2 mul rotate

az_dict /char undef
az_dict /halfangle undef
} def

%--------------------------------------
/pi 3.1415923 def
end % $circtextdict,  end of circle routine


%--------------------------------------
/label_this_number_square
{
	% takes lat_counter, lon_counter off stack
	% returns true/false
	% routine checks location of number_square
	% to see if it is on the outside (border) of a letter_square.
	% returns on/true - square will be labled with numbers
	% returns off/false - square will be left blank
	% if are in numbering-all-squares mode,
	% then evaluation short circuits to true

	% lat_counter & lon_counter defined in grid_locator_numbers_show
	{
	true
	label_all_number_squares_in_a_letter_square	% do it All!
	{ exit } if
	lat_counter 0 eq
	{ exit } if
	lat_counter 9 eq
	{ exit } if
	lon_counter 0 eq
	{ exit } if
	lon_counter 9 eq
	{ exit } if
	not exit	% it's not true!
	} loop
}def

%--------------------------------------
/find_NSEW_limits
{
	% finds positions for the N,S,E,W limits
	% for drawing and labelling number squares
	% find values for globally defined variables
	%
	% northern_edge
	% southern_edge
	% eastern_edge
	% western_edge
	%
	% which are used by the routines
	% grid_locator_numbers_show, grid_locator_fine


	% find northern edge of the area which will have number labels
	% if QTH very close to (or exactly on) a letter square edge
	% then draw both the square above and below

	lat_QTH dup dup truncate sub abs
	very_small_distance lt
	{
		very_small_distance add
	} if % close to QTH, then increase lat_QTH by very_small_distance

	% lat_QTH on top of stack

	10 div ceiling
	grid_locator_number_squares_northern_limit dup -1 eq
	{
		% limit is -1, plot to north pole
		pop 89
		/northern_edge exch def
	}
	{
		% process input
		add 10 mul cvi
		% is it > 89 def
		dup 89 gt { pop 89 } if
		/northern_edge exch def
	} ifelse

	% find southern edge of the area which will have number labels
	% if QTH very close to (or exactly on) a letter square edge
	% then draw both the square above and below

	lat_QTH dup dup truncate sub abs
	very_small_distance lt
	{
		very_small_distance sub
	} if	% decrease lat_QTH by very_small_distance

	%lat_QTH % on top of stack
	10 div floor
	grid_locator_number_squares_southern_limit dup -1 eq
	{
		% limit is -1, plot to south pole
		pop -89
		/southern_edge exch def
	}
	{
		% process input
		sub 10 mul cvi
		% is it < -89 def
		dup -89 lt { pop -89 } if
		/southern_edge exch def
	} ifelse % process southern_limit


	% find eastern edge of the area which will have number labels
	% if QTH very close to (or exactly on) a letter square edge
	% then draw both the square to west and east
	lon_QTH dup dup truncate sub abs
	very_small_distance lt
	{
		very_small_distance add
	} if	% increase lon_QTH by very_small_distance

	%lon_QTH on top of stack
	20 div ceiling

	grid_locator_number_squares_eastern_limit dup -1 eq
	{
		% limit is -1, plot to Intl Date line in easterly dirn
		pop 180
		/eastern_edge exch def
	}
	{
		% process input
		add 20 mul cvi
		% is it > 180 def
		dup 180 gt { pop 180} if
		/eastern_edge exch def
	} ifelse

	% find western edge of the area which will have number labels
	% if QTH very close to (or exactly on) a letter square edge
	% then draw both the square to west and east
	lon_QTH dup dup truncate sub abs
	very_small_distance lt
	{
		very_small_distance sub
	} if	% decrease lon_QTH by very_small_distance

	% lon_QTH on top of stack
	20 div floor

	grid_locator_number_squares_western_limit dup -1 eq
	{
		% limit is -1, plot to Intl Date line in westerly dirn
		pop -180
		/western_edge exch def

	}
	{
		% process input
		sub 20 mul cvi
		% is it < -180 def
		dup -180 lt { pop -180} if
		/western_edge exch def
	} ifelse

	%(find_NSEW_limits: \n) print_notice northern_edge southern_edge eastern_edge western_edge pstack pop pop pop pop
	%(\n) print_notice
} def

%--------------------------------------

/grid_locator_numbers
[
	(0) (1) (2) (3) (4) (5) (6) (7) (8) (9)
] def

%--------------------------------------
/grid_num_str
	(locator numbers at lat,lon =           \b\b\b\b\b\b\b\b\b) def

/grid_locator_numbers_show
{
	(grid locator numbers: \n) print_notice
	/Helvetica-Bold findfont pop
	fine_gl_width master_line_width_factor mul setlinewidth
	grid_locator_number_color setrgbcolor
	find_NSEW_limits

	southern_edge 1 northern_edge 1 sub	%each latitude
	{
		/mem_state save def
		%find locator for number labels within square
		%dup /number_lat exch 0.5 add def
		dup /number_lat exch grid_locator_number_square_lat_center add def


			% add to move into middle of square
		/lat_counter exch 90 add
			% make +ve no matter what, since
			% mod gives -ve answers
		10 mod def	% lat index

		western_edge 2 eastern_edge 2 sub		% each longitude
		{
			dup grid_locator_number_square_lon_center add /number_lon exch def
			% add to move into middle of square

			% send to error output, so we keep tabs on whats going on
			send_notices verbose and
			{
				grid_num_str print
				number_lat 0.5 sub cvi grid_string cvs print
				COMMA print
				number_lon 1 sub grid_string cvs print CR print
				flush
			} if

			/lon_counter exch 180 add
			% make +ve no matter what or else mod will give -ve answers
			20 mod 2 idiv def % lon index


			label_this_number_square
			% if labelling are we in border or in do it all mode?
			{
				[ -1 1 ]
				{
					/offset_direction exch def
					gsave
					% first letter, move left 0.4 degrees
					%number_lat number_lon 0.4 offset_direction mul add
					number_lat number_lon grid_locator_number_square_lon_offset offset_direction mul add
					lat_lon2xy moveto
					% find the local slope of the lon lines
					% - stand letters on them
					%number_lat number_lon 0.4 offset_direction mul add 0.1 add
					number_lat number_lon grid_locator_number_square_lon_offset offset_direction mul add 0.1 add
					lat_lon2xy
					% x on top of stack, y next
					/y1 exch def
					/x1 exch def
					%number_lat number_lon 0.4 offset_direction mul add 0.1 sub
					number_lat number_lon grid_locator_number_square_lon_offset offset_direction mul add 0.1 sub
					lat_lon2xy
					% x on top of stack, y next
					/y2 exch def
					/x2 exch def

					% find how stretched out things are in the lon
					% direction so we know how big to make letters
					y1 y2 sub dup /lon_y exch def
					% save x component of lon vector
					dup mul			% and square it
					x1 x2 sub dup /lon_x exch def
					% save y component of lon vector
					dup mul			% and square it
					add sqrt /lon_len exch def	% length of lon vector (for normalising)
					%(grid_locator_numbers_show: lon_len \n) print_notice lon_len pstack pop

					% find the local slope of the lat lines
					%number_lat 0.4 sub 0.1 add number_lon
					number_lat grid_locator_number_square_lon_offset sub 0.1 add number_lon
					lat_lon2xy
					% x on top of stack, y next
					/y1 exch def /x1 exch def
					%number_lat 0.4 sub 0.1 sub number_lon
					number_lat grid_locator_number_square_lon_offset sub 0.1 sub number_lon
					lat_lon2xy
					% x on top of stack, y next
					/y2 exch def /x2 exch def

					% find how stretched out things
					% are in the lat direction so
					% we know how big to make letters
					y1 y2 sub dup /lat_y exch def dup mul
					x1 x2 sub dup /lat_x exch def dup mul
					add sqrt /lat_len exch def

					% near poles, due to limited precision of
					% ghostscript, lon_len=0,
					% need to trap 0 div error
					lon_len very_small_distance lt
					{
						% don't even try to handle it
						exit
					}{

						[
						lon_x lon_len div lon_y lon_len div
						lat_x lat_len div lat_y lat_len div
						0			0
						] concat

						% if in "down under" mode, rotate letters 180 def
						orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or
						{
							%(grid_locator_numbers_show: rotate letters 180 deg \n) print_notice pstack
							[
							-1 0
							0 -1
							0  0
							] concat
						} if

						/Helvetica-Bold findfont
						grid_locator_number_font_scale
						scalefont setfont

						grid_locator_numbers
						offset_direction -1
						% change direction if in "down under" mode
						orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or
						{neg} if
						eq
						{lon_counter}{lat_counter} ifelse
						get
						% stringwidth, the setfont and the charpath routines
						% are responsible for chewing up alot of VM.
						dup stringwidth

						% wx, wy on stack, adjust till looks about right
						pop grid_locator_number_font_scale
						3 div neg exch neg 2 div exch rmoveto
						true charpath
						number_square_labels_outlined {stroke}{fill} ifelse
					} ifelse % trap if near poles
				grestore
				} forall % 1st & 2nd numbers
			} if % label_this_number_square
		} for % sweep along this lon
		mem_state restore
	} for %each latitude
	(\n) print_notice

az_dict /x1 undef
az_dict /x2 undef
az_dict /y1 undef
az_dict /y2 undef

} def % grid_locator_numbers_show

%--------------------------------------

/grid_locator_letter_font_scale
{
	% this code replaces last years winner of the obfuscated Postscript competition
	%lat_len lon_len gt { lon_len }{ lat_len } ifelse 45 mul
	lat_len lon_len gt { lon_len }{ lat_len } ifelse
	grid_locator_letter_font_scale_fudge_factor mul

} def

%--------------------------------------

/grid_locator_number_font_scale
{
	%grid_locator_letter_font_scale 10 div
	grid_locator_letter_font_scale 10 div grid_locator_number_font_scale_fudge_factor mul
} def

%--------------------------------------
/grid_let_str
	(locator letters at lat,lon =           \b\b\b\b\b\b\b\b\b) def

/grid_locator_letters
[
	(A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) (L) (M) (N) (O) (P) (Q) (R)
] def

/grid_locator_letters_show
{
	mark
	%(grid locator letters: start \n) print_notice pstack flush
	% set narrower line width for smaller letters in arrl style
	fine_gl_width master_line_width_factor mul
	grid_locator_labelling_style (az_proj) eq {3 div} if
	grid_locator_labelling_style (arrl) eq {6 div} if
	setlinewidth
	/Helvetica-Bold findfont pop	%load the font
	%
	% there is some wierd bug here that I haven't traced
	% the pair of numbers 110, 110 get left on the stack
	% when code gets to lat -45, lon 110
	% I don't know what it's about, as it doesn't happen at any other place
	% in this set of loops. You can see this bug by uncommenting the lone
		% pstack
	% command at the bottom of the -170 20 170 loop
	%
	% Since the bug seems benign, I've handled it by putting a mark on the stack
	% and then clearing to the mark on exiting from this routine
	% JM, Mar 95


	-85 10 +85			% each latitude
	{
		/mem_state save def
		dup /letter_lat exch def

		/lat_counter exch 85 add 10 div def		% lat index

		-170 20 170	%each longitude
		{
			dup /letter_lon exch def
			send_notices verbose and
			{
				grid_let_str print
				letter_lat grid_string cvs print COMMA print
				letter_lon grid_string cvs print CR print
				flush
			} if

			letter_lat letter_lon gc
			pop	% bearing, leaving dist on stack
				% test if are near the antipodes
				% only draw grid squares in which whole of square
				% is inside the antipodes
				% the other ones, which spill over onto the other
				% side of the world aren't handled real well and
				% have HUGE letters

			170 lt	% is it closer than 170 deg away?
			{

				/lon_counter exch 170 add 20 div def	% lon index
				/delta 0.3 def
				% any smaller than this and you div 0 errors near the pole due to single precision math of Postscript
				% (try Sydney at lon 151 with grid letters on, arrl style, or lon 154 with az_proj style)


				[ -1 1 ]
				{
					% have to do letters in the opposite direction and
					% upside down if doing a "down under" orientation
					% here do opposite direction
					/offset_direction exch def
					%/posn exch def
					gsave	% first letter, move left 4 degrees
						% second letter move right 4 degrees
					%letter_lat letter_lon 4 posn mul add
					letter_lat letter_lon grid_locator_letter_square_lon_offset offset_direction mul add
					lat_lon2xy moveto
						% We're now at the point where a letter will be drawn
						% find the local slope of the lon lines
						%	- will stand letters on them
						% I just fiddled slopes and negs and x1, y1's etc
						% until the orientation was right on the screen
						% - the math may not be right - JM
					%letter_lat letter_lon 4 posn mul add 0.1 add
					letter_lat letter_lon grid_locator_letter_square_lon_offset offset_direction mul add delta add
					%(grid_locator_letters_show: lat lon \n) print_notice pstack
					lat_lon2xy
						% x on top of stack, y next
					%(grid_locator_letters_show: x1 y1 \n) print_notice pstack

					/y1 exch def
					/x1 exch def
					%letter_lat letter_lon 4 posn mul add 0.1 sub
					letter_lat letter_lon grid_locator_letter_square_lon_offset offset_direction mul add delta sub
					%(grid_locator_letters_show: lat lon \n) print_notice pstack
					lat_lon2xy
						% x on top of stack, y next
					%(grid_locator_letters_show: x2 y2 \n) print_notice pstack
					/y2 exch def
					/x2 exch def
						% find how stretched out things are in the lon
						% direction so we know how big to make letters
					y1 y2 sub delta div 0.1 mul dup /lon_y exch def
						% save x component of lon vector
					dup mul	% and square it
					x1 x2 sub delta div 0.1 mul dup /lon_x exch def
						% save y component of lon vector
					dup mul	% and square it
					add sqrt delta div 0.1 mul
					/lon_len exch def
					%(grid_locator_letters_show: lon_len \n) print_notice lon_len pstack pop

						% length of lon vector (for normalising)
						% find the local slope of the lat lines
					%letter_lat 0.1 add letter_lon 4 posn mul add
					letter_lat delta add letter_lon grid_locator_letter_square_lon_offset offset_direction mul add
					lat_lon2xy
						% x on top of stack, y next
					/y1 exch def
					/x1 exch def
					%letter_lat 0.1 sub letter_lon 4 posn mul add
					letter_lat delta sub letter_lon grid_locator_letter_square_lon_offset offset_direction mul add
					lat_lon2xy
						% x on top of stack, y next
					/y2 exch def
					/x2 exch def
						% find how stretched out things are in the
						% lat direction so we know how big to
						% make letters
					y1 y2 sub delta div 0.1 mul dup /lat_y exch def
					dup mul
					x1 x2 sub delta div 0.1 mul dup /lat_x exch def
					dup mul
					add sqrt delta div 0.1 mul
					/lat_len exch def
					%(grid_locator_letters_show: lat_len \n) print_notice lat_len pstack pop
					% have to have delta in the matrix, so that the size of the letters doesn't change with delta

					[
					lon_x lon_len div lon_y lon_len div
					lat_x lat_len div lat_y lat_len div
					0		  0
					] concat

					% if "down under" rotate letters 180 def
					orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or
					{
						%(grid_locator_letters_show: rotate letters 180 deg \n) print_notice pstack
						[
						-1 0
						0 -1
						0  0
						] concat
					} if

					/Helvetica-Bold findfont
					grid_locator_letter_font_scale scalefont setfont
					grid_locator_letter_color setrgbcolor
					grid_locator_letters

					%Pick the letter according to the lat_counter or the lon_counter
					% depending on the direction of the offset
					offset_direction -1
					orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or
					{neg} if % if in "down under" mode use the opposite convention
					eq
					{ lon_counter }{ lat_counter } ifelse cvi get
						% char on top of stack
					dup stringwidth
						% wx, wy on stack, adjust till looks about right
					pop grid_locator_letter_font_scale 3 div neg
					exch neg 2 div exch rmoveto true charpath
					letter_square_labels_outlined {stroke}{fill} ifelse
					grestore
				} forall % 1st and 2nd letters
			}if %170 lt
			%pstack	% uncomment this to see the numbers 110, 110 appear on the stack
		} for % sweep along this latitude
		mem_state restore
	} for % each latitude
	LF verbose_notice
	cleartomark

az_dict /x1 undef
az_dict /x2 undef
az_dict /y1 undef
az_dict /y2 undef

az_dict /delta undef

%(grid_locator_letters_show: end \n) print_notice pstack


}def

%--------------------------------------

/grid_locator_small_letters
[
(a) (b) (c) (d) (e) (f) (g) (h) (i) (j) (k) (l) (m) (n) (o) (p) (q) (r) (s) (t) (u) (v) (w) (x) 
] def

%--------------------------------------

/lat_lon_to_grid_locator
	{
	%if have length 10 and we have a 6char gridsquare, then the last 4 chars will be \000
	%I can't see a way to ignore the nulls. 
	%So we are limited to 6 char gridsquares
	/grid_locator_string 6 string def
	%turns decimal lat/lon into 6 char gridlocator
	%
	%takes /lat, /lon globals
	%returns /grid_locator as global
	%
	%input lat/lon in decimal degrees. N is +ve, E is +ve
	%output will be a string of format FN05lw (UC,UC,int,int,lc,lc)
	%the origin of the gridlocator system is lat=-90, lon=-180
	%The first two chars indicate which of box of (10 deg lat x 20 deg lon). 
	%There are 18 of these in each direction. 
	%Within this box, the next two chars (numbers) are (1 deg lat x 2 def lon). 
	%There are 10 of these in each direction.
	%The last 2 chars (2.5min lat x 5 min lon). 
	%There are 24 of these in each direction 
	%
	%original code by Mark WM7D, mailto:wm7d@wm7d.net
	%prettied up by Joe Mack, NA3T, Nov 97
	%changed from perl to postscript Joseph Mack NA3T, Jun 00 mailto:jmack@wm7d.net
	%perl and postscript have arrays that start at index=0
	%
	%----------------
	
	%allowable output characters
	%
	%/grid_locator_letters 		(A..R)	18 letters 
	%/grid_locator_numbers 		(0..9)	10 numbers	
	%/grid_locator_small_letters	(a..x)	24 letters 

	%(24 is a hangover from the Babylonian days 
	%when the units of lat/lon were H:M:S, 
	%giving the then sensible interval of 2.5 or 5 mins for each letter).
	%Note this scheme divides the world into 18x10x24 divisions, 
	%this 200yrs after Napoleon gave us the decimal system.
	
	%----------------------------------
	%(lat_lon_to_gridsquare: start \n) print_notice pstack 
	% 
	%usually do lat then lon, however gridsquares are done lon,lat	
	% change origin of lat/lon
	lon 180 add /grid_lon exch def
	lat 90 add /grid_lat exch def
	%grid_lon grid_lat (lat_lon_to_gridsquare: grid_lon grid_lat \n) print_notice pstack pop pop
	
	%do all math in terms of 18*10*24 divisions
	grid_lon 18 mul 10 mul 24 mul 360 div cvi /index_lon exch def
	grid_lat 18 mul 10 mul 24 mul 180 div cvi /index_lat exch def 
	%index_lat index_lon (lat_lon_to_gridsquare: index_lat index_lon \n) print_notice pstack pop pop 
	
	%get first char from each of lat/lon
	grid_locator_letters index_lon 10 div 24 div cvi 
		dup /index_char1 exch def
		1 
		%(lat_lon_to_gridsquare: first_char \n) print_notice pstack 
		getinterval 0 get /first_char exch def	%(A..R)	18 letters 
		%first_char index_char1 (lat_lon_to_gridsquare: first_char \n) print_notice pstack pop pop
	grid_locator_letters index_lat 10 div 24 div cvi 
		dup /index_char2 exch def
		1 
		%(lat_lon_to_gridsquare: second_char \n) print_notice pstack 
		getinterval 0 get /second_char exch def	%(A..R)	18 letters a
		%second_char index_char2 (lat_lon_to_gridsquare: second_char \n) print_notice pstack pop pop

	%index_char1 index_char2 (lat_lon_to_gridsquare: index_char1 index_char2 \n) print_notice pstack pop pop 

	%decrement indexes
	index_lon index_char1 10 mul 24 mul sub /index_lon exch def
	index_lat index_char2 10 mul 24 mul sub /index_lat exch def
	%index_lat index_lon (lat_lon_to_gridsquare: index_lat index_lon \n) print_notice pstack pop pop 
	%get number from each of lat/lon
	grid_locator_numbers index_lon 24 div cvi 
		dup /index_char3 exch def
		1 
		%(lat_lon_to_gridsquare: third_char \n) print_notice pstack 
		getinterval 0 get /third_char exch def		%(0..9)	10 numbers
		%third_char index_char3 (lat_lon_to_gridsquare: third_char \n) print_notice pstack pop pop
	grid_locator_numbers index_lat 24 div cvi 
		dup /index_char4 exch def
		1 
		%(lat_lon_to_gridsquare: fourth_char \n) print_notice pstack 
		getinterval 0 get /fourth_char exch def	%(0..9)	10 numbers
		%fourth_char index_char4 (lat_lon_to_gridsquare: fourth_char \n) print_notice pstack pop pop

	%decrement indexes
	index_lon index_char3 24 mul sub /index_char5 exch def
	index_lat index_char4 24 mul sub /index_char6 exch def
	grid_locator_small_letters index_char5 
		1 
		%(lat_lon_to_gridsquare: fifth_char \n) print_notice pstack 
		getinterval 0 get /fifth_char exch def	%(a..x)	24 letters 
		%fifth_char index_char5 (lat_lon_to_gridsquare: fifth_char \n) print_notice pstack pop pop
	grid_locator_small_letters index_char6 
		1 
		%(lat_lon_to_gridsquare: sixth_char \n) print_notice pstack 
		getinterval 0 get /sixth_char exch def	%(a..x)	24 letters 
		%sixth_char index_char6 (lat_lon_to_gridsquare: sixth_char \n) print_notice pstack pop pop

	%sixth_char fifth_char fourth_char third_char second_char first_char (lat_lon_to_grid_locator: exit \n) print_notice pstack pop pop pop pop pop pop

	%(FM05lw) toupper /grid_locator exch def %dummy return line	
	%create output string (look how easy it is to concatenate 6 chars into a string in postscript). 
	grid_locator_string 0 first_char temp_string cvs putinterval 
	grid_locator_string 1 second_char temp_string cvs putinterval 
	grid_locator_string 2 third_char temp_string cvs putinterval 
	grid_locator_string 3 fourth_char temp_string cvs putinterval 
	grid_locator_string 4 fifth_char temp_string cvs putinterval 
	grid_locator_string 5 sixth_char temp_string cvs putinterval 
	%grid_locator_string (lat_lon_to_gridsquare: grid_locator_string cvs \n) print_notice pstack pop
	grid_locator_string toupper /grid_locator exch def
	%grid_locator (lat_lon_to_gridsquare: grid_locator \n) print_notice pstack pop
} def %lat_lon_to_grid_locator

%--------------------------------------

/LAT_FLAG true def
/LON_FLAG false def

/grid_lat_str
	(latitude line              =           \b\b\b\b\b\b\b\b\b) def

/grid_locator_lat
{

	%figure out spacing
	draw_lat_lon_lines
	{
		alternate_lat_spacing /lat_spacing exch def
	}
	{
		/lat_spacing 10 def
	} ifelse




	-90 lat_spacing add lat_spacing +90 lat_spacing	sub			% each latitude
	{
		/lat_start exch def
		lat_start 0 eq
			{
				coarse_gl_width grid_line_emphasis mul master_line_width_factor mul setlinewidth
			}
			{
				coarse_gl_width master_line_width_factor mul setlinewidth
			} ifelse
		send_notices verbose and
		{
			grid_lat_str print
			lat_start grid_string cvs print CR print
			flush
		} if

		lat_start neg lat_QTH sub abs 0.1 lt
		{
			LAT_FLAG lat_start -179 lon_QTH add 179 lon_QTH add contour_draw
		}{
			LAT_FLAG lat_start -180 180 contour_draw
		} ifelse
	} for
	LF verbose_notice
}def

%--------------------------------------

/grid_lon_str
	(longitude line             =           \b\b\b\b\b\b\b\b\b) def

/grid_locator_lon
{

	%figure out spacing
	draw_lat_lon_lines
	{
		alternate_lon_spacing /lon_spacing exch def
	}
	{
		/lon_spacing 20 def	%for grid_locators
	} ifelse


	-180 lon_spacing +180				%each longitude line
	{
		/lon_start exch def
		lon_start 0 eq
			{
				coarse_gl_width grid_line_emphasis mul master_line_width_factor mul setlinewidth
			}
			{
				coarse_gl_width master_line_width_factor mul setlinewidth
			} ifelse

		send_notices verbose and
		{
			grid_lon_str print
			lon_start grid_string cvs print CR print
			flush
		} if

		lon_start dup 0 lt { 180 }{ -180 } ifelse add lon_QTH sub abs 0.1 lt
		{
			LON_FLAG lon_start lat_QTH neg 1 add 89 contour_draw
			LON_FLAG lon_start -89 lat_QTH neg 1 sub contour_draw
		}{
			LON_FLAG lon_start -89 89 contour_draw
		} ifelse
	} for
	LF verbose_notice
} def

%--------------------------------------
/contour_draw
{

	/end_point	exch def
	/counter	exch def	% the initial point in the line
	/fixed_ord	exch def	% the fixed ordinate
	/lon_lat	exch def	% flag to tell us up or down!


%	After each point is transformed from mercator space to azimithal
%	space, its displacement from the previous point is checked (actually
%	the square of the displacement). If it is greater than 'max_contour_step' amount
%	we halve our steps in mercator space. If it is less than 'min_contour_step' amount
%	we double our steps.
%	This works, but is not a great algorythm. It is designed to handle
%	lines near the antipodes, which move very quickly in az projection
%	space for small changes in lat/lon space. However for QTHs very near
%	the poles, the latitude lines are tightly circular and this routine
%	will produce a lot of jaggies, unless max_contour_step is kept small. Meanwhile the
%	longitude lines are very straight and are drawn in unneccessary detail.

	/incr 0.5 def		% initial step in mercator space
	/min_contour_step 1.0 def		% the square of the min_contour_stepimum step in az space
	/max_contour_step 4.0 def		% the square of the maximum step in az space

	newpath counter fixed_ord lon_lat { exch } if lat_lon2xy
	moveto

	{
		counter fixed_ord lon_lat { exch } if lat_lon2xy

		currentpoint 2 index sub dup mul	% square of distance is sum
		exch 3 index sub dup mul add	% of squares of x & y distance
		dup max_contour_step gt incr incr_lim gt and
		{
			/incr incr 2.0 div def pop pop pop
			/counter counter incr sub def
		}{ % too much movement - halve step
			min_contour_step lt
			{
				/incr incr 2.0 mul def	% we move too little in az space
			} if				% we draw even if we are less
							% than min_contour_step distance
			lineto
			counter end_point ge { exit } if
			/counter incr counter add def
		} ifelse
	} loop
	stroke

az_dict /end_point undef
az_dict /counter undef
az_dict /fixed_ord undef
az_dict /lon_lat undef
az_dict /incr undef
az_dict /min_contour_step undef
az_dict /max_contour_step undef


} def

%--------------------------------------

/grid_locator_coarse
{
	(Letter grid squares: \n) print_notice
	newpath
	grid_locator_letter_color 1 1 3 { pop shade mul 3 1 roll } for setrgbcolor
	grid_locator_lat
	grid_locator_lon
} def

%--------------------------------------

/grid_fine_lat_str
	(latitude  line             =           \b\b\b\b\b\b\b\b\b) def

/grid_fine_lon_str
	(longitude line             =           \b\b\b\b\b\b\b\b\b) def

/grid_locator_fine
{
	gsave
	(\nNumber grid squares: \n) print_notice

	find_NSEW_limits % only do for limited number of squares

	grid_locator_number_color 1 1 3 { pop shade mul 3 1 roll } for
	setrgbcolor
	1 setlinejoin
	fine_gl_width master_line_width_factor mul setlinewidth
	number_square_edges_dashed {[.1 .25] 0 setdash} if

	southern_edge 1 northern_edge		% each latitude
	{
		/lat_start exch def
		send_notices verbose and
		{
			grid_fine_lat_str print
			lat_start grid_string cvs print CR print
			flush
		} if

		newpath
		lat_start western_edge
		lat_lon2xy
		moveto
		western_edge 1 eastern_edge
			% draw in 1 deg segments to get curved line
		{
			lat_start exch		% other point from do loop counter
			lat_lon2xy
			lineto
		} for				% sweep along this latitude
		stroke
	} for					%each latitude
	(\n) print_notice

	western_edge 2 eastern_edge		%each longitude line
	{
		%(grid_locator_fine: west to east \n) print_notice pstack
		% there are problems if drawing lon line that is
		% 180 opposite you by this method.
		% An attempt to go outside the border will result in
		% a line crossing back across the north (or south) pole
		% trap this line.

		dup
%		% find lon opposite the QTH
		lon_QTH 180 add dup
		180 gt
		{360 sub} if
%		% compare

		sub dup mul 1 lt % difference is lt 1 deg
		%eq
		{
			%(grid_locator_fine: don't plot this one \n) print_notice pstack
			pop
		} % loop variable
		{
			/lon_start exch def
			send_notices verbose and
			{
				grid_fine_lon_str print
				lon_start grid_string cvs print CR print
				flush
			} if % verbose on

			newpath
			southern_edge lon_start
			lat_lon2xy
			moveto

			southern_edge 1 northern_edge
			{
				lon_start lat_lon2xy
				lineto
			} for	% sweep along this longitude
			stroke
		} ifelse % lon line isn't opposite QTH
%		} if % lon line isn't opposite QTH
	} for	% each longitude
	LF verbose_notice
	grestore
} def


%--------------------------------------

/outer_border
{
	%(outer_border: start \n) print_notice
	gsave
	fine_gl_width master_line_width_factor mul setlinewidth
	outer_border_color setrgbcolor
	newpath
	0 0 180 0 360 arc closepath stroke
	0 0 180 atom 40 mul add 0 360 arc
	closepath
	stroke

%compass_rose
%Used to call compass_rose here, but color of outer_border is not passed.
%Here is same routine with its own color

	newpath
	180 atom 40 mul add
	gsave
	/rad exch def
	compass_line_width master_line_width_factor mul setlinewidth
	0 5 359
	{
		rad 0 moveto
		dup cvi 15 idiv exch 15.0 div sub 0 eq { 30 }{ 17 } ifelse
		atom mul neg 0 rlineto stroke
		5 rotate
	} for
	0 0 rad 0 360 arc closepath stroke
	grestore
	180 atom 50 mul add label_compass_directions
	grestore
} def

%--------------------------------------

/compass_rose
{
	newpath
	gsave
	/rad exch def % in degrees
	compass_line_width master_line_width_factor mul setlinewidth
	compass_color setrgbcolor
	0 5 359
	{
		rad 0 moveto
		dup cvi 15 idiv exch 15.0 div sub 0 eq { 30 }{ 17 } ifelse
		atom mul neg 0 rlineto stroke
		5 rotate
	} for
	0 0 rad 0 360 arc closepath stroke
	grestore
} def

%--------------------------------------

/label_compass_directions
{
	gsave
	/rad exch def
	compass_label_color setrgbcolor
	/Helvetica findfont bearing_fontsize scalefont setfont

	orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or { 180 rotate} if
	360 compass_label_increment neg 1
	{
		0 rad moveto name cvs dup stringwidth pop 2 div neg
		bearing_fontsize 2 mul neg rmoveto show
		compass_label_increment rotate
	} for
	%(Compass Directions\n) print_notice
	orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or { -180 rotate} if
	grestore
} def

%--------------------------------------

/draw_bearing_rose
{
	(Compass Circumference\n) print_notice

	% A few problems need to be handled here.
	% First the radius of the compass(es) needs to be determined.
	% Then the circumference is drawn
	% Then the spokes are drawn.
	% Then the labels need to be drawn on the spokes.
	% If the spokes are drawn after the labels, then some of the directions
	% eg "315" degrees will have a spoke drawn over the "1".
	% Since several compasses/spokes/label sets can be drawn here,
	% the largest compass is drawn first, then the spokes. After that
	% the spoke_drawing is turned off. Then subsequent compasses and
	% labels are drawn.


	% find the "ballpark" (1000, 100 or 10 kms)
	/Helvetica findfont bearing_fontsize scalefont setfont

	% see if QTH is off the map, and if so handle the compass drawing
	% differently
	lat_center lon_center gc /mbear exch def /mdist exch def
	mdist map_scale_deg sub deg2km 0 gt
	{
		% QTH is off the page (or nearly so)
		% We 'round' off the distance to the centre
		% order_of_mag from /setup_dimensions

		mdist deg2km order_of_mag div cvi order_of_mag mul /datum exch def

		% we find the compass rose that is the largest that will fit
		% on the page (in increments of the order of magnitude)
		9 -1 1
		{
			order_of_mag mul /limit exch def
			limit km2deg map_scale_deg .9 mul lt
			{
				exit
			} if
		} for
		% draw this larger compass rose if it is within the world
		datum limit add dup km2deg dup 170 lt
		{
			/rad exch def %need value for rad in draw_spokes
			%rad = (rad 1 \n ) print_notice
			rad compass_rose
			draw_compass_spokes
				{
					draw_spokes
					/draw_compass_spokes off def
				} if
			rad label_compass_directions
			rad mbear km_show
		}{
			pop pop
		} ifelse

		% draw the compass rose if it is inside the globe (less than 180 deg) and
		% greater than 1/4 of the page.
		datum km2deg dup map_scale_deg 0.25 mul ge exch 170 lt and
		{
			datum dup km2deg %radius
			/rad exch def %need value for rad in draw_spokes
			%rad = (rad 2 \n ) print_notice
			rad compass_rose % these two routine need radius on the stack
			draw_compass_spokes
				{
					draw_spokes
					/draw_compass_spokes off def
				} if
			rad label_compass_directions
			rad mbear km_show
		} if

		% draw the size below the datum if it isn't smaller than 1/4 screen
		datum limit sub dup km2deg dup map_scale_deg 0.25 mul ge
		{
			/rad exch def %need value for rad in draw_spokes
			%rad = (rad 3 \n ) print_notice
			rad	compass_rose
			draw_compass_spokes
				{
					draw_spokes
					/draw_compass_spokes off def
				} if
			rad label_compass_directions
			rad mbear km_show
		}{
			pop pop
		} ifelse
	} if

	% draw a rose on the screen (largest that corresponds to a multiple
	% of 1, 2, or 5 times the order of magnitude

	[ 5 2 1 ]
	{
		dup order_of_mag mul map_scale_deg compass_coerce deg2km lt
		{
			exit
		}{
			pop
		} ifelse
	} forall

	order_of_mag mul dup km2deg dup 170 lt
	{
		/rad exch def %need value for rad in draw_spokes
 		%rad = (rad 4 \n ) print_notice
		rad compass_rose
		draw_compass_spokes
			{
				draw_spokes
				/draw_compass_spokes off def
			} if
		rad label_compass_directions
		rad compass_label_color  1 1 3 { pop shade mul 3 1 roll } for setrgbcolor
		0 exch moveto cvi 10 string cvs dup stringwidth pop
		( km) stringwidth pop add 2 div neg coarse_gl_width rmoveto show ( km) show
	}{
		pop pop
	} ifelse
} def

%--------------------------------------
/draw_distance_circles
% around QTH
% on stack - radius of circle in km
{
	(draw_distance_circles: \n) print_notice pstack
	dup
	/rad_km exch def	% radius of circle in km
	km2deg /rad exch def	% radius of circle in degrees
	%determine place to put label
	%if no center offset then put label at 0 deg
	%if center_offset is on,
	%then put label in same direction as the offset center
	center_offset
	{
		%center is offset
		lat_center lon_center gc
		/label_bearing exch def
		pop
		%(draw_distance_circles: label_bearing \n) print_notice label_bearing pstack pop
	}
	{
		%no center_offset
		0 /label_bearing exch def
		%(draw_distance_circles: label_bearing \n) print_notice label_bearing pstack pop
	}ifelse % center_offset

	%rad_km rad 0 km_show
	rad_km rad neg label_bearing km_show

	newpath
	gsave
	compass_line_width master_line_width_factor mul setlinewidth
	compass_color setrgbcolor
	0 0 rad 0 360 arc closepath stroke
	grestore

}def
%--------------------------------------
/km_show
% print "XXXXkms"
% on stack: kilometers (real or int) <== first entry on stack (last off)
%	bearing (degrees)
%	distance (degrees)
{
	distance_bearing2xyneg moveto
	%(km_show: \n) print_notice
	/Helvetica findfont bearing_fontsize scalefont setfont
	compass_label_color 1 1 3 { pop shade mul 3 1 roll } for
	setrgbcolor
	cvi name cvs dup stringwidth pop
	( km) stringwidth pop add 2 div neg coarse_gl_width 10 mul neg rmoveto show ( km) show
} def

%-------------------------------------
/draw_spokes
{
	gsave
	%need extra space at end of string to clear previous line on screen
	(Compass Spokes            \n) print_notice
	%this next one will fail if rad is unknown.
	%rad (rad \n) print_notice pstack pop
	%compass_spokes_to_antipodes (compass_spokes_to_antipode \n) print_notice pstack pop	

	% find the "ballpark" (1000. 100 or 10 kms)
	compass_line_width master_line_width_factor mul setlinewidth
	compass_color setrgbcolor
	/compass_min 0 def
	{
		/compass_min compass_min order_of_mag 10 div add def
		compass_min map_scale_deg deg2km 6 div gt
		{
			exit
		} if
	} loop

	0 compass_spoke_interval 359  % change middle integer for different spacings of spokes
	{
		30 mod 0 eq	% the first number in this line is the interval
				% between spokes that reach right to the center (=QTH)
		{
			0 0	% these lines start at center (ie QTH)
		}
		{
			0 compass_min km2deg
			%these lines start at dist=compass_min away from QTH
		} ifelse
		moveto 0

		% if draw_compass_circumference is on, then rad will be set.
		% if rad is set then you look at compass_spokes_to_antipodes.
		% if draw_compass_circumference is off, then draw spokes to antipodes.
		% if compass_spokes_to_antipodes is on, then draw spokes to antipodes.
		az_dict /rad known compass_spokes_to_antipodes not and
		{	rad	}	{	180	} ifelse
		lineto stroke
		% note rad is not defined unless have already executed compass_rose.
		% Incase this routine is not executed, rad is predefined at 180 (up top).
		% (hmm Jun 2001, can't see where rad is set to 180).
		newpath compass_spoke_interval rotate
	} for %compass_spoke_interval
	grestore
} def

%--------------------------------------
% Ghostscript has arccos.
% (Unfortunately Ghostscript arccos does not handle values <-1.0 and >1.0
% real well - the program will crash. Such numbers (eg 1.000001) can appear
% through rounding errors and are handled separately in the routine gc.)
%
% Standard postscript does not have a built in 'arccos', but using
% atan', which it has, and some Pythagorean geometry we
% can synthesize it.	- M.K.

/Arccos
{
	% arccos(x) = atan( sqrt( (1/x)**2 - 1) )
	/x exch def
	{
		x 1.0 gt
		{ % x > 1, Error
			0.0 exit
		} if
		x -1.0 lt
		{  % x < 1, Error
			180.0 exit
		} if

		x 0.0 eq
		{
			90.0 exit
		} if

		1.0 x div dup mul 1 sub sqrt 1 atan
		x 0 lt
		{
			180 exch sub
		} if
		exit
	} loop
az_dict /x undef
} bind def

/arcsin
{
	% arcsin(x) = atan( sqrt( 1/((1/x)**2 - 1)) )
	%(arcsin: start \n) print_notice pstack
	/x exch def
	{
		x 1.0 gt
		{ % x > 1, Error
			90.0 exit
		} if
		x -1.0 lt
		{  % x < 1, Error
			270.0 exit
		} if

		x 0.0 eq
		{
			0.0 exit
		} if

		1.0 x div dup mul 1 sub 1 exch div sqrt
		x 0.0 lt {neg} if	%loose quadrant info by squaring x, have to partially restore
		1 atan
		dup 180 gt {360.0 sub} if	%turns Declination of 340 deg into more recognisable -20
		exit
	} loop
	%(arcsin: exit \n) print_notice pstack
az_dict /x undef
} bind def


%--------------------------------------

/gc
% to call, push lat, lon of dest
% on exit, pushes dist (in deg) bearing (deg) on stack
{
	% *	Code adapted from
	% *	gc.c
	% *
	% *	Great Circle. This program is used to determine bearing
	% *	and range to a station given latitude and longitude data.
	% *
	% *	Ver 1.01 By S. R. Sampson, N5OWK
	% *	Public Domain (p) November 1989
	% *
	% *	Ref: Air Force Manual 51-40, "Air Navigation", 1 February 1987
	% *

	/DEST_Long exch def
	/DEST_Lat exch def

	%lat_QTH = (gc: lat_QTH \n) print_notice
	%lon_QTH = (gc: lon_QTH \n) print_notice

	/QTH_Long lon_QTH def
	/QTH_Lat lat_QTH def

	%/* Compute the Bearing and Range, From the Formula in Chapter 23 */

	DEST_Long QTH_Long sub /Delta_Long exch def

	QTH_Lat sin DEST_Lat sin mul
	QTH_Lat cos DEST_Lat cos mul Delta_Long cos mul
	add

	%Check for out of range numbers before running arccos
	dup 1.0 gt {pop 1.0}if
	dup -1.0 lt {pop -1.0}if
	arccos /dist exch def

	%if distance is very small (eg 0.0) then cannot determine bearing,
	%return bearing = 0

	very_small_distance dist gt
	{
		/bearing 0 def
	}{
		% if at the antipodes can't determine bearing either
		distance_to_antipodes dist lt
		{
			/bearing 0 def
		}{
			DEST_Lat sin QTH_Lat sin dist cos mul sub
			dist sin QTH_Lat cos mul div
			dup -1.0 lt { pop -1.0} if
			dup  1.0 gt { pop 1.0} if
			arccos
			/bearing exch def

			Delta_Long 180.0 gt
			{
				Delta_Long 360 sub /Delta_Long exch def
			} if

			Delta_Long 0.0 lt
			{
				Delta_Long -180 gt
				{
					360.0 bearing sub
					/bearing exch def
				} if
			} if
		} ifelse
	}ifelse
	dist bearing
}def %gc

%--------------------------------------

/distance_bearing2xy
% call by pushing distance, then bearing
% of exit pushes y, then x
{
	/bearing exch def
	/distance exch def	%is in degrees

	orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or
	{
	bearing sin neg distance mul % this is y
	bearing cos distance mul neg% this is x
	}
	{
	bearing sin neg distance mul neg % this is y
	bearing cos distance mul % this is x
	}ifelse


}def

/distance_bearing2xyneg
% call by pushing distance, then bearing
% of exit pushes y, then x
{
	/bearing exch def
	/distance exch def	%is in degrees

	orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or
	{
	bearing sin neg distance mul neg % this is y
	bearing cos distance mul neg% this is x
	}
	{
	bearing sin neg distance mul % this is y
	bearing cos distance mul % this is x
	}ifelse


}def



%--------------------------------------
/lat_lon2xy
%lat on stack
%lon on stack
%returns xy on stack ready for moveto
{
	%This routine is currently coded to do the azimuthal equidistant projection
	%However any subroutine that maps from (lat,lon) to (x,y) could be called here
	%Thus it is in principle just by changing the following call to
	%have mercator projection, or biconic, or whatever.
	%
	%While this is the way it was when the coding for az_proj started
	%and still is true for reading the .dat files (which are all
	%lat,lon pairs), in several places in az_proj.ps, shortcuts
	%have been taken which rely on properties of the azimuthal equidistant
	%projection, e.g. the terminator at sunrise/sunset, which is calculated
	%from 2 points which are on a straight line in this projection,
	%but which will be a curve in others. Presumably a do loop could
	%calculate the curve, but still some recoding is neccessary.
	%
	%Some other routines just use the (dist, bearing) -> (x,y)
	%transformation. This would have to be replaced if
	%another mapping was used.
	%
	%So other projections could still be used, but the code
	%is now reasonably locked into the azimuthal equidistant projection.
	%

	gc
	distance_bearing2xy
}def
%--------------------------------------
% Michael did this one.
% (I think) this procedure takes an array of points and plots (draws) them
% the array comes from /readline
%
% shorthand to extract elements from array
% eg 10 lon gets the longitude entry from the 10th element in the coord array

%/ini { coord 0 get exch get} def
%/lat { coord 1 get exch get} def
%/lon { coord 2 get exch get} def

/entry_ini { coord exch get 0 get} def
/entry_lat { coord exch get 1 get} def
/entry_lon { coord exch get 2 get} def

/crunch_path
{
	%(crunch_path: start \n) print
	% digest line here!
	% nothing on stack, all info in /entry_* ?

	% determine line color, line width etc as a function of line type.
	% Also print, to stdout, the wdb index of the line as it is processed.
	% This output is handy for finding where a particular line segment
	% (wdb_path) is on the surface of the earth (that is if you are
	% viewing the output) as the lines are not labelled in the .wdb files.
	% As well the incrementing of numbers on the screen gives some assurance
	% that your computer is not frozen.

% huh? maybe I moved the code for this comment, Joe Nov 96
% a comment without code, isn't that backwards
%	% if this is the first (wdb) path (ie map segment) and we haven't
%	% yet printed the grids, then do it now.



	0 entry_ini
	dup  /wdb_path exch def 	% 4 digit number that labels each line (= path)
					% 1.1.6 5 digit
	%(crunch_path: wdb_path \n) print_notice pstack
	1000 idiv 1 sub /feature_index exch def	% feature_index

	%/feature_index (crunch_path: feature_index \n)print_notice pstack pop
	
	feature_index 0 ge
	{
		feature_color feature_index get exec setrgbcolor
		feature_width feature_index get atom mul setlinewidth
	} if

	newpath 0 entry_lat 0 entry_lon lat_lon2xy moveto


	wdb_path_entry 1 gt

	% test if feature is turned on
	% we don't draw if any of these conditions are true
	% ie we don't draw if any of these features are turned off

	draw_coast_lines	not feature_index 1 add	coast_line	  eq and
	draw_country_borders   	not feature_index 1 add country_border	  eq and	or
	draw_political_states	not feature_index 1 add	political_states eq and	or
	%draw_us_states		not feature_index 1 add US_state 	  eq and	or
	draw_islands		not feature_index 1 add island		  eq and	or
	draw_lakes		not feature_index 1 add	lake 		  eq and	or
	draw_rivers		not feature_index 1 add river		  eq and	or
	%draw_australian_states	not feature_index 1 add	Australian_state  eq and	or
	draw_opposite_countries	not feature_index 1 add	opposite_countries eq and	or
	draw_USA_call_areas	not feature_index 1 add	USA_call_areas    eq and	or
	draw_county_borders	not feature_index 1 add	county_border     eq and	or
									 not and
	{
		%(valid point \n) print

		az_dict /debug known
		{
		debug
			{
			% are at first point in line
			% save current point etc, as after show, current point will be at the end of the string
			gsave
			/Helvetica findfont bearing_fontsize 4 mul scalefont setfont
			wdb_path temp_string cvs show
			grestore
			} if
		} if

		1 1 wdb_path_entry 1 sub
		{
			/ptr exch def
			ptr entry_ini Error_Flag ne
			{
				ptr entry_lat ptr entry_lon
				lat_lon2xy lineto
			}
			{
				%(extract_coord: bogus data at some line in wdb path - ) print_notice 0 entry_ini pstack
				(\n)print_notice
			}ifelse
		} for

		send_notices verbose and
		{
			%dup grid_string cvs print CR print
			feature_index 1 add
			dup coast_line eq        {(drawing coast line        ) print} if
			dup country_border eq    {(drawing country border    ) print} if
			dup political_states eq {(drawing political state   ) print} if
			%dup US_state eq          {(drawing US state          ) print} if
			dup island eq            {(drawing island            ) print} if
			dup lake eq              {(drawing lake              ) print} if
			dup river eq             {(drawing river             ) print} if
			%dup Australian_state eq  {(drawing Australian state  ) print} if
			dup opposite_countries eq  {(drawing opposite country  ) print} if
			dup USA_call_areas eq	 {(drawing USA call area     ) print} if
			dup county_border eq	 {(drawing county borders    ) print} if

			pop
			wdb_path grid_string cvs print CR print
			flush
		}if

		feature_index 0 ge
		{
			{ % loop through all valid feature types
				% (well those with positive indices anyhow)

				% a special case
				feature_index 1 add lake eq lake_fill and
				{	% it's a lake and it's being filled
					gsave	% save path of lake outline
					% feature_color feature_index get exec setrgbcolor
					fill
					/big_lake_found false def	%initialise
				 	big_lakes
					{	% array of big_lakes on stack
						wdb_path eq map_scale_deg 30 lt and
						{ % this wdb_path is one of the big_lakes
							% and the map scale is small
							/big_lake_found true def	%found a big_lake
							grestore 					%recall path
							lake_edge_color	setrgbcolor
							%feature_width feature_index get atom mul setlinewidth
							stroke
							% no other big lake will have this wdb_path
							% so don't bother checking further
							exit % to forall
						} if % it's a big lake, stroke the edge
					} forall % big_lakes

					big_lake_found not
					{
						%if this wasn't a big_lake have to do matching grestore
						grestore
					} if

				 exit	% to end of valid feature,
					% we've filled and stroked this lake
					% so bypass default feature handling at bottom of routine
				} if 	% a lake and are "filling"

				% another special case, islands in lakes
				feature_index 1 add island eq
				{
					% it's an island. Is it an island in a lake?
					island_in_lake	% array of numbers, which are islands in lakes
					{
						% array of islands in lakes is on stack
						wdb_path eq
						% test if path is an island in a lake
						{
							% the current wdb_path is an island in a lake
							% if drawn on a lake filled with say blue,
							% then the island will then have to be filled with white
							gsave
							white setrgbcolor % 0 setgray % fill with white
							fill
							grestore
							% feature_width feature_index get atom mul setlinewidth
							% stroke 	% deleted - handled below in default
							exit % there's only one, don't need to check other elements in array
						} if % this wdb_path is an island in a lake
					} forall % members of island_in_lakes
					%exit % have handled this island, bypass default method of plotting
					%commented out previous line or else islands WITHOUT lakes are not plotted
				} if % island

				%another special case of State borders
				feature_index 1 add political_states 	eq
				%feature_index 1 add US_state		eq	or
				%feature_index 1 add Australian_state	eq	or
				feature_index 1 add opposite_countries	eq	or
				feature_index 1 add USA_call_areas	eq	or
				{	% it's a state border (or call area)
					state_borders_dashed
					{
						% sample 1-3- patterns (my favorite for states JM)
						%[20 atom mul 20 atom mul 60 atom mul 20 atom mul ] 0 setdash	% big dashes
						%[ 5 atom mul  5 atom mul 15 atom mul  5 atom mul ] 0 setdash	% small dashes
						 [10 atom mul 10 atom mul 30 atom mul 10 atom mul ] 0 setdash % just right dashes
					} if
					% feature_width feature_index get atom mul setlinewidth
					stroke
					exit % bypass default handling
				} if % state border

				% default handling of normal features here
				stroke
				exit
			} loop % all types of features
		} if % valid feature (index ge 0)
	} if % line belongs to a feature to be drawn
[] 0 setdash % turn off dashes, just to be safe
%(crunch_path: end\n) print_notice pstack
az_dict /line_cnt line_cnt wdb_path_entry add put
} def

%--------------------------------------
/coord 2024 array def
/first_time true def
/Error_Flag -500 def	% none of the entries should be this
/wdb_path_entry 0 def

%/coord_size 1500 def
%/coord [ 0 1 2 { pop coord_size array } for ] def
%/first_time true def
%/Error_Flag -500 def	% none of the entries should be this
%/i 0 def

%%initialise
%/entry_id  0 def
%/entry_lat 0 def
%/entry_lon 0 def

/extract_coord
{
	% a string of the type (   5 46.283 -124.067) will be on the stack

	% for good hygeine, put a mark under this string
	% have to handle the controlD at the end of the file
	% which doesn't appear as a valid anything
	% also have to handle possible blank lines at the end of the file

	mark exch

	%(extract_coord: start \n) print_notice pstack

	% get first item,
	% if the first line of a wdb file it should be a 4 digit wdb descriptor (type integer).
	% 1.1.6 is 4 or 5 digits
	% check that first item is indeed an integer.
	% If it is greater than 1000 then crunch_path.
	% We can use 'wdb_path_entry' to indicate the number of entries in the arrays.
	% After we return from crunch_path we reset wdb_path_entry.
	% If the token differs from what we expect, we indicate with an illegal
	% number

	%/entry_id  Error_Flag def
	%/entry_lat Error_Flag def
	%/entry_lon Error_Flag def

	/entry [ Error_Flag dup dup ] def
	token
	{
		%(extract_coord: checking for integer \n) print_notice pstack
		dup type /integertype eq
		{
			%(extract_coord: integer found \n) print_notice pstack
			dup 1000 ge first_time not and
			{
				%(extract_coord: found n+1th wdb path descriptor \n) print_notice
				% get here if find wdb path descriptor (eg 1001)
				% and are not here for the first time (ie have extracted previous coords)
				% ie we are starting a 2nd or 3rd or nth wdb path
				dup 0 entry_ini ne % entry_ini[0] is from crunch_path
				{
					%(extract_coord: entry_ini != 0, found a new wdb path, crunch_path on previous path \n) print_notice pstack
					crunch_path /wdb_path_entry 0 def
					%(extract_coord: returned crunch_path on previous path \n) print_notice pstack
				}
				{
					%get here if two consecutive wdb_paths have same 4 digit number
					% (like a long path has been cut into two pieces)
					% the wdb files from v1.01 have been edited so this doesn't happen (Jul 96)
					%(extract_coord: mod'ing wdb_path label, ie remainder /1000 \n) print_notice pstack
	    				1000 mod
					%(extract_coord: after mod'ing wdb_path label \n) print_notice pstack
				} ifelse
			} if

			%/entry_id exch def
			% integer is either wdb path descriptor (int >= 1000)
			% or resolution of data (1..5)

			%(extract_coord: about to put integer into entry \n) print_notice pstack
			entry 0 3 -1 roll put

			%(extract_coord: coords data string \n) print_notice pstack
			% get rid of mark below coord string on stack
			exch cleartomark
			%(extract_coord: cleartomark \n) print_notice pstack


		}
		{
			% if are reading the controlD at the end of the file
			% then two entries, \004 and (), will be on stack
			% (entract_coord: bogus data \n) print_notice pstack
			cleartomark % chuck the number(s)
			% put obviously invalid data on stack for token routine below
			(-1 -1)
			%(entract_coord: invalid data entered \n) print_notice pstack

		} ifelse	% we expect the first number in a path to be a 4 digit int

		%(extract_coord: wdb point coords \n) print_notice pstack
		token
		{
			dup type /realtype eq
			{
				%entry_lat exch def
				entry 1 3 -1 roll put
			}{
				pop	% we expect a real second!
			} ifelse

			token
			{
				dup type /realtype eq
				{
					%/entry_lon exch def
					entry 2 3 -1 roll put
				}{
					pop
				} ifelse	% we expect a real third!
			} if
		} if
	} if

	clear

	%coord 0 get wdb_path_entry entry_id  put
	%coord 1 get wdb_path_entry entry_lat put
	%coord 2 get wdb_path_entry entry_lon put

	coord wdb_path_entry entry put

	% To avoid a limitcheck error,
	% we limit the path complexity to less than 1500 points.
	% n.b. this 1500 point limit includes all paths
	% (including current clippath)
	% The wdb files v1.01 and on have been edited so that
	% the wdb paths all have =< 1000 points (Jul 96)
	wdb_path_entry 1450 ge
	{
		%(extract_coord: about to crunch_path, for entry > 1450 \n) print_notice pstack
		crunch_path
		/wdb_path_entry 0 def	% reset wdb_path_entry
		% ensure we restart at the previous point
		%/entry_id 0 ini def
		entry 0 0 entry_ini put coord 0 entry put

		%coord 0 get 0 entry_id	 put
		%coord 1 get 0 entry_lat put
		%coord 2 get 0 entry_lon put

	}if

	/wdb_path_entry wdb_path_entry 1 add def
	/first_time false def
	%(extract_coord: finish \n) print_notice pstack

} def


%--------------------------------------

%
% If we are using ghostscript or Display PS
% we can locate the script with an argument
% otherwise the script follows the programme as 'stdin'
%

/argno 0 def
/next_file
{
	userdict /ARGUMENTS known
	{
		userdict /ARGUMENTS get length 0 ne
	}
	{
		false
	} ifelse

	{
		% we have arguments
		{
			% loop until we have a good argument (or run out)
			userdict /ARGUMENTS get dup length
			argno le
			{	% check that we have any more arguments
				pop false exit
			}{
				argno get
				/argno argno 1 add def
				% If we know about ARGUMENTS (eg in gs),
				% and we have arguments, we use the first one
				% as a file name and attempt to open it
					dup dup status
				{
					4 { pop } repeat
					/data_file exch (r) file def
					(Processing file ) print_notice print_notice
					% write blank to obliterate data from previous line
					(              \n) print_notice
					true exit
				}{
					print  ( is not a valid filename. Cannot open. \n)
					print flush
					pop
					} ifelse
			} ifelse
		} loop
	}
	{
		az_dict /data_file known
		{
			false	% if we've been here before then it's the end (ie no more files)
		}{
			(\nAZ_PROJ Attention: \n) print_notice
			(No data file names passed to gs on command line \n) print_notice
			(If you're sending data by stdin, eg a command like \n) print_notice
			(C:gs>type big.ps | gs - \n) print_notice
			(then the map will be being drawn as you read this notice. \n) print_notice
			(and you have nothing to do - just wait \n) print_notice
			(\n) print_notice
			(Otherwise you most probably want to send an EOF \n) print_notice
			(Note: EOF depends on your operating system \n) print_notice
			(                     Unix   ctrl-D         \n) print_notice
			(                     VMS    ctrl-C         \n) print_notice
			(                     MSDOS  ctrl-Z, cr,    \n) print_notice
			(\n) print_notice
			(Stdin could also be the terminal (the keyboard). \n) print_notice
			(In this case you can (if you really want to) send your own data \n) print_notice
			(lines to gs by hand, and when you've finished looking at the map, \n) print_notice
			(you can exit by entering EOF on the keyboard. \n) print_notice
			(\n) print_notice
			/data_file (%stdin) (r) file def
			true
		} ifelse
	} ifelse
} def

%--------------------------------------
/grid_to_lat_lon
% 6 or 4 char grid locator string, eg FM18rx or FM19 is on stack

% v1.1beta13 Nov 98
% now automatically handles 2,4,6 char grid locator giving length of sides and corners
% a gridlocator is used elsewhere to determine
% a QTH, in which case the lat/lon at the center of the locator is needed
% a box, in which case the lower left lat/lon and length of the sides is needed
% returns
% lat/lon of the center,
% lat_start/lon_start for the bottom left corner
% lat_incr/lon_incr, increments for the length of the sides
% and bad_loc as globals.
% lat and lon are given for center of square, whether 2,4 or 6 char
{

	%(grid_to_lat_lon \n) print_notice
	%pstack
	/bad_loc false def
	/lat -90.0 def
	/lon -180.0 def

	dup
	length /loc_len exch def

% If we have more than 2 digits in the grid locator, then proceed

	loc_len 2 ge
	{
		%beacon_fields 2 get	% get grid_locator - old code
		% this is the grid locator, now passed on stack
		%(loc_len) loc_len pstack pop pop

		0 1 loc_len 1 sub
		{
			/position_counter exch def
			dup position_counter get % get the next digit
			{
				position_counter 0 eq % first is a letter longitude
				{
					32 or 97 sub	% convert to lower case & make 0 to 18
					dup 18 ge	% only 18 letters are allowed
					{
						/bad_loc true def
						pop exit
					} if
					% lat/lon are -90/-180 at this stage
					20 mul lon add /lon exch def
					loc_len 2 eq	% if only 2 digits in GL string
					{
						lon dup /lon_start exch def
						% centre the beacon in Grid
						10 add /lon exch def
						%set lon_incr
						/lon_incr 20 def
					} if
					exit
				} if

				position_counter 1 eq	% 2nd letter, latitude
				{

					32 or 97 sub	% convert to lower case & make 0 to 18
					dup 18 ge	% only 18 allowed
					{
						/bad_loc true def
						pop exit
					} if
					10 mul lat add /lat exch def
					loc_len 2 eq	% center in GS if only 2 letters given
					{
						lat dup /lat_start exch def
						5 add /lat def
						/lat_incr 10 def
					} if
					exit
				} if

				%if 2 char locator, then all values will have been set
				%else only the lat/lon at the bottom left corner of the square have been set

				position_counter 2 eq			% number longitude GS
				{
					48 sub		% make 0-9
					dup 10 ge	% only 0 to 9 allowed
					{
						/bad_loc true def
						pop exit
					} if
					2 mul lon add /lon exch def
					loc_len 4 eq
					{
						lon dup
						/lon_start exch def
						1 add /lon exch def
						/lon_incr 2 def
					} if
					exit
				} if

				position_counter 3 eq
				{
					48 sub
					dup 10 ge
					{
						/bad_loc true def
						pop exit
					} if
					1 mul lat add /lat exch def
					loc_len 4 eq
					{
						lat dup
						/lat_start exch def
						0.5 add /lat exch def
						/lat_incr 1 def
					} if
					exit
				} if

				position_counter 4 eq
				{
					32 or 97 sub	% convert to lower case & make 0 to 23
					dup 24 ge
					{
						/bad_loc true def
						pop exit
					} if
					%5 60 div mul /lon exch lon add def
					2 24 div mul lon add /lon exch def
					lon dup
					/lon_start exch def
					1 24 div add /lon exch def
					/lon_incr 2 24 div def
					exit
				} if

				position_counter 5 eq
				{
					32 or 97 sub	% convert to lower case & make 0 to 23
					dup 24 ge
					{
			  			/bad_loc true def
						pop exit
					} if
					1 24 div dup /lat_incr exch def
					mul lat add /lat_start exch def
					lat_start lat_incr 2 div add /lat exch def
					exit
				} if %position_counter
			} loop  %get
		} for pop
	}{
		/bad_loc false def
	} ifelse % ge
az_dict /loc_len undef

%(grid_to_lat_lon: lat lon \n) print_notice lat_start lon_start lat lon lat_incr lon_incr pstack pop pop pop pop pop pop
} def %grid_to_lat_lon

%--------------------------------------

/location_to_lat_lon

%v1.1.3
%
%suggested by Bob McCormick W1QA. 
%takes location info off the stack in any form at all and creates globals lat, lon
%(don't have a routine for lat/lon -> grid_locator yet).
%
%Previously each datatype accepted only one form of lat/lon info, 
%and no others. Similar datatypes had their own format for lat/lon.
%The reason for one format or another was usually 
%because I was looking for better ways of handling the lat/lon info.
%
%this will be used for transmitter type data (beacons, commercial transmitters, mountains...)
%it won't be used for *.wdb files as there's no need for grid_locator info for each wdb point
%
%the string on the stack will have come from a search (:) instruction and will be 
%(first_piece_of_info) (second_piece_of_info:other_pieces_of_info:...)
% this could be
% (lat.decimal) (lon.decimal:...)
% (lat.decimal, lon.decimal) (....:....) 
% (gridsquare) (....:...)
% where lat, lon can be signed reals or with NSEW suffixes (eg 36.10N)
%
%
%If is gridsquare, will also leave bad_loc (from grid_to_lat_lon) as global.
%gridsquare lc is converted to UC
% the string on the stack from a *.dat line will look like
% (FN05lw) (:... )
% or
% (35.943) (:-79.0261:...)
% or
% (35.943,-79.0261) (:...)
%
% if being fed lat_QTH lon_QTH will look like
% (FN05lw) 
% (35.943) (-79.03)
{
	%(location_to_lat_lon: entering \n) print_notice pstack
	%will need to determine if we were sent a lat,lon or a gridsquare
	az_dict /temp_lat undef
	az_dict /temp_lon undef
	az_dict /lat undef
	az_dict /lon undef
	az_dict /grid_locator undef

	% is the string a "lat,lon" pair (ie ',' separated, rather than "lat:lon" ie ':' separated)
	(,) search
		{
		%(location_to_lat_lon: entering comma separated lat,lon \n) print_notice pstack
		exch pop % the (,)
		/temp_lat exch def	% will check for validity later
		/temp_lon exch def
		%temp_lon temp_lat (location_to_lat_lon: exiting comma separated lat,lon \n) print_notice pstack pop pop
		} % if string is really a lat,lon pair that is comma separated
		{
		isnum 
			{
			%(location_to_lat_lon: string is lat \n) print_notice pstack
			/temp_lat exch def
			% extract the lon
			% next field has lon
			(:) search
				{
				%(location_to_lat_lon: extracting lat:lon \n) print_notice pstack
				exch pop %the (:)
				/temp_lon exch def
				} 
				{
				% if lat_QTH, lon_QTH are fed to this routine, 
				% then lon_QTH will not be terminated by a ':'
				/temp_lon exch def
				}ifelse
			} % string is a number, presumably a lat, next string is (lon:...)
			{
			% input was grid_locator
			%(location_to_lat_lon: location is gridsquare \n) print_notice pstack
			toupper dup /grid_locator exch def
			grid_to_lat_lon
			%on top of stack is gridsquare with lon below it.
			%lon is ignored, pop it

			%changed my mind, if gridsquare, there is no lon below it
			%(:) search 
			%	{
			%	%location came from a *.dat line with (:) separator
			%	(location_to_lat_lon: gridsquare, : found \n) print_notice pstack
			%	exch pop pop % the lon and the (:)
			%	} 
			%	{
			%	%location came from a lat lon pair from the QTH with no (:) separator
			%	(location_to_lat_lon: gridsquare, : not found \n) print_notice pstack
			%	pop % just the lon
			%	}ifelse
			%lon lat grid_locator (location_to_lat_lon: found gridsquare \n) print pstack pop pop pop
			} ifelse % string is a string (and not a number), presumably a gridsquare   
		} ifelse % string is either a lat or a gridsquare

	%(location_to_lat_lon: half way \n) print pstack
	%was it lat/lon or a gridsquare?
	%if it was a gridsquare, conversion to lat,lon was handled just above
	az_dict /temp_lat known 
		{
		temp_lat islat 
			{ 
			/lat exch def 
			}
			{
			pop
			/bad_loc true def
			} ifelse

		temp_lon islon 
			{ 
			/lon exch def 
			}
			{
			pop
			/bad_loc true def
			} ifelse
		%calculate grid_locator
		%(location_to_lat_lon: calculating grid_locator \n) print_notice pstack
		lat_lon_to_grid_locator
		} if % input was lat,lon
	%really don't have much error checking 
	/bad_loc false def
	%(location_to_lat_lon: exiting \n) print_notice pstack
}def %location_to_lat_lon

%--------------------------------------

/draw_transmitter	%v1.04
% on stack - a string of the type (WMAR:FM19qi:100000:-1:Baltimore,MD,US;comment field)
%being
%Call/Ch (channel only if TV station)
%Gridlocator
%Power (watts)
%beam_heading (deg of main lobe), -1 if omni (NULL string is trapped as -1)
%	- Note if multiple lobes then use comma separated list eg :45,225:
%arbitary string (suggest City,State/Province,Country), currently ignored by AZ_PROJ
%coment field (for your own use, ignored by AZ_PROJ)
%
%as well the global "freq_string" and "transmitter_type" are defined on entry
{
	%(draw_transmitter: start \n) print_notice pstack
	(:) search
	{
		exch pop % the (:)
		%(draw_transmitter: callsign_string \n) print_notice pstack
		/callsign_string exch def % callsign
		%(draw_transmitter: callsign_string \n) print_notice callsign_string pstack pop
		(:) search
		{
			exch pop % the (:)
			%(draw_transmitter: location info \n) print_notice pstack
			location_to_lat_lon
			%(draw_transmitter: returning from location info \n) print_notice pstack
			%transmitter_dict code added in v1.1.2
			%lat lon (draw_transmitter: location \n) print_notice pstack pop pop
			%look to see if we've already drawn a symbol, call, power, freq etc at this spot
			%if so, will redraw symbol (doesn't cost us a lot) 
			%but will draw call/freq underneath the last string
			%grid_locator (draw_transmitter: have we already seen stations at grid_locator? \n) print_notice pstack pop
			%transmitter_dict has grid_locator number_stations_at_this_grid_locator pairs (a hash table)
			%see Blue book "Dictionaries and Local Variables" p 128 
			%for having a local dict
			transmitter_dict begin
				transmitter_dict grid_locator known 
					{
					%grid_locator known
					%grid_locator (draw_transmitter: grid_locator known \n) print_notice pstack pop
					transmitter_dict grid_locator get /number_stations_at_this_grid_locator exch def
					%transmitter_dict length number_stations_at_this_grid_locator grid_locator (draw_transmitter: transmitter_dict grid_locator known, number entries in transmitter_dict \n) print_notice pstack pop pop pop
					number_stations_at_this_grid_locator 1 add /number_stations_at_this_grid_locator exch def
					%number_stations_at_this_grid_locator grid_locator (draw_transmitter: transmitter_dict number_stations_at_this_grid_locator \n) print_notice pstack pop pop
					transmitter_dict grid_locator number_stations_at_this_grid_locator put 
					%transmitter_dict length number_stations_at_this_grid_locator grid_locator (draw_transmitter: after update transmitter_dict grid_locator known, number entries in transmitter_dict \n) print_notice pstack pop pop pop
					%not sure how to get number_stations_at_this_grid_locator into the outside world, I'll just push it on the stack
					number_stations_at_this_grid_locator
					}
					{
					%grid_locator unknown
					%grid_locator (draw_transmitter: grid_locator unknown \n) print_notice pstack pop
					transmitter_dict grid_locator 1 put 
					%transmitter_dict length grid_locator (draw_transmitter: transmitter_dict grid_locator unknown, number entries in transmitter_dict \n) print_notice pstack pop pop
					transmitter_dict grid_locator get /number_stations_at_this_grid_locator exch def
					%not sure how to get number_stations_at_this_grid_locator into the outside world, I'll just push it on the stack
					number_stations_at_this_grid_locator
					} ifelse %grid_locator known
			end % transmitter_dict
			%recover number_stations_at_this_grid_locator
			/number_stations_at_this_grid_locator exch def
			%number_stations_at_this_grid_locator grid_locator (draw_transmitter: transmitter_dict on exit\n) print_notice pstack pop pop

			(:) search	%look for power
			{
				exch pop % the (:)
				%(draw_transmitter: transmitter_power \n) print_notice pstack
				%can be null string
				dup () eq {pop 0}{cvr} ifelse
				/transmitter_power exch def % transmitter_power
				%(draw_transmitter: transmitter_power \n) print_notice transmitter_power pstack pop
			} if % string_2 found

			(:) search	%look for string_3, beam_heading
			{
				exch pop % swap top two on stack and pop the "%"
				%(draw_transmitter: beam_heading \n) print_notice pstack
				% on stack - something like (45,225,300)(:)(Baltimore,MD,US;comment field)
				% on stack - something like -top (45,225,300)(Baltimore,MD,US;comment field) bottom-

				%beam_heading can be null string
				dup () eq {pop (-1)} if

				%may be comma separated list
				%parse comma separated list into array of ints
				[	% symbol for start of array
				% have to push symbol below comma separated list
				exch
				% on stack - something like -top (45,225,300) [ (Baltimore,MD,US;comment field) bottom-

				{
					(,) search
					{
					%(draw_transmitter: comma separated list \n) print_notice pstack

					% on stack - top (45) (,) (225,300) [ (Baltimore,MD,US;comment field) bottom
					% pop comma
					exch pop % the ","
					cvi
					% on stack - top 45 (225,300) [ (Baltimore,MD,US;comment field) bottom
					%push the integer down the stack
					exch
					% on stack - top (225,300) 45 [ (Baltimore,MD,US;comment field) bottom
					} % if comma
					{
					%(draw_transmitter: no commas \n) print_notice pstack
					% on stack - (300) 225 45 [ (Baltimore,MD,US;comment field)
					cvi
					% on stack - 300 225 45 [ (Baltimore,MD,US;comment field)
					%(draw_transmitter: no commas, end \n) print_notice pstack
					exit 	% no commas found
					} ifelse
				} loop % through list of comma separated beam_headings
				] /beam_heading_array exch def %finish making array
				% on stack - (Baltimore,MD,US;comment field)

				%(draw_transmitter: beam_heading \n) print_notice beam_heading_array pstack pop
			} if % string_3 found

			(:) search	%look for string_4, location/comments to be printed
			{
				%(draw_transmitter: location_string \n) print_notice pstack
				/location_string exch def %
				%(draw_transmitter: location_string \n) print_notice location_string pstack pop
				pop % (:)
				pop % comments or ()
				%(draw_transmitter: location_string \n) print_notice location_string pstack pop
			} if % string_4 found

			%grid_locator grid_to_lat_lon	%lat and lon, now global variables determined above
			bad_loc not
			{
				{
					% valid location
					%(draw_transmitter: valid location \n) print_notice transmitter_type pstack pop
					transmitter_type (BC) eq
					{
						%(draw_transmitter: BC \n) print_notice pstack
						az_dict /freq_offset_type known
						{
							%(draw_transmitter: freq is modified +,-,N,Z,H or V \n) print_notice pstack
							% all modifiers
							BC_color setrgbcolor
							% some modifiers have special colors
							freq_offset_type (+) eq {BC_color_plus_offset setrgbcolor} if
							freq_offset_type (-) eq {BC_color_minus_offset setrgbcolor} if
							freq_offset_type (Z) eq {BC_color_Z_offset setrgbcolor} if
							freq_offset_type (N) eq {BC_color_N_offset setrgbcolor} if
							freq_offset_type (H) eq {BC_color_H_polarisation setrgbcolor} if
							freq_offset_type (V) eq {BC_color_V_polarisation setrgbcolor} if
						} % freq_offset_type known
						{
							%(draw_transmitter: freq is not modified \n) print_notice pstack
							BC_color setrgbcolor
						} ifelse % no freq_offset

						transmitter_power BC_low_power_limit ge
						{
							%(draw_transmitter: power OK \n) print_notice pstack
							% draw if BC station has enough power


							%Code dependant on BC_symbol_type
							BC_symbol_type (circles) eq
							        {
							        /draw_BC_symbol {draw_nested_circles}   def
							        %if symbol is circles, one string should be above and the other below (or to left and right)
							        /BC_station_string_1_location           (above2)        def
							        /BC_station_string_2_location           (below2)        def
							        } if
							
							BC_symbol_type (tower) eq
							        {
							        /draw_BC_symbol {draw_tower}            def
							        %if symbol is tower, then both strings should be below (or to left and right)
							        %v1.1.2 - strings from multiple stations at same location would overwrite
							        %now az_proj keeps state and maintains a hash table of locations that have had
							        %symbols plotted there (currently only TV stations)
							        %subsequent symbols are plotted at 1.75 the font height below each other
							        %in this case you will want the strings to left and right.
							        %
							        %/BC_station_string_1_location          (below) def
							        %/BC_station_string_2_location          (below2) def
							        /BC_station_string_1_location           (left)  def
							        /BC_station_string_2_location           (right) def
							        /tower_size     {atom 10 mul}   def     %width of tower base in atoms, 
							                                                %tower sections are 2x base units high
							        } if
							
							
							BC_symbol_type (generic_dot) eq
							        {
							        /draw_BC_symbol
							                {
							                /BC_station_string_1_location (above2) def 
									/BC_station_string_2_location (below2) def
							                BC_color setrgbcolor %set fill color for symbol 
							                /generic_dot_radius BC_font_size 0.5 mul def                    %set radius of dot, 
							                                                        %here half the height of the text       
							                                                        %ie diam of dot=height of the text
							                draw_generic_dot
							                }def
							        } if
							
							BC_symbol_type (generic_square) eq
							        {
							        /draw_BC_symbol
							                {
							                %/BC_station_string_1_location          (above2)        def
							                /BC_station_string_1_location           (above2)        def
							                /BC_station_string_2_location           (below2)        def
							                BC_color setrgbcolor                    %set fill color for symbol 
							                /generic_square_halfside BC_font_size 0.5 mul def                       %set radius of dot, 
							                                                        %here half the height of the text       
							                                                        %ie diam of dot=height of the text
							                draw_generic_square
							                }def
							        } if
							
							BC_symbol_type (generic_triangle) eq
							        {
							        /draw_BC_symbol
							                {
							                %/BC_station_string_1_location          (above2)        def
							                /BC_station_string_1_location           (above2)        def
							                /BC_station_string_2_location           (below2)        def
							                BC_color setrgbcolor                    %set fill color for symbol 
							                /generic_triangle_halfside BC_font_size 0.5 mul def                     %set radius of dot, 
							                                                        %here half the height of the text       
							                                                        %ie diam of dot=height of the text
							                draw_generic_triangle
							                }def
							        } if

							draw_BC_symbol	
						} 
						{
							%if have multiple stations at this location
							%have to decrement number_stations_at_this_grid_locator 
							%(draw_transmitter: power not OK \n) print_notice number_stations_at_this_grid_locator pstack pop
							number_stations_at_this_grid_locator 1 ge
								{
								/number_stations_at_this_grid_locator number_stations_at_this_grid_locator 1 sub def
								transmitter_dict grid_locator 
								number_stations_at_this_grid_locator put 
								transmitter_dict grid_locator get 
								%(draw_transmitter: decrementing \n) print_notice pstack pop
								} if 
						}ifelse
						exit
					} if
					%(transmitter_type: valid location \n) print_notice transmitter_type pstack pop

					transmitter_type (beacon) eq
					{
						%(draw_transmitter: transmitter_type beacon \n) print_notice pstack
						beacon_color setrgbcolor
						draw_beacon_symbol %defined in az_ini.ps
						exit
					} if

					transmitter_type (repeater) eq
					{
						%(transmitter_type: repeater \n) print_notice pstack
						repeater_color setrgbcolor
						draw_repeater_symbol
						exit
					} if

					transmitter_type (rover) eq
					{
						%(transmitter_type: rover \n) print_notice pstack
						draw_rover_symbol
						exit
					} if

					(transmitter_type: error unidentified transmitter type \n) print_notice transmitter_type pstack pop exit
				} loop

			} % bad location
			{
				pop	exit 	%bad location
			} ifelse % valid location


			% print strings

			%(draw_transmitter: transmitter_type \n) print_notice transmitter_type pstack pop

			transmitter_type (BC) eq
			transmitter_power BC_low_power_limit ge % has enough power
			and
			{
				%(draw_transmitter: BC callsign_string \n) print_notice callsign_string pstack pop
	    			BC_font findfont BC_font_size scalefont setfont
			       	BC_font_color setrgbcolor

				% list of locations of strings, 
				% if set for left/right, above/below etc
				% originally these were locations relative to the symbol
				% eg up 0.5, right 1.0 
				% however when multiple TV stations are at one location
				% the original code overwrote previous strings in the same 
				% location, obliterating them
				% The first attempt to change this overwriting, 
				% placed the below string by multiplying the y offset by 2,3..n
				% This worked fine, as it was only 1 level offset from the symbol
				% and the subsequent strings were separated by 1 level.
				% If the string was at below2, then the strings were spaced 
				% 2 apart.
				% The recoding here separates below2 into an offset which stays constant
				% and a shift that gets multiplied for each time another station is at that location.
				% The ypos of below2 then will be yoffset+(shift * 1,2..n)
				% 
				% it would be nice if this routine moved the strings up 
				% and down to follow changes of size of the generic dot 
				% etc. Only the dot has a preset size.
				% The tower and nested rings are dependant on power
				% and size is calculated on the fly.
					
				BC_station_string_1_location (noprint) eq not
				{
					%incase have spelling error etc
					/string_x	-0.5 def
					/string_y	-0.5 def

					% The units here in x are stringwidth, y is fontheight
					/BC_station_string_1_x_center 	-0.5 def
					/BC_station_string_1_x_right 	0.6 def

					/BC_station_string_1_y_center 	-0.5 def
					/BC_station_string_1_y_up 	1.2 def
					/BC_station_string_1_y_shift  	1.2 def


					BC_station_string_1_location (left) search 
						{
						pop pop pop
						/string_x BC_station_string_1_x_center 
						BC_station_string_1_x_right sub def 	
						} 
						{
						pop
						}ifelse 

					BC_station_string_1_location (right) search 
						{
						pop pop pop
						/string_x BC_station_string_1_x_center 
						BC_station_string_1_x_right add add def	
						} 
						{
						pop
						}ifelse

					BC_station_string_1_location (above) search
						{
						pop pop pop
						/string_y BC_station_string_1_y_center
						BC_station_string_1_y_up 
						number_stations_at_this_grid_locator mul add def
						} 
						{
						pop
						}ifelse

					BC_station_string_1_location (above2) search 
						{
						pop pop pop
						/string_y string_y
						BC_station_string_1_y_shift add def
						} 
						{
						pop
						}ifelse

					BC_station_string_1_location (below) search 
						{
						pop pop pop
						/string_y BC_station_string_1_y_center
						BC_station_string_1_y_up 
						number_stations_at_this_grid_locator mul sub def
						}
						{
						pop
						}ifelse


					BC_station_string_1_location (below2) search 
						{
						pop pop pop
						/string_y string_y
						BC_station_string_1_y_shift sub def
						} 
						{
						pop
						}ifelse

					lat lon lat_lon2xy moveto % symbol's location
					%(draw_transmitter: callsign_string \n)print_notice callsign_string pstack pop flush
					%(draw_transmitter: string_x string_y \n)print_notice string_x string_y pstack pop pop flush
					callsign_string
	    				dup stringwidth pop string_x mul
	    				%BC_font_size number_stations_at_this_grid_locator mul 1.75 mul string_y mul rmoveto
	    				%BC_font_size 1.75 mul string_y mul rmoveto
	    				BC_font_size 1 mul string_y mul rmoveto
					show
				} if % !noprint

				BC_station_string_2_location (noprint) eq not
				{
					%incase have spelling error etc
					/string_x	-0.5 def
					/string_y	-0.5 def

					% The units here in x are stringwidth, y is fontheight
					/BC_station_string_2_x_center 	-0.5 def
					/BC_station_string_2_x_right 	0.6 def

					/BC_station_string_2_y_center 	-0.5 def
					/BC_station_string_2_y_up 	1.2 def
					/BC_station_string_2_y_shift  	1.2 def


					BC_station_string_2_location (left) search 
						{
						pop pop pop
						/string_x BC_station_string_2_x_center 
						BC_station_string_2_x_right sub def 	
						} 
						{
						pop
						}ifelse 

					BC_station_string_2_location (right) search 
						{
						pop pop pop
						/string_x BC_station_string_2_x_center 
						BC_station_string_2_x_right add add def	
						} 
						{
						pop
						}ifelse

					BC_station_string_2_location (above) search
						{
						pop pop pop
						/string_y BC_station_string_2_y_center
						BC_station_string_2_y_up 
						number_stations_at_this_grid_locator mul add def
						} 
						{
						pop
						}ifelse

					BC_station_string_2_location (above2) search 
						{
						pop pop pop
						/string_y string_y
						BC_station_string_2_y_shift add def
						} 
						{
						pop
						}ifelse

					BC_station_string_2_location (below) search 
						{
						pop pop pop
						/string_y BC_station_string_2_y_center
						BC_station_string_2_y_up 
						number_stations_at_this_grid_locator mul sub def
						}
						{
						pop
						}ifelse


					BC_station_string_2_location (below2) search 
						{
						pop pop pop
						/string_y string_y
						BC_station_string_2_y_shift sub def
						} 
						{
						pop
						}ifelse

					lat lon lat_lon2xy moveto % symbol's location
					%(draw_transmitter: string_2 callsign_string \n)print_notice callsign_string pstack pop flush
					%(draw_transmitter: string_x string_y \n)print_notice string_x string_y pstack pop pop flush
					callsign_string
	    				dup stringwidth pop string_x mul
	    				%BC_font_size number_stations_at_this_grid_locator mul 1.75 mul string_y mul rmoveto
	    				%BC_font_size 1.75 mul string_y mul rmoveto
	    				BC_font_size 1 mul string_y mul rmoveto
					show
				} if % !noprint
			} if % (BC)

			(beacon) transmitter_type eq
			{
				%(draw_transmitter: beacon strings \n) print_notice pstack
	    			beacon_font findfont beacon_font_size scalefont setfont
				%beacon_font_color (beacon: beacon_font_color \n) print_notice pstack pop pop pop
				beacon_font_color setrgbcolor
				%(draw_transmitter: beacon strings 2\n) print_notice pstack

				beacon_station_string_1_location (noprint) eq not
				{
					{
						beacon_station_string_1_location (left) 	eq {/string_x -1.1 def 	/string_y  -0.5 def exit} if
						beacon_station_string_1_location (right) 	eq {/string_x  0.1 def 	/string_y  -0.5 def exit} if
						beacon_station_string_1_location (above) 	eq {/string_x -0.5 def 	/string_y   4 def exit} if
						beacon_station_string_1_location (above2) 	eq {/string_x -0.5 def 	/string_y   6 def exit} if
						beacon_station_string_1_location (below) 	eq {/string_x -0.5 def 	/string_y  -7 def exit} if
						beacon_station_string_1_location (below2) 	eq {/string_x -0.5 def 	/string_y -10 def exit} if
						beacon_station_string_1_location (above-left)	eq {/string_x -1.1 def 	/string_y   4 def exit} if
						beacon_station_string_1_location (above-right)	eq {/string_x  0.1 def 	/string_y   4 def exit} if
						beacon_station_string_1_location (below-left)	eq {/string_x -1.1 def 	/string_y  -7 def exit} if
						beacon_station_string_1_location (below-right)	eq {/string_x  0.1 def 	/string_y  -7 def exit} if
						%if have spelling error etc, will not exit
						/string_x	0.0 def
						/string_y	0.0 def
						exit
					} loop

					lat lon lat_lon2xy moveto % symbol's location
					callsign_string
					%pstack
		    			dup stringwidth pop string_x mul
     					nested_circle_size string_y mul 
					%rmoveto
      					beacon_font_size number_stations_at_this_grid_locator 1 sub mul 1.0 mul add rmoveto
					show
				} if % !noprint

				beacon_station_string_2_location (noprint) eq not
				{
					{
						beacon_station_string_2_location (left) 	eq {/string_x -1.1 def 	/string_y  -0.5 def exit} if
						beacon_station_string_2_location (right) 	eq {/string_x  0.1 def 	/string_y  -0.5 def exit} if
						beacon_station_string_2_location (above) 	eq {/string_x -0.5 def 	/string_y   4 def exit} if
						beacon_station_string_2_location (above2) 	eq {/string_x -0.5 def 	/string_y   6 def exit} if
						beacon_station_string_2_location (below) 	eq {/string_x -0.5 def 	/string_y  -7 def exit} if
						beacon_station_string_2_location (below2) 	eq {/string_x -0.5 def 	/string_y -10 def exit} if
						beacon_station_string_2_location (above-left)	eq {/string_x -1.1 def 	/string_y   4 def exit} if
						beacon_station_string_2_location (above-right)	eq {/string_x  0.1 def 	/string_y   4 def exit} if
						beacon_station_string_2_location (below-left)	eq {/string_x -1.1 def 	/string_y  -7 def exit} if
						beacon_station_string_2_location (below-right)	eq {/string_x  0.1 def 	/string_y  -7 def exit} if
						%if have spelling error etc, will not exit
						/string_x	0.0 def
						/string_y	0.0 def
						exit
					} loop

					lat lon lat_lon2xy moveto	% beacon's location
					freq_string
		    			dup stringwidth pop string_x mul
     					nested_circle_size string_y mul 
					%rmoveto
      					beacon_font_size number_stations_at_this_grid_locator 1 sub mul 
						%string_y signof mul mul 
						1.0 mul 
						add 
					rmoveto
					show
				} if % !noprint
			} if % (beacon)



			(repeater) transmitter_type eq
			{
				%(draw_transmitter: repeater strings \n) print_notice pstack
	    			repeater_font findfont repeater_font_size scalefont setfont
				repeater_font_color setrgbcolor
				repeater_station_string_1_location (noprint) eq not
				{
					{
						repeater_station_string_1_location (left) 		eq {/string_x -1.3 def 	/string_y  -0.6 def exit} if
						repeater_station_string_1_location (right) 		eq {/string_x  0.2 def 	/string_y  -0.6 def exit} if
						repeater_station_string_1_location (above) 		eq {/string_x -0.5 def 	/string_y   4 def exit} if
						repeater_station_string_1_location (above2) 		eq {/string_x -0.5 def 	/string_y   6 def exit} if
						repeater_station_string_1_location (below) 		eq {/string_x -0.5 def 	/string_y  -7 def exit} if
						repeater_station_string_1_location (below2) 		eq {/string_x -0.5 def 	/string_y -10 def exit} if
						repeater_station_string_1_location (above-left)		eq {/string_x -1.3 def 	/string_y   4 def exit} if
						repeater_station_string_1_location (above-right)	eq {/string_x  0.2 def 	/string_y   4 def exit} if
						repeater_station_string_1_location (below-left)		eq {/string_x -1.3 def 	/string_y  -7 def exit} if
						repeater_station_string_1_location (below-right)	eq {/string_x  0.2 def 	/string_y  -7 def exit} if
						%if have spelling error etc, will not exit
						/string_x	0.0 def
						/string_y	0.0 def
						exit
					} loop

					lat lon lat_lon2xy moveto % symbol's location
					callsign_string
		    			dup stringwidth pop string_x mul
     					repeater_symbol_size string_y mul 
      					repeater_font_size number_stations_at_this_grid_locator 1 sub mul 
						1.0 mul 
						add 
					rmoveto
					show
				} if % !noprint

				repeater_station_string_2_location (noprint) eq not
				{
					{
						repeater_station_string_2_location (left) 		eq {/string_x -1.3 def 	/string_y  -0.6 def exit} if
						repeater_station_string_2_location (right) 		eq {/string_x  0.2 def 	/string_y  -0.6 def exit} if
						repeater_station_string_2_location (above) 		eq {/string_x -0.5 def 	/string_y   4 def exit} if
						repeater_station_string_2_location (above2) 		eq {/string_x -0.5 def 	/string_y   6 def exit} if
						repeater_station_string_2_location (below) 		eq {/string_x -0.5 def 	/string_y  -7 def exit} if
						repeater_station_string_2_location (below2) 		eq {/string_x -0.5 def 	/string_y -10 def exit} if
						repeater_station_string_2_location (above-left)		eq {/string_x -1.3 def 	/string_y   4 def exit} if
						repeater_station_string_2_location (above-right)	eq {/string_x  0.2 def 	/string_y   4 def exit} if
						repeater_station_string_2_location (below-left)		eq {/string_x -1.3 def 	/string_y  -7 def exit} if
						repeater_station_string_2_location (below-right)	eq {/string_x  0.2 def 	/string_y  -7 def exit} if
						%if have spelling error etc, will not exit
						/string_x	0.0 def
						/string_y	0.0 def
						exit
					} loop

					lat lon lat_lon2xy moveto	% repeater's location
					freq_string
		    			dup stringwidth pop string_x mul
     					repeater_symbol_size string_y mul 
					%rmoveto
      					repeater_font_size number_stations_at_this_grid_locator 1 sub mul 
						1.0 mul 
						add 
					rmoveto
					show
				} if % !noprint
			} if % (repeater)

			(rover) transmitter_type eq
			{
				%(draw_transmitter: rover strings \n) print_notice pstack
		    		rover_font findfont rover_font_size scalefont setfont
				rover_font_color setrgbcolor

				rover_station_string_1_location (noprint) eq not
				{
					{
						rover_station_string_1_location (left) 		eq {/string_x -1.4 def 	/string_y  -0.5 def exit} if
						rover_station_string_1_location (right) 	eq {/string_x  0.2 def 	/string_y  -0.5 def exit} if
						rover_station_string_1_location (above) 	eq {/string_x -0.5 def 	/string_y   4   def exit} if
						rover_station_string_1_location (above2) 	eq {/string_x -0.5 def 	/string_y   6   def exit} if
						rover_station_string_1_location (below) 	eq {/string_x -0.5 def 	/string_y  -7   def exit} if
						rover_station_string_1_location (below2) 	eq {/string_x -0.5 def 	/string_y -10   def exit} if
						rover_station_string_1_location (above-left)	eq {/string_x -1.4 def 	/string_y   4   def exit} if
						rover_station_string_1_location (above-right)	eq {/string_x  0.2 def 	/string_y   4   def exit} if
						rover_station_string_1_location (below-left)	eq {/string_x -1.4 def 	/string_y  -7   def exit} if
						rover_station_string_1_location (below-right)	eq {/string_x  0.2 def 	/string_y  -7   def exit} if
						%if have spelling error etc, will not exit
						/string_x	0.0 def
						/string_y	0.0 def
						exit
					} loop

					lat lon lat_lon2xy moveto % symbol's location
					callsign_string
		    			dup stringwidth pop string_x mul
     					rover_symbol_size string_y mul 
      					rover_font_size number_stations_at_this_grid_locator 1 sub mul 
						1.0 mul 
						add 
					rmoveto
					show
				} if % !noprint

				rover_station_string_2_location (noprint) eq not
				{
					{
						rover_station_string_2_location (left) 		eq {/string_x -1.4 def 	/string_y  -0.5 def exit} if
						rover_station_string_2_location (right) 	eq {/string_x  0.2 def 	/string_y  -0.5 def exit} if
						rover_station_string_2_location (above) 	eq {/string_x -0.5 def 	/string_y   4   def exit} if
						rover_station_string_2_location (above2) 	eq {/string_x -0.5 def 	/string_y   6   def exit} if
						rover_station_string_2_location (below) 	eq {/string_x -0.5 def 	/string_y  -7   def exit} if
						rover_station_string_2_location (below2) 	eq {/string_x -0.5 def 	/string_y -10   def exit} if
						rover_station_string_2_location (above-left)	eq {/string_x -1.4 def 	/string_y   4   def exit} if
						rover_station_string_2_location (above-right)	eq {/string_x  0.2 def 	/string_y   4   def exit} if
						rover_station_string_2_location (below-left)	eq {/string_x -1.4 def 	/string_y  -7   def exit} if
						rover_station_string_2_location (below-right)	eq {/string_x  0.2 def 	/string_y  -7   def exit} if
						%if have spelling error etc, will not exit
						/string_x	0.0 def
						/string_y	0.0 def
						exit
					} loop

					lat lon lat_lon2xy moveto	% rover's location
					location_string
		    			dup stringwidth pop string_x mul
	     				rover_symbol_size string_y mul 
      					rover_font_size number_stations_at_this_grid_locator 1 sub mul 
						1.0 mul 
						add 
					rmoveto
					show
				} if % !noprint
			} if % (rover)
		} % if found (:) infront of grid_locator
		{
		} ifelse % grid_locator
	} % search found a `(:)
	{
		% no string_1, print error message
		(error: no string_1 in data line \n) print_notice
	} ifelse % search for :

az_dict /string_1 undef
az_dict /string_2 undef
%(draw_transmitter: end \n) print_notice pstack

}def

%--------------------------------------
%Instruction to execute to specially label a beacon
/beacon_special_1
	{
	%draw cross hairs around beacon, might be good for a B/W printer
	beacon_color setrgbcolor
	coarse_gl_width  master_line_width_factor mul setlinewidth
	newpath  25 atom mul  25 atom mul moveto  25 atom mul  25 atom mul rlineto stroke
	newpath -25 atom mul -25 atom mul moveto -25 atom mul -25 atom mul rlineto stroke
	newpath -25 atom mul  25 atom mul moveto -25 atom mul  25 atom mul rlineto stroke
	newpath  25 atom mul -25 atom mul moveto  25 atom mul -25 atom mul rlineto stroke
	} def
/beacon_special_2
	{
	% make beacon red
	%/beacon_color {red} def
	beacon_color setrgbcolor
	} def
%/beacon_special {beacon_special_2} def	% now in az_ini.ps

% defaults
/mark_beacon {} def
%/beacon_color /black cvx def


%--------------------------------------


/beacon_strings	  [ 10 string 10 string 10 string ] def

/beacon_fields
[
	()		% frequency in MHz (as a string)
	()		% callsign
	()		% grid locator (4 or 6 digit)
	20.0 		% power
	30.0		% direction
	0
] def


/extract_beacon
{
% defaults in case we don't find them in data
	beacon_fields 3 1.0 put	% power W
	beacon_fields 4 -1 put  % beam_heading, -1 => omni, 60=> 60deg true
	beacon_fields 5 0 put	% write label on top of symbol (1 = below)

% The fields in the beacon text are
% beacon:144.020  NV3Z  FM18rx  15  90  1
% beacon:		<-- indicates a beacon line
% 144.020		<-- frequency
% NV3Z			<-- call sign  (n.b. do not use '/' in call or parser will freak out)
% FM18rx		<-- Grid locator. If only 2 or 4 digits supplied, the beacon is
% 					placed in the middle of the grid
% 15			<-- Power of beacon. Different symbols for  < 5W, < 50W, > 50W
% 90			<-- direction of beacon. If not supplied, or 360 given, omni assumed
% 1			<-- label under symbol; 0 or no value - printed on top.
	{
	0 1 2
		{
		/string_counter exch def
		token	 % get first two strings
			{% n.b. this is intolerant of "/" in string
			beacon_strings string_counter get cvs beacon_fields string_counter 3 -1 roll put
			}
			{
			exit
			}ifelse
		} for

	3 1 5
		{
		/string_counter exch def
		token
			{% power and direction are reals
			dup type /realtype eq 1 index type /integertype eq or
				{
				cvr beacon_fields string_counter 3 -1 roll put
				}
				{
				pop		% ignore if string
				} ifelse
			}
			{
			exit
			} ifelse
		} for
	exit
	} loop

% Only print beacon if we have at least a location
%string_counter 2 ge beacons_on and
	string_counter 2 ge
		{
		Print_beacon
		} if

az_dict /string_counter undef
} def

%--------------------------------------
/correct_azimuth
%requires globals: beam_heading, lat, lon
{
% Have to fiddle with beam_heading, since while at QTH, Nth is up,
% on any other part of the map, Nth is not up (see CAVEAT in bea_w3ep.dat).
%
%	beam_heading = ( beam_heading \n) print_notice
%	lat = lon = (lat lon \n) print_notice
% beacon is at lat/lon.
% Find the location of a test point a small distance away (say 1 deg)
% from the beacon on a bearing of "beam_heading".
	lon beam_heading sin add /lon_test exch def
	lat beam_heading cos add /lat_test exch def
%	lat_test = lon_test = (lat_test lon_test \n) print_notice
% Find location of test point in x,y space
	lat_test lon_test lat_lon2xy /x_test exch def /y_test exch def
%	x_test = y_test = (x_test y_test \n) print_notice
% do same for beacon
	lat lon lat_lon2xy /x_beacon exch def /y_beacon exch def
%	x_beacon = y_beacon = (x_beacon y_beacon \n) print_notice
% find bearing on page (xy space) to test point from beacon
	y_test y_beacon sub x_test x_beacon sub atan /test_beam_heading exch def
%	test_beam_heading = (test_beam_heading \n) print_notice
	test_beam_heading /beam_heading exch def
	beam_heading 360 gt {beam_heading 360 sub /beam_heading exch def} if
	beam_heading 0 lt {beam_heading 360 add /beam_heading exch def} if
%	beam_heading = (beam_heading \n) print_notice

} def % correct_azimuth
%--------------------------------------

/Print_beacon
{
	/bad_loc false def

	/lat -90.0 def
	/lon -180.0 def
	/nested_circle_size atom 10 mul  def
	beacon_color setrgbcolor

	/loc_len beacon_fields 2 get length def

	beacon_fields 2 get
	%(test) pstack pop

	location_to_lat_lon
	%grid_to_lat_lon

	bad_loc not false
	%beacons_plotted
	bands_plotted
		{
		dup (*) eq exch beacon_fields 0 get cvi eq or { not } if
		%beacon_fields 0 get cvi eq { not } if
		} forall and

	{
	/beam_heading beacon_fields 4 get def

	%(\n :) print_notice
	%beam_heading = (beam_heading, \n) print_notice

	beam_heading -1 eq
		{
		/beam_half_width 179.999 def
		/beam_heading 360 exch def
		}
		{
		% assume a 70deg beam width
		/beam_half_width 35 def
		} ifelse

	correct_azimuth

	/pwr beacon_fields 3 get dup
	0.0 le { pop 0 }{ 2 mul log cvi } ifelse  def

	gsave
		3 atom mul setlinewidth
		%0 setgray
		lat lon lat_lon2xy translate
		gsave
			mark_beacon
		grestore
		gsave

			% old code
			beam_half_width 35 ne { /nested_circle_size nested_circle_size 1.5 div def } if
			450 beam_heading sub rotate newpath
			% new code
			%beam_heading -1 eq { /nested_circle_size nested_circle_size 1.5 div def } if
			%90 rotate newpath % N for compass is -90 in cartesian
			0 0 nested_circle_size 0 360 arc
			gsave
				%1.0 setgray
		 		6 atom mul setlinewidth stroke
			grestore stroke

			beam_half_width 35 eq
				{
				0 0 nested_circle_size 315 45 arc
				0 0 nested_circle_size 3 div 65 295 arcn closepath ffill
				}
				{
				0 0 nested_circle_size 360 beam_half_width sub beam_half_width arc
				0 0 nested_circle_size 3 div beam_half_width 360 beam_half_width sub arcn closepath ffill
				} ifelse

			0 0 nested_circle_size 0 360 arc stroke

			pwr 0 gt
				{
				0 0 nested_circle_size 7 mul 3 div 360 beam_half_width sub beam_half_width arc
				0 0 nested_circle_size 5 mul 3 div beam_half_width 360 beam_half_width sub arcn
				closepath ffill

				pwr 1 gt
					{
					0 0 nested_circle_size 12 mul 3 div 360 beam_half_width sub beam_half_width arc
					0 0 nested_circle_size 10 mul 3 div beam_half_width 360 beam_half_width sub arcn
					closepath ffill
					} if
				} if
		grestore
		beacon_font findfont beacon_font_size scalefont setfont
		beacon_color setrgbcolor
		beacon_fields 5 get  0 eq
			{
			0 pwr 1 add 4 mul 1 add 3 div nested_circle_size mul moveto
			}
			{
			0 pwr 1 add 4 mul 1 add 3 div nested_circle_size mul
			beacon_font_size add neg moveto
			} ifelse
		currentpoint
		beacon_fields 0 get dup stringwidth pop 2 div neg 0 rmoveto halo
		moveto 0 beacon_font_size
		beacon_fields 5 get 0 ne { neg } if rmoveto
		beacon_fields 1 get dup stringwidth pop 2 div neg 0 rmoveto halo
	grestore
	}
	{
	} ifelse
} def

%--------------------------------------
% this was originally copied from beacon_special

%Instruction to execute to specially label a repeater
/repeater_special_1
	{
	%draw cross hairs around repeater, might be good for a B/W printer
	repeater_color setrgbcolor
	5 atom mul setlinewidth
	newpath  25 atom mul  25 atom mul moveto  25 atom mul  25 atom mul rlineto stroke
	newpath -25 atom mul -25 atom mul moveto -25 atom mul -25 atom mul rlineto stroke
	newpath -25 atom mul  25 atom mul moveto -25 atom mul  25 atom mul rlineto stroke
	newpath  25 atom mul -25 atom mul moveto  25 atom mul -25 atom mul rlineto stroke
	} def
/repeater_special_2
	{
	% make repeater red
	%/repeater_color {red} def
	repeater_color setrgbcolor
	} def
%/repeater_special {repeater_special_2} def	% now in az_ini.ps

% defaults
/mark_repeater {} def
%/repeater_color /black cvx def




%--------------------------------------
% this was originally copied from extract_beacon
/repeater_strings	  [ 10 string 10 string 10 string ] def

/repeater_fields
[
	()		% frequency in MHz with a trailing +/- for offset (string)
	()		% callsign
	()		% grid locator (4 or 6 digit)
	20.0 		% power
	30.0		% direction
	0
] def


/extract_repeater
{
	repeater_fields 3 1.0 put 		% defaults in case we don't
	repeater_fields 4 -1 put   % find them in data
	repeater_fields 5 0 put				%   write label on top of symbol

% The fields in the repeater text are
%	repeater:147.21+  NA3T  FM119gh 15  90  1
% repeater:	<-- indicates a repeater line
% 147.21+		<-- frequency, with + (or -) offset
% NA3T			<-- call sign  (n.b. do not use '/' in call or parser will freak out)
% FM19gh		<-- Grid locator. If only 2 or 4 digits supplied, the repeater is
%					placed in the middle of the grid
% 15			<-- Power of repeater. Different symbols for  < 5W, < 50W, > 50W
% 90			<-- direction of repeater. If not supplied, or 360 given, omni assumed
% 1			<-- label under symbol; 0 or no value - printed on top.
	{
	0 1 2
		{
		/string_counter exch def
		token		% get first two strings
			{			% n.b. this is intolerant of "/" in string
			repeater_strings string_counter get cvs repeater_fields string_counter 3 -1 roll put
			}
			{
			exit
			} ifelse
		} for

	3 1 5
		{
		/string_counter exch def
		token
			{		% power and direction are reals
			dup type /realtype eq 1 index type /integertype eq or
				{
				cvr repeater_fields string_counter 3 -1 roll put
				}
				{
				pop		% ignore if string
				} ifelse
			}
			{
			exit
			} ifelse
		} for
	exit
	} loop

% Only print repeater if we have at least a location
%string_counter 2 ge repeaters_on and
	string_counter 2 ge
		{
		Print_repeater
		} if

az_dict /string_counter undef
} def


%--------------------------------------


%Repeater stuff
/repeater_special {beacon_special} def
/mark_repeater {} def
%/repeater_font_size	{ atom 15 mul } def
%/repeater_symbol_size 	{atom 10 mul}  def

/Print_repeater
	{
	/bad_loc false def
	/lat -90.0 def
	/lon -180.0 def
	repeater_color setrgbcolor

% If we have more than 2 digits in the grid locator, then proceed
	/loc_len repeater_fields 2 get length def
	loc_len 2 ge
		{
		repeater_fields 2 get
		location_to_lat_lon
		%grid_to_lat_lon
		}
		{
		/bad_loc false def
		} ifelse

	bad_loc not false
	%repeaters_plotted
	bands_plotted
		{
		dup 
		repeater_fields 0 get
		% have string which is freq with +/- at end
		% Can't convert to int in same way as for beacon (cvi)
		% threfore look for numbers before decimal point
		(.) search
			{
			%roll the MHz down the stack
			3 1 roll
			pop pop % pop the (.) and kHz+/- string
			cvi eq 
			exch (*) eq or 
			{not} if
			}
			{
			%pstack
			pop	% bad freq
			} ifelse
		} forall and

		{
		/beam_heading repeater_fields 4 get def
		beam_heading -1 eq
			{
			/beam_half_width 179.999 def
			/beam_heading 360 exch def
			}
			{
			/beam_half_width 35 def
			} ifelse

		correct_azimuth

		/pwr repeater_fields 3 get dup
		0.0 le { pop 0 }{ 2 mul log cvi } ifelse  def

	gsave
		3 atom mul setlinewidth
		%0 setgray
		lat lon lat_lon2xy translate
		gsave
		mark_repeater
	grestore
	gsave

		beam_half_width 35 ne { /repeater_symbol_size repeater_symbol_size 1.5 div def } if
		450 beam_heading sub rotate newpath
		0 0 repeater_symbol_size 0 360 arc
		gsave
		%1.0 setgray
		6 atom mul setlinewidth stroke
		grestore stroke

		beam_half_width 35 eq
			{
				0 0 repeater_symbol_size 315 45 arc
				0 0 repeater_symbol_size 3 div 65 295 arcn closepath ffill
			}{
				0 0 repeater_symbol_size 360 beam_half_width sub beam_half_width arc
				0 0 repeater_symbol_size 3 div beam_half_width 360 beam_half_width sub arcn closepath ffill
			} ifelse

		0 0 repeater_symbol_size 0 360 arc stroke

		pwr 0 gt
			{
			0 0 repeater_symbol_size 7 mul 3 div 360 beam_half_width sub beam_half_width arc
			0 0 repeater_symbol_size 5 mul 3 div beam_half_width 360 beam_half_width sub arcn
			closepath ffill

			pwr 1 gt
				{
				0 0 repeater_symbol_size 12 mul 3 div 360 beam_half_width sub beam_half_width arc
				0 0 repeater_symbol_size 10 mul 3 div beam_half_width 360 beam_half_width sub arcn
				closepath ffill
				} if
			} if
		grestore
		repeater_font findfont repeater_font_size scalefont setfont
		%repeater_color setrgbcolor
		repeater_fields 5 get  0 eq
		{
			0 pwr 1 add 4 mul 1 add 3 div repeater_symbol_size mul moveto
		}
		{
			0 pwr 1 add 4 mul 1 add 3 div repeater_symbol_size mul
			repeater_font_size add neg moveto
		} ifelse
		currentpoint
		repeater_fields 0 get dup stringwidth pop 2 div neg 0 rmoveto halo
		moveto 0 repeater_font_size
		repeater_fields 5 get 0 ne { neg } if rmoveto
		repeater_fields 1 get dup stringwidth pop 2 div neg 0 rmoveto halo
		grestore

	}
	{
	} ifelse

az_dict /loc_len undef
az_dict /beam_heading undef
az_dict /beam_half_width undef

} def


%--------------------------------------
%/draw_worked_grid_square_old
%{
%	%grid square locator 4 char string (eg FM19) on stack
%	grid_to_lat_lon
%	% grid is a 2deg by 1deg rectangle
%	% the lat/lon returned is the center of the square
%	/lat lat 0.5 sub def
%	/lon lon 1.0 sub def
%	% the lat/lon returned is the bottom left corner
%
%
%
%	% 1 atom mul setlinewidth
%	worked_grid_square_color setrgbcolor
%	newpath
%
%	% sweep along edges of grids in increments of 1/10th
%	% of edge length (to make grid edges curved).
%
%	%adjust lat lon to bottom left corner of grid square
%
%	lat	lon lat_lon2xy moveto
%
%	0 1 10
%		{
%		/temp exch def
%		lat	lon 2 temp mul 10 div add	lat_lon2xy lineto
%		} for % sweep along bottom edge
%
%	0 1 10
%		{
%		/temp exch def
%		lat 1 temp mul 10 div add	lon 2 add	lat_lon2xy lineto
%		} for % sweep up eastern edge
%
%	10 -1 0
%		{
%		/temp exch def
%		lat 1 add	lon 2 temp mul 10 div add lat_lon2xy lineto
%		} for % sweep along top edge
%
%	10 -1 0
%		{
%		/temp exch def
%		lat 1 temp mul 10 div add	lon lat_lon2xy lineto
%		} for % sweep down western edge
%	closepath
%	fill
%az_dict /temp undef
%}def %draw_worked_grid_square_old
%
%--------------------------------------
/toupper
%takes an arbitary length string on stack
%converts [a-z] -> [A-Z]
%leaves others untouched
%returns to stack
%
{

%(toupper \n) print_notice pstack

dup
/arbitrary_string exch def
length /arbitrary_string_length exch def
%(arbitrary_string_length \n) print_notice
%arbitrary_string_length pstack pop

0 1 arbitrary_string_length 1 sub
	{
	/arbitrary_string_index exch def

	%(arbitrary_string_index \n) print_notice
	%arbitrary_string_index pstack pop


	arbitrary_string arbitrary_string_index get /arbitrary_string_char exch def% get next char
	%(toupper, char found \n) print_notice
	%arbitrary_string_char pstack pop
	arbitrary_string_char dup dup 97 ge exch 122 le and	% [a-z] ?
		{
		%(toupper before \n) print_notice
		%arbitrary_string_char pstack pop
		32 sub /arbitrary_string_char exch def
		%(toupper after \n) print_notice
		%arbitrary_string_char pstack pop
		}
		{
		pop
		}ifelse % islower
	arbitrary_string arbitrary_string_index arbitrary_string_char put
	} for
%(toupper end \n) print_notice
arbitrary_string % leave arbitrary_string on stack
%pstack
az_dict /arbitrary_string undef
}def %toupper

%--------------------------------------
/draw_grid_box_path
%makes path for a 2/4/6 char grid square (eg FM19)
%requires globals lat_start, lon_start, lat_incr, lon_incr
%on return, you must either stroke or fill the path yourself
{
	%(draw_grid_box_path: create box path \n) print_notice pstack flush
	% find path of box
	newpath

	% sweep along edges of grids in increments of 1/10th
	% of edge length (to make grid edges curved).

	lat_start lon_start lat_lon2xy moveto

	0 1 10
		{
		/temp exch def
		lat_start
		lon_start lon_incr temp mul 10 div add
		lat_lon2xy lineto
		} for % sweep along bottom edge

	0 1 10
		{
		/temp exch def
		lat_start lat_incr temp mul 10 div add
		lon_start lon_incr add
		lat_lon2xy lineto
		} for % sweep up eastern edge

	10 -1 0
		{
		/temp exch def
		lat_start lat_incr add
		lon_start lon_incr temp mul 10 div add
		lat_lon2xy lineto
		} for % sweep along top edge

	10 -1 0
		{
		/temp exch def
		lat_start lat_incr temp mul 10 div add
		lon_start
		lat_lon2xy lineto
		} for % sweep down western edge
	closepath
	%(draw_grid_box_path: box path created \n) print_notice pstack flush

}def %draw_grid_box_path
%--------------------------------------
/set_grid_box_color
% uses data_modifier to set color of grid_box
% called by draw_grid_box, draw_qso
%hmm Mar 00, I think this has to be called before draw_grid_box
% a default color will have been set
{
	%(set_grid_box_color: start data_modifier \n) print_notice data_modifier pstack pop
	% if modifier is (red),(green), (blue) or none then color fill grid square
	% else put in stripes

	% set color
	az_dict /data_modifier known
	{
		{
			data_modifier (red) eq
			{
				%(draw_grid_box: red \n) print_notice pstack
				grid-red_color setrgbcolor exit
			} if
			data_modifier (green) eq {grid-green_color setrgbcolor exit} if
			data_modifier (blue) eq {grid-blue_color setrgbcolor exit} if
			%(draw_grid_box: outlined boxes, default to black \n) print_notice  
			% all other cases eg (lon), (lat), (left), (right) 
			% - these will be lines rather than color fills
			data_modifier (lon) eq {black setrgbcolor exit}if
			data_modifier (lat) eq {black setrgbcolor exit}if
			data_modifier (left) eq {black setrgbcolor exit}if
			data_modifier (right) eq {black setrgbcolor exit}if
			data_modifier (vert) eq {black setrgbcolor exit}if
			data_modifier (horz) eq {black setrgbcolor exit}if
			data_modifier (*) eq {black setrgbcolor exit}if
			data_modifier (1) eq {black setrgbcolor exit}if
			data_modifier (2) eq {black setrgbcolor exit}if
			data_modifier (3) eq {black setrgbcolor exit}if
			data_modifier (4) eq {black setrgbcolor exit}if
			data_modifier (5) eq {black setrgbcolor exit}if
			data_modifier (6) eq {black setrgbcolor exit}if
			data_modifier (7) eq {black setrgbcolor exit}if
			data_modifier (8) eq {black setrgbcolor exit}if
			data_modifier (9) eq {black setrgbcolor exit}if
			data_modifier (density) eq
			data_modifier (etopo5) eq or
				{
				%(set_grid_box_color: legend_quantity \n) print_notice legend_quantity pstack pop
				%set colors according to legend_quantity
				%after comparing to values in legend_table (which came from the legend: line in a .dat file)
				legend_quantity cvr /legend_quantity exch def
				%legend_quantity 1 le { 0.85 0.85 0.85 setrgbcolor exit} if
				%legend_quantity 2 le { 0.85 0.85 1.0 setrgbcolor exit} if
				%legend_quantity 4 le { 0.8 1.0 1.0 setrgbcolor exit} if
				%legend_quantity 8 le { 0.8 1.0 0.8 setrgbcolor exit} if
				%legend_quantity 16 le { 0.6 1.0 0.6 setrgbcolor exit} if
				%legend_quantity 32 le { 0.5 1.0 0.5 setrgbcolor exit} if
				%legend_quantity 64 le { 1.0 1.0 0.25 setrgbcolor exit} if
				%legend_quantity 128 le { 1.0 0.5 0.5 setrgbcolor exit} if
				%grey
				legend_quantity legend_array 0 get le { 0.85 0.85 0.85 setrgbcolor exit} if					
				%steel blue
				%legend_quantity legend_array 1 get le { 0.85 0.85 1.0 setrgbcolor exit} if
				%OK with X-ghostscript, grey with xv and hard to differentiate from color 0
				%legend_quantity legend_array 1 get le { 0.75 0.75 1.0 setrgbcolor exit} if
				%dark blue
				%legend_quantity legend_array 1 get le { 0.5 0.5 1.0 setrgbcolor exit} if
				legend_quantity legend_array 1 get le { 0.66 0.66 1.0 setrgbcolor exit} if
				%real blue (also dark)
				%legend_quantity legend_array 1 get le { 0.0 0.0 1.0 setrgbcolor exit} if

				%sky blue
				%legend_quantity legend_array 2 get le { 0.8 1.0 1.0 setrgbcolor exit} if
				%cyan
				legend_quantity legend_array 2 get le { 0.0 1.0 1.0 setrgbcolor exit} if

				%medium green
				%legend_quantity legend_array 3 get le { 0.7 1.0 0.7 setrgbcolor exit} if
				%another green
				legend_quantity legend_array 3 get le { 0.5 1.0 0.5 setrgbcolor exit} if
				%real green
				legend_quantity legend_array 3 get le { 0.0 1.0 0.0 setrgbcolor exit} if

				%looks green on 8 bit card
				%legend_quantity legend_array 4 get le { 0.5 1.0 0.5 setrgbcolor exit} if
				%light green
				%legend_quantity legend_array 4 get le { 0.75 1.0 0.5 setrgbcolor exit} if
				%green yellow
				%legend_quantity legend_array 4 get le { 0.9 1.0 0.5 setrgbcolor exit} if
				%yellowy green
				legend_quantity legend_array 4 get le { 0.8 1.0 0.5 setrgbcolor exit} if

				% yellow
				%legend_quantity legend_array 5 get le { 1.0 1.0 0.25 setrgbcolor exit} if
				legend_quantity legend_array 5 get le { 1.0 1.0 0.0 setrgbcolor exit} if

				%allmost red
				%legend_quantity legend_array 6 get le { 1.0 0.5 0.5 setrgbcolor exit} if
				%light red - OK (dropping blue down to zero has no effect on 8 bit card)
				%legend_quantity legend_array 6 get le { 1.0 0.75 0.5 setrgbcolor exit} if
				%yellow
				%legend_quantity legend_array 6 get le { 1.0 0.9 0.0 setrgbcolor exit} if
				legend_quantity legend_array 6 get le { 1.0 0.8 0.0 setrgbcolor exit} if
				red setrgbcolor	exit
				}if
			%(set_grid_box_color: unknown data_modifier, default color substituted, no grid boxes \n) print_notice data_modifier pstack pop flush exit
		} loop % over all possible data_modifiers
	} if % data_modifier known
} def % set_grid_box_color

%--------------------------------------
/draw_grid_box
%called by /draw_worked_grid_square, /draw_qso, /draw_legend
%uses globals lat lon (bottom left of grid_square)
%lat_start, lon_start
%lat_incr, lon_incr - ie size of box  (usually 1x2 deg;  when drawing sumbols for propagation modes, sides are 1/2)
%data_modifier, determines how area is filled

{
	%az_dict /data_modifier known {(draw_grid_box: data_modifier \n) print_notice data_modifier pstack pop} if
	coarse_gl_width master_line_width_factor mul setlinewidth

	gsave	% there's a clip just below here
		% if you don't gsave/grestore,
		% you'll never be able to draw outside the clip path again

	draw_grid_box_path
	% now have a path, if colors then fill else clip
	az_dict /data_modifier known
	{
		data_modifier (red) eq		%leave a "TRUE" on the stack (ie fill grid box) if (red), (green), (blue) or no data_modifier
		data_modifier (green) eq or
		data_modifier (blue) eq or
		data_modifier (density) eq or
		data_modifier (etopo5) eq or
	}
	{
		false	%data_modifier is false, therefore no color info known
	} ifelse % leaves boolean on stack
	az_dict /data_modifier known not or 		% default (no modifier)
	{
		%if it's a color fill (from immediately above) or default (== color fill) then fill
		%(draw_grid_box: fill \n) print_notice
		fill
		%stroke
	}
	{
		%else clip and then use some routine which covers the page with a pattern
		%(draw_grid_box: clip \n) print_notice
		clip
	} ifelse

	az_dict /data_modifier known
	{
		% have to figure spacing of stripes which are used to mark grid squares
		% would like something about constant in page units
		% however all calcs are done in lat/lon degrees.
		% grid squares change shape as the lat increases, away from the equator
		% So need fudge factors for lat and for scale
		% At the equator, about 10 stripes are needed for a 2 deg wide box, at a scale of 200km/cm
		% Use a cos type function to decrease the spacing.
		% So that the spacing doesn't blow up at the poles, add another fudge factor
		%
		%(draw_grid_box: map_scale_deg \n) print_notice map_scale_deg pstack pop
		25 map_scale_deg div /scale_factor exch def
		%(draw_grid_box: scale_factor \n) print_notice scale_factor pstack pop
		/lat_factor {lat cos 0.1 add} def



		data_modifier (lon) eq
		{
			%vertical stripes
			%(draw_grid_box: vertical stripes \n) print_notice
			%0 0.28 2.2 % 0.28 deg steps (5 steps per width)
			0 0.25 lat_factor div scale_factor div 2.2 % 0.28 deg steps (5 steps per width)
			{
				newpath
				lon add /temp_lon exch def
				lat temp_lon lat_lon2xy moveto
				lat lat_incr add temp_lon lat_lon2xy lineto
				stroke
			} for % all vertical stripes
		}if % data_modifier v

		data_modifier (lat) eq
		{
			%horizontal stripes
			%(draw_grid_box: horizontal stripes \n) print_notice
			0 0.25 scale_factor div 1.1 % 0.2 deg steps (5 steps per height)
			{
				newpath
				lat add /temp_lat exch def
				temp_lat lon lat_lon2xy moveto
				temp_lat lon lon_incr add lat_lon2xy lineto
				stroke
			} for % all vertical stripes
		}if % data_modifier v

		data_modifier (left) eq
		{
			%left leaning stripes
			%(draw_grid_box: left leaning stripes \n) print_notice
			-1.0 0.4 scale_factor div lat_factor div 4.2 % 0.4 deg steps
			{
				newpath
				lon add /temp_lon exch def
				lat temp_lon lat_lon2xy moveto
				lat lat_incr add temp_lon lat_incr sub lat_lon2xy lineto
				stroke
			} for % all left stripes
		}if % data_modifier left

		data_modifier (right) eq
		{
			%right leaning stripes
			%(draw_grid_box: right leaning stripes \n) print_notice
			-1.0 0.4 scale_factor div lat_factor div 4.2 % 0.4 deg steps
			{
				newpath
				lon add /temp_lon exch def
				lat temp_lon lat_lon2xy moveto
				lat lat_incr add temp_lon lat_incr add lat_lon2xy lineto
				stroke
			} for % all / stripes
		}if % data_modifier /

		data_modifier (vert) eq
		{
			%vertical stripes
			%(draw_grid_box: vertical stripes \n) print_notice
			-1000 atom mul 7.5 atom mul 1000 atom mul % 10 atom mul steps across page space
			{
				newpath
				dup 2000 atom mul moveto
				   -2000 atom mul lineto
				stroke
			} for % all / stripes
		}if % data_modifier /

		data_modifier (horz) eq
		{
			%horz stripes
			(draw_grid_box: vertical stripes \n) print_notice
			-2000 atom mul 7.5 atom mul 2000 atom mul % 10 atom mul steps across page space
			{
				newpath
				dup 1000 atom mul exch moveto
				   -1000 atom mul exch lineto
				stroke
			} for % all / stripes
		}if % data_modifier /



		data_modifier (*) eq
		{
			%draw radial lines from QTH
			%(draw_grid_box: radial lines from qth 0\n) print_notice
			%
			% as the grid box get further from the qth, the radial lines
			% will have to be drawn at a closer angular spacing.
			% find distance (and bearing which will be used below)
			lat lon gc /bearing exch def deg2km /distance exch def
			% handle v.small distances (if target is in next grid square, approx 100km)
			distance 100 lt {100 /distance exch def} if
			%(draw_grid_box: distance \n) print_notice distance pstack pop flush
			%
			% draw radial lines over 360 deg, starting in some direction.
			% to prevent this starting line appearing as one straight line through
			% a string of adjacent grid squares, choose some direction to start which
			% isn't the same for all grid squares.
			% How about the direction at the center of each square?
			% (Note that a bearing of 0 deg in compass space (Nth) is 90 deg in postscript space)
			%
			% chose interval for radial lines that gives integer number of radial lines

			%1 1250 distance div div 360 mul round % number of evenly spaced intervals in circle
			distance 1500 div 360 mul round % number (int) of evenly spaced intervals in circle
			360 div 1 exch div /deg_interval exch def
			bearing deg_interval 359 bearing add % deg steps % blue book p103
			{
				gsave rotate
				% the size of the paper in the short direction is +/- 1000 atom mul
				% chose the radius to get to the diagonals at least
				% if center is offset, then could be more
				0 0 moveto 2000 atom mul 0 lineto
				stroke
				grestore
			} for % all * stripes
		}if % data_modifier *

		data_modifier (1) eq
		{
			%draw radial lines from QTH-1
			%(draw_grid_box/mod1: radial lines from grid_locator_qth_1 to lat lon \n) print_notice grid_locator_qth_1 lat lon pstack pop pop pop
			save
			% will change the qth for the center of the projection for this routine.
			% this is needed for /gc, which looks for the globals
			% lon_QTH, lat_QTH to determine the center of the projection
			% Will use this new center to calculate distance to a worked grid.
			% will draw radial lines from this qth
			% on exit will restore old qth for center of projection

			%save old lat lon which come from the location of the worked grid
			lat lon
			%find lat lon for new center (qth-1)
			grid_locator_qth_1 grid_to_lat_lon % the globals lat lon are now for the new qth
			% make new center for projection
			%(draw_grid_box: new center for projection from qth 1 \n) print_notice lat lon pstack pop pop flush
			lat /lat_QTH exch def
			lon /lon_QTH exch def
			%restore lat lon
			/lon exch def
			/lat exch def
			%(draw_grid_box: worked grid lat lon \n) print_notice lat lon pstack pop pop flush

			% now drawn radial lines from qth-1 through worked grid
			% as the grid box get further from the qth, the radial lines
			% will have to be drawn at a closer angular spacing.
			% find distance
			%lat lon pstack gc pop pstack deg2km /distance exch def
			lat lon gc pop deg2km /distance exch def
			% handle v.small distances (target is in next grid square, approx 100km)
			distance 100 lt {100 /distance exch def} if
			%(draw_grid_box: distance \n) print_notice distance pstack pop flush
			%radial spacing is 1 deg intervals at 2500km
			0 2500 distance div 359 % deg steps % blue book p103
			{
				gsave rotate
				0 0 moveto 1000 atom mul 0 lineto
				stroke
				grestore
			} for % all * stripes
			restore % original center of map
		}if % data_modifier *
	}if % data_modifier known


	grestore
	az_dict /temp undef
	az_dict /distance undef

}def

%--------------------------------------
/draw_worked_grid_square
% called by parse_data_type
% added for v1.02
% version 1.02, allows modes (Es, F2, EME, Ms, Au)
% v1.04 allows modifiers of the grid parameter
% v1.1beta6 allows grid-color, colors from a table based on an extra field in the line
% v1.1beta13 changed to allow grid squares of 2,4,6 char
% (although expect only 4 char to be used for this type of data)
%
% On stack a string like (Au:FN31:comments, eg call sign)
% lat/lon are globals
{
	%(draw_worked_grid_square: start data_modifier \n) print_notice pstack az_dict /data_modifier known {data_modifier pstack pop} if
	% Note: there are 5 propagation modes here
	% I've divided the grid square into 4, hence 2 modes
	% have to double up.
	% Since Aurora occurs in the E layer, I've put both
	% into the same quadrant of the grid_square.
	% Au is a wavy line on the RHS of the Es box.

	%(draw_worked_grid_square: \n) print_notice lat lon lat_start lon_start lat_incr lon_incr pstack pop pop pop pop pop pop


	% initialise a few things

	/F2_color	/lightblue cvx	def	%F2 contact, bottom right corner of gridsquare
	/Es_color	/lightred  cvx	def	%Es contact, top right corner of gridsquare
	/Ms_color	/black	   cvx	def	%Meteor contact, top left corner of gridbox
	/EME_color	/black	   cvx	def	%moonbounce contact
	/Au_color	/red	   cvx	def	%aurora, bottom left corner of gridsquare
	/TEP_color	/blue	   cvx	def	%TransEquatorial

	worked_grid_square_color setrgbcolor
	/propagation_mode_ok	false	def

	(:) search
		{
		exch pop %the `:'

		%(draw_worked_grid_square: grid_map_mode : \n) print_notice pstack
		/grid_map_mode exch def % can be null
		grid_map_mode toupper /grid_map_mode exch def


		(:) search
			{
			exch pop % (:)
			%(draw_worked_grid_square: grid_square : \n) print_notice pstack
			%extract the grid_square
			/grid_square exch def % can be 2,4 or 6char
			%display comment string
			%(draw_worked_grid_square: comment is )print_notice print_notice (            \n) print_notice
			} if % (:)
		} if % search found a `:'

	%grid_mode on top of stack
	%(draw_worked_grid_square: grid_mode \n) print_notice pstack

	%Handle grid mode


	grid_map_mode () eq
		{
		%no propagation mode in entry, use default
		%this is the standard way of plotting qra_densities
		%will draw a box of appropriate size for 2,4 or 6 char gridlocator

		%(draw_worked_grid_square: no propagation mode entered \n) print_notice pstack

		grid_square grid_to_lat_lon
		%( lat/lon, lat_start/lon_start, lat_incr/lon_incr are globals now)
		%(draw_worked_grid_square: grid_map_mode\n) print_notice lat lon lat_start lon_start lat_incr lon_incr pstack pop pop pop pop pop pop

		%set colors according to modifiers
		worked_grid_square_color setrgbcolor % default
		set_grid_box_color
		%(draw_worked_grid_square: no propagation mode \n) print_notice pstack
		draw_grid_box
		%exit % out of whole loop so this box is not processed by "unknown propagation mode"
		/propagation_mode_ok	true	def		
		black setrgbcolor
	} if

	grid_map_mode (F2) eq
		{
		%symbol in top right of gridsquare
		grid_square grid_to_lat_lon
		%(F2 symbol: grid_map_mode \n) print_notice lat lon lat_start lon_start lat_incr lon_incr pstack pop pop pop pop pop pop
		gsave

		% move to top right corner of gridsquare

		lat_start 0.5 add /lat_start exch def
		lon_start 1.0 add /lon_start exch def
		F2_color setrgbcolor
		0.5 /lat_incr exch def
		1.0 /lon_incr exch def


		%draw F2 squares in bottom left quarter of grid square
		%lat_start lat_incr sub /lat_start exch def
		%lon_start lon_incr sub /lon_start exch def

		draw_grid_box
		grestore
		%exit % out of whole loop so this box is not processed by "unknown propagation mode"
		/propagation_mode_ok	true	def		
		%black setrgbcolor
		} if

	grid_map_mode (ES) eq
		{
		%(Es symbol: grid_map_mode \n) print_notice lat lon lat_start lon_start lat_incr lon_incr pstack pop pop pop pop pop pop
		grid_square grid_to_lat_lon

		gsave
		Es_color setrgbcolor
		0.5 /lat_incr exch def
		1.0 /lon_incr exch def

		%draw Es squares in bottom right quarter of grid square
		lon_start 1.0 add /lon_start exch def

		draw_grid_box
		grestore
		%exit
		/propagation_mode_ok	true	def		
		} if



	%symbols below use line drawings
	coarse_gl_width setlinewidth

	grid_map_mode (AU) eq
		{
		%bottom left corner of gridsquare
		%(Au symbol: grid_map_mode \n) print_notice lat lon lat_start lon_start lat_incr lon_incr pstack pop pop pop pop pop pop
		grid_square grid_to_lat_lon

		gsave	%lat/lon lat_start/lon_start etc
		red setrgbcolor
		0.5 /lat_incr exch def
		0.25 /lon_incr exch def

		%draw aurora symbol
		%6 "S" shaped squiggles each of different colors
		0 1 6
			{
			/temp exch def
			%offset start again for each iteration
			lon_start temp 0.125 mul add /lon_Au exch def
			temp 0 eq {green setrgbcolor} if
			temp 1 eq {orange setrgbcolor} if
			temp 2 eq {magenta setrgbcolor} if
			temp 3 eq {blue setrgbcolor} if
			temp 4 eq {yellow setrgbcolor} if
			temp 5 eq {cyan setrgbcolor} if
			temp 6 eq {lightred setrgbcolor} if
			%bezier curve

			%(Au symbol: \n) print_notice lat lon lat_start lon_start lat_incr lon_incr pstack pop pop pop pop pop pop

			%start of curveto
			lat_start lon_Au lat_lon2xy moveto

			lat_start lat_incr 3 div add
			lon_Au lon_incr 2 mul add
			lat_lon2xy % x1,y1 for curveto

			lat_start lat_incr 3 div 2 mul add
			lon_Au lon_incr sub
			lat_lon2xy %x2,y2

			lat_start lat_incr add
			lon_Au lon_incr add
			lat_lon2xy %x3,y3

			curveto
			stroke
			}for %6 different lines
		grestore
		black setrgbcolor
		%exit % out of whole loop so this box is not processed by "unknown propagation mode"
		/propagation_mode_ok	true	def		
		} if %(Au)

	grid_map_mode (MS) eq
		{
		grid_square grid_to_lat_lon
		gsave
		Ms_color setrgbcolor

		%Nov 98, this is all a bit opaque to me, as to what is happening here, I sure hope it doesn't break :-(

		/lat lat 0.5 sub def
		/lon lon 1.0 sub def


		0.55 /lat_offset exch def
		0.4 /lat_incr exch def
		0.25 /lon_incr exch def

		0 1 3
			{
			/temp exch def
			temp 0.25 mul /lon_start exch def

			%draw meteor symbol on top left of grid_square

			newpath	% needed to clear currentpoint (which just happens to be the Copyright label at the bottom left of the page)
			lat lat_offset add
			lon lon_start add
			lat_lon2xy
			2 copy	%2 lat/lon pairs on stack

			lat_incr 10 div 0 360 arc fill	%one lat/lon pair used

			moveto %another lat/lon pair used
			lat lat_offset add lat_incr add
			lon lon_start add lon_incr add
			lat_lon2xy lineto

			stroke
			}for %three different lines
		black setrgbcolor
		grestore
		%exit % out of whole loop so this box is not processed by "unknown propagation mode"
		/propagation_mode_ok	true	def		
		} if

	grid_map_mode (EME) eq
		{
		grid_square grid_to_lat_lon
		%(EME symbol: \n) print_notice lat lon lat_start lon_start lat_incr lon_incr pstack pop pop pop pop pop pop
		gsave
		EME_color setrgbcolor

		0.0 /lat_offset exch def
		1.5 /lon_offset exch def
		0.5 /lat_incr exch def
		0.5 /lon_incr exch def

		% grid is a 2deg by 1deg rectangle
		% the lat/lon returned is the center of the square
		/lat lat 0.5 sub def
		/lon lon 1.0 sub def
		% the lat/lon returned is the bottom left corner

		% moon symbol is bottom right
		% the 0.1 degree numbers skew the moon symbol, giving it a slight tilt

		newpath
		%make big arc

		lat lat_offset add
		lon lon_offset add 0.1 sub
		lat_lon2xy moveto

		lat lat_offset add
		lon lon_offset add lon_incr add
		lat_lon2xy %lineto

		lat lat_offset add lat_incr add
		lon lon_offset add lon_incr add
		lat_lon2xy %lineto

		lat lat_offset add lat_incr add
		lon lon_offset add 0.1 add
		lat_lon2xy %lineto
		curveto
		%now at top of moon

		%make 2 smaller arcs
		lat lat_offset add lat_incr add
		lon lon_offset add 0.1 add
		lat_lon2xy moveto

		lat lat_offset add lat_incr add
		lon lon_offset add lon_incr 2 div add
		lat_lon2xy %lineto

		lat lat_offset add lat_incr 2 div add
		lon lon_offset add lon_incr 2 div add
		lat_lon2xy %lineto

		lat lat_offset add lat_incr 2 div add
		lon lon_offset add
		lat_lon2xy %lineto

		curveto

		lat lat_offset add lat_incr 2 div add
		lon lon_offset add lat_lon2xy moveto

		lat lat_offset add lat_incr 2 div add
		lon lon_offset add lon_incr 2 div add
		lat_lon2xy %lineto

		lat lat_offset add
		lon lon_offset add lon_incr 2 div add
		lat_lon2xy %lineto

		lat lat_offset add
		lon lon_offset add 0.1 sub
		lat_lon2xy %lineto

		curveto
		stroke
		black setrgbcolor
		grestore
		%exit % out of whole loop so this box is not processed by "unknown propagation mode"
		/propagation_mode_ok	true	def		
		} if

	grid_map_mode (TEP) eq
		{
		grid_square grid_to_lat_lon
		gsave

		%(TEP symbol: \n) print_notice lat lon lat_start lon_start lat_incr lon_incr pstack pop pop pop pop pop pop
		TEP_color setrgbcolor
		coarse_gl_width 4 mul setlinewidth


		/lat lat 0.5 sub def
		/lon lon 1.0 sub def

		% TEP symbol is whole square.
		% Don't expect to work many grids by both TEP and another mode (except EME maybe)

		newpath
		%make double bounce symbol
		/lat_offset 0 def
		/lon_offset 0 def

		lat lat_offset add
		lon lon_offset add
		lat_lon2xy moveto

		lat lat_offset add lat_incr add
		lon lon_offset add lon_incr 3 div add
		lat_lon2xy %lineto

		lat lat_offset add lat_incr add
		lon lon_offset add lon_incr 2 div add
		lat_lon2xy %lineto
		30 atom mul
		arct


		lat lat_offset add lat_incr add
		lon lon_offset add lon_incr 2 div add
		lat_lon2xy
		lineto
		%curveto

		%next part of curve

		lat lat_offset add lat_incr add
		lon lon_offset add lon_incr 2 div add
		lat_lon2xy
		moveto


		lat lat_offset add lat_incr add
		lon lon_offset add lon_incr 3 div 2 mul add
		lat_lon2xy %lineto

		lat lat_offset add
		lon lon_offset add lon_incr add
		lat_lon2xy
		30 atom mul arct

		lat lat_offset add
		lon lon_offset add lon_incr add
		lat_lon2xy lineto

		stroke
		black setrgbcolor
		grestore
		%exit % out of whole loop so this box is not processed by "unknown propagation mode"
		/propagation_mode_ok	true	def		
		} if



		propagation_mode_ok not		
		{
			(Ignored unknown propagation mode: ) print_notice
			grid_map_mode =
		} if 


az_dict /F2_color undef
az_dict /Es_color undef
az_dict /Ms_color undef
az_dict /EME_color undef
az_dict /Au_color undef
az_dict /TEP_color undef
az_dict /lat_start undef
az_dict /lat_offset undef
az_dict /lat_incr undef
az_dict /lon_start undef
az_dict /lon_offset undef
az_dict /lon_incr undef
az_dict /temp undef
%(draw_worked_grid_square: exit ) print_notice

}def %draw_worked_grid_square

%--------------------------------------
/swap_points
{
%called by draw_qso_path
%so that the path from (lat1,lon1) to (lat2,lon2) is the shortpath

lon1 lon2 /lon1 exch def /lon2 exch def
lat1 lat2 /lat1 exch def /lat2 exch def
} def


%--------------------------------------
/tan
%angle on stack, returns tan on stack
{
dup sin exch cos div
}def

%--------------------------------------
/draw_shortpath
%called by draw_qso_path
%draws shortpath greatcircle between two points.
%function involves tan(lon1-lon2) and hence
%cases where these two points have same lon,
%or have lon1-lon2=180 (over the pole), are trapped
%by the calling routine and are handled separately.
%
%
%lat1 lon1 lat2 lon2 are globals
{
	%(draw_qso_path: start \n) print_notice
	%qso_color setrgbcolor
	%now in /draw_qso_path
	%coarse_gl_width 2 mul setlinewidth
	newpath

	lat1 lon1 lat_lon2xy moveto
	%(draw_qso_path: 1 \n) print_notice lon2 lat2 lon1 lat1 pstack pop pop pop

	lon1 0.1 lon2
	{
	/lon exch def
	%(draw_qso_path: lon \n) print_notice lon pstack pop
	lat1 tan
	lon2 lon sub sin mul
	%(draw_qso_path: 2 \n) print_notice pstack

	lat2 tan
	lon lon1 sub sin mul
	add
	%(draw_qso_path: 3 \n) print_notice pstack

	lon2 lon1 sub sin div
	%(draw_qso_path: 4 \n) print_notice pstack

	1 atan
	/lat exch def
	%(draw_qso_path: 5 new point \n) print_notice pstack lon lat pstack pop pop

	lat lon lat_lon2xy lineto
	%(draw_qso_path: 6 \n) print_notice

	} for % all lon
	stroke
}def %draw_shortpath

%--------------------------------------
/draw_same_lon
%called by draw_qso_path
%draws shortpath greatcircle between two points of same lon.
%
%lat1 lon1 lat2 lon2 are globals
{
	%(draw_same_lon: \n) print_notice
	%qso_color setrgbcolor
	%now in /draw_qso_path
	%coarse_gl_width 2 mul setlinewidth
	newpath

	lon1 /lon exch def
	lat1 lon lat_lon2xy moveto

	lat1 0.1 lat2
	{
	/lat exch def

	lat lon lat_lon2xy lineto

	} for % all lon
	stroke
}def %draw_shortpath
%--------------------------------------
/draw_over_the_pole
%called by draw_qso_path
%draws shortpath greatcircle between two points of opposite lon.
%
%lat1 lon1 lat2 lon2 are globals
{
	%(draw_over_the_pole: \n) print_notice
	%qso_color setrgbcolor
	%now in /draw_qso_path
	%coarse_gl_width 2 mul setlinewidth
	newpath

	{
		%are we going over the north or south pole?
		lat1 lat2 add 2 div dup 90 lt exch 0 gt and
		{
			%going over north pole, draw in 2 segments so don't do through pole

			lon1 /lon exch def
			lat1 lon1 lat_lon2xy moveto
			lat1 0.1 89
			{
				/lat exch def
				lat lon lat_lon2xy lineto
			} for % all lon
			stroke

			lon2 /lon exch def
			lat2 lon2 lat_lon2xy moveto
			lat2 0.1 89
			{
				/lat exch def
				lat lon lat_lon2xy lineto
			} for % all lon
			stroke

			exit
		} if

		%are we going over the north or south pole?
		lat1 lat2 add 2 div dup -90 gt exch 0 lt and
		{
			%going over south pole, draw in 2 segments so don't do through pole

			lon1 /lon exch def
			lat1 lon1 lat_lon2xy moveto
			lat1 -0.1 -89
			{
				/lat exch def
				lat lon lat_lon2xy lineto
			} for % all lon
			stroke

			lon2 /lon exch def
			lat2 lon2 lat_lon2xy moveto
			lat2 -0.1 -89
			{
				/lat exch def
				lat lon lat_lon2xy lineto
			} for % all lon
			stroke
			exit
		} if

		%default of case statement
		%(test_over_the_pole: points are either at the same pole or opposite each other, skipping \n) print_notice
		%lon2 lat2 lon1 lat1 pstack pop pop pop pop
	}loop


}def %draw_over_the_pole

%--------------------------------------
/draw_qso_path
%called by draw_qso
%draws great circle path between two points
%calling routine pushs on the stack lat1, lon1, lat2, lon2
%
%the math is from Chris Cosgrove of Sydney University
%his explanation is directly below this subroutine
%
{
	/path_ok true def	% false for path that goes over the pole
	/lon2 exch def
	/lat2 exch def
	/lon1 exch def
	/lat1 exch def

	coarse_gl_width 4 mul setlinewidth

	%(draw_qso_path: 1st point \n) print_notice lon1 lat1 pstack pop pop
	%(draw_qso_path: 2nd point \n) print_notice lon2 lat2 pstack pop pop


	{
	%-180<lon<=180
	%-90<lat<90

	lon2 lon1 sub

	% diff > 180
	dup 180 gt
		{
		%(draw_qso_path: longpath, add 360 to lon1, invert order \n) print_notice
		%add 360, exchange points
		lon1 360 add /lon1 exch def
		swap_points
		draw_shortpath
		exit
		} if % diff > 180

	dup 180 eq
		{
		%(draw_qso_path: path is over a pole \n) print_notice
		draw_over_the_pole
		exit
		} if


	% 0 < diff < 180
	dup dup 0 gt exch 180 lt and
		{
		%(draw_qso_path: shortpath \n) print_notice
		draw_shortpath
		exit
		} if

	% diff == 0
	dup 0 eq
		{
		%(draw_qso_path: points at same longitude \n) print_notice
		draw_same_lon
		exit
		} if % diff > 180


	% -180 < diff < 0
	dup dup -180 gt exch 0 lt and
		{
		%(draw_qso_path: longpath, inverting order \n) print_notice
		swap_points
		draw_shortpath
		exit
		} if


	dup -180 eq
		{
		%(draw_qso_path: path is over the pole \n) print_notice
		draw_over_the_pole
		exit
		} if

	% diff < -180
	dup -180 lt
		{
		%(draw_qso_path: shortpath, have to add 360 to lon2 \n) print_notice
		%add 360 to 2nd lon
		lon2 360 add /lon2 exch def
		draw_shortpath
		} if % diff > 180

	}loop % through all possibilities

	pop % the lon difference on the stack

}def %draw_qso_path

%Subj:	Great Circle Problem
%
%G'day Joe,
%
%      Here is a solution to your great circle problem. I am
%assuming that you want to interpolate points on the arc that
%are equally spaced on the sphere.
%
%	Let "phi" (here lon) denote the longitude coordinate,
%running from -180 on the east side of the date line to +180 on the west side. It is
%convenient to extend the range of lon from -180 to +360. Similarly,
%let "th" (abbreviation for theta) denote the latitude coordinate,
%running from -90 at the south pole to +90 at the north pole.
%
%	Next, let (lat1,lon1) be the coordinates of the endpoint A
%and (lat2,lon2) be the coordinates of the endpoint B of the
%great circle arc. Exclude the simple cases where A and B are on
%the same meridian or opposite meridians. Hence we are excluding
%great circles that pass through the poles. Let P be a moving point
%on the arc AB having coordinates (th,lon).
%
%	We need to decide which endpoint is A and which is B. Choose
%them so that
%
%         0 < lon2 - lon1 < 180.
%
%Then the short arc of the great circle is the one where lon runs
%from lon1 to lon2. If the short arc crosses the date line, then
%lon2 will be between 180 and 360.
%
%Let "psi" and "psi_0" denote the angles subtended by the arcs AP and AB,
%respectively, at the centre of the sphere. These angles must lie between
%0 and 180. The arc length of AP is R psi, where R is the radius of the
%sphere. Similarly, R psi_0 is the arc length of AB. psi_0 and psi can
%be calculated from
%
%	cos(psi_0) 	= sin(lat1)sin(lat2)
%			+ cos(lat1)cos(lat2)cos(lon2-lon1)	(1)
%
%	cos(psi) 	= sin(lat1)sin(th)
%			+ cos(lat1)cos(th)cos(lon-lon1)	(2)
%
%	sin(psi_0) 	= cos(lat2)sqrt[
%			(sin(lon2-lon1))^2
%			+ (cos(lat1)tan(lat2)
%			- sin(lat1)cos(lon2-lon1))^2
%					]			(3)
%
%	sin(psi) 	= sin(psi_0)cos(th)sin(lon-lon1)
%			/(cos(lat2)sin(lon2-lon1))		(4)
%
%Inverting the cosines in (1) and (2) gives unique values of psi_0 and
%psi between 0 and 180.


%
%	sin(psi_0) 	= cos(lat2)sqrt[
%			(sin(lon2-lon1))^2
%			+ (cos(lat1)tan(lat2)
%			- sin(lat1)cos(lon2-lon1))^2
%					]			(3)

	%lon2 lon1 sub cos
	%lat1 sin mul neg
	%	%lat2 tan
	%lat2 dup sin exch cos div
	%lat1 cos mul add
	%dup mul

	%lon2 lon1 sub sin dup mul add
	%sqrt
	%lat2 cos mul
	%	% have sin(psi_0)
	%(draw_qso_path: sin psi_0 \n) print_notice
	%pstack




%
%	cos(psi_0) 	= sin(lat1)sin(lat2)
%			+ cos(lat1)cos(lat2)cos(lon2-lon1)	(1)

	%lon2 lon1 sub cos
	%lat2 cos mul
	%lat1 cos mul
	%lat2 sin
	%lat1 sin mul add
	%	% have cos(psi_0)
	%(draw_qso_path: cos psi_0 \n) print_notice
	%pstack


	%atan
	%/psi_0 exch def
	%(draw_qso_path: psi_0 \n) print_notice
	%psi_0 pstack pop


%



%
%	cos(psi) 	= sin(lat1)sin(lat)
%			+ cos(lat1)cos(lat)cos(lon-lon1)	(2)
%
%
%	sin(psi) 	= sin(psi_0)cos(lat)sin(lon-lon1)
%			/(cos(lat2)sin(lon2-lon1))		(4)
%
%Inverting the cosines in (1) and (2) gives unique values of psi_0 and
%psi between 0 and 180.
%
%	The formula for latitude (lat) of P in terms of longitude (lon) is
%
%	tan(lat) 	= [tan(lat1)sin(lon2-lon)
%			+ tan(lat2)sin(lon-lon1)]
%			/sin(lon2-lon1)			(5)





%
%	The formula for latitude (th) of P in terms of longitude (lon) is
%
%	tan(th) 	= [tan(lat1)sin(lon2-lon)
%			+ tan(lat2)sin(lon-lon1)]
%			/sin(lon2-lon1)			(5)
%
%Again, inverting the tangent gives a unique angle between -90 and +90.
%
%	 In order to interpolate points, we want formulae for th and lon
%in terms of the arc length parameter psi. Suppose we want to subdivide
%the arc AB into n equal subintervals. Calculate psi_0 from (1) above
%and let psi take the n+1 values,
%
%	psi = 0, psi_0/n, 2 psi_0/n, 3 psi_0/n, ... , (n-1)psi_0/n, psi_0.
%
%Then lon is given explicitly in terms of psi by
%
%	sin(lon2-lon1)cot(lon-lon1)
%
%			= (cos(lat1)/cos(lat2))sin(psi_0)cot(psi)
%			+ sin(lat1)
%			[sin(lat1)cos(lon2-lon1)
%			- cos(lat1)tan(lat2)]			(6)
%
%
%Inverting the cotangent gives a unique value of lon-lon1 between 0 and
%180.  Having constructed lon in terms of psi, th can be constructed from
%either (4) or (5), the former leaving the sign of th undetermined and the
%latter giving th uniquely.
%
%	Finally, if you know the map coordinates (x,y) in terms of (th,lon),
%then you now have x and y in terms of the arc length parameter psi, running
%from 0 to psi_0. I hope this is what you wanted.
%
%	Chris
%
%--------------------------------------
/draw_qso
{
	% Aug 2000
	% initially I expected all locations to come as 4char gridlocators
	% I have since (about May 2000) changed as much of the code as I could so that
	% locations can be any of a number of formats (including lat,lon).
	% I thought initially that it would be neat to have the option to
	% fill in the box (gridsquare) at each end of the qso.
	% I did this by putting the gridlocator in UC or lc.
	% I haven't used this box at all and for any reasonable number of contacts
	% eg a contest or an opening, it's a nuisance.
	% I'm now expanding the function so that I can feed 6char gridlocators in which case
	% this 4 char gridlocator box is meaningless.
	% I think I'm going to shelve/disable the code which draws this grid box.
	%
	%(draw_qso: start \n) print_notice pstack
	%on stack will be a line of the type
	%(w3abc:EM85:n2xy:FN00:comment field)

	coarse_gl_width master_line_width_factor mul 2 mul setlinewidth

	% set default color
	qso_color setrgbcolor
	band (50) eq { 50_color setrgbcolor } if
	band (144) eq { 
			144_color setrgbcolor 
			%(draw_qso: band 144 \n) print_notice pstack
			} if
	band (222) eq { 222_color setrgbcolor } if
	band (432) eq { 432_color setrgbcolor } if

	% 4 char grid locator box size (required for /draw_grid_box)
	0.0 /lat_start exch def
	1.0 /lat_incr exch def
	0.0 /lon_start exch def
	2.0 /lon_incr exch def

	(:) search
	{
		exch pop %the `:'
		%(draw_qso: 1st callsign \n) print_notice pstack
		/first_call exch def 	%can be null, ie ()
		(:) search
		{
			exch pop % move the `:' to the top and pop it
			%on stack either gridlocator or lat,lon
			%should test for lat,lon sometime, ie is there a ',' in the string?
			%will do later
			%how many chars in this gridlocator
			
			dup length 
			%on stack is gridlocator and gridlocator_length
			%(draw_qso: first gridlocator length \n) print_notice pstack 
			/gridlocator_length exch def 
			dup /grid_square exch def
			%grid_square of first station on top of stack

			location_to_lat_lon
			%lon lat (draw_qso: lat lon gridsquare center, 1st gridlocator \n) print_notice pstack pop pop

			%if location came in as gridsquare, 
			%then lat/lon will be the center of the (4 or 6 char) gridsquare and we're OK
			%if location came in as lat/lon, we'll be OK by definition


			lat /lat1 exch def
			lon /lon1 exch def

			%lon1 lat1 (draw_qso: lat1 lon1 center of gridsquare for 1st gridlocator \n) print_notice pstack pop pop

			% old code, when finding corner of gridbox 
			% from arbitary lat lon in the box 
			%/lat lat floor 0.5 add def
			%/lon lon 2 div floor 2 mul 1.0 add def
			%lon1 lat1 (draw_qso: lat1 lon1 1st \n) print_notice pstack pop pop


		%	set_grid_box_color
		%	%do we want to draw the grid_box?
		%	%if first letter of grid_locator is upper case then draw
		%	%else first letter of grid_locator is lower case do not draw
		%	grid_square 0 get
		%	%(draw_qso: 1st grid_square, first char \n) print_notice grid_square pstack pop

		%	dup 65 ge exch 82 le and	% have uppercase grid_locator A (65)->R(82)
		%	{
		%		%(draw_qso: 1st grid_square, uppercase first char \n) print_notice pstack
		%		% lat and lon above are for the center of the square
		%		/lat lat 0.5 sub def
		%		/lon lon 1.0 sub def
		%		draw_grid_box	%sets colors from data_modifier
		%		stroke
		%	} if


			(:) search
			{
				exch pop % the (:)
				/second_call exch def 	%can be null
				%(grid square of 2nd station:comment field) on top of stack

				(:) search
				{
					exch pop % move the `:' to the top and pop it
					%(draw_qso: 2nd callsign \n) print_notice pstack
					% grid_square on top, comment below it
					exch
					% display comment field on top (may be null)
					%(qso: comment field \n )print_notice pstack
					pop
					dup /grid_square exch def
					%grid_square of 2nd station on top of stack


					location_to_lat_lon
					%grid_to_lat_lon

					lat /lat2 exch def
					lon /lon2 exch def

					%if location came in as 4 char gridsquare, 
					% then lat/lon will be the center of the square and we're OK
					%if location came in as lat/lon, 
					%it will be anywhere in gridsquare

					%this was for finding the location 
					%of a 4char gridbox from an arbitary lat,lon within the box
					%find center of gridsquare
					%/lat lat floor 0.5 add def
					%/lon lon 2 div floor 2 mul 1.0 add def
					% lat and lon above are for the center of the square

					lat /lat2 exch def
					lon /lon2 exch def

					%do we want to draw the grid_box?
					%if first letter of grid_locator is upper case then draw
					%else first letter of grid_locator is lower case do not draw
		%			grid_square 0 get
		%			%lat2 lon2 (draw_qso: 2nd grid_square \n) print_notice grid_square pstack pop pop pop
		%			dup 65 ge exch 82 le and	% have uppercase grid_locator A (65)->R(82)
		%			{
		%				% lat and lon above are for the center of the square
		%				/lat lat 0.5 sub def
		%				/lon lon 1.0 sub def
		%				draw_grid_box	%sets colors from data_modifier
		%				stroke
		%			} if
				} if % (:)
			} if % (:)
		}if % (:)
	} if %  (:)

	%(qso: \n) print_notice lon2 lat2 second_call lon1 lat1 first_call pstack pop pop pop pop pop pop

	show_qso_callsigns
	{
		gsave   % so colors of grid box and qso_path are not lost
		qso_font findfont qso_font_size 2 mul scalefont setfont
		%only use qso_font_color (black) if qso_color is yellow
		band (144) eq
			{
			az_dict /qso_font_color known {qso_font_color setrgbcolor} if
			} if
		lat1 lon1 lat_lon2xy moveto
		first_call dup stringwidth pop 2 div neg atom 8 mul rmoveto show

		lat2 lon2 lat_lon2xy moveto
		second_call dup stringwidth pop 2 div neg atom 8 mul rmoveto show
		grestore
	} if


	%push stuff on stack for /draw_qso_path
	lat1 lon1 lat2 lon2

	%(qso: output \n) print_notice pstack

	draw_qso_path

	black setrgbcolor	% restoring color in case some downstream routine doesn't have it set
	%(draw_qso: end \n) print_notice pstack

}def


%--------------------------------------
/draw_qra
{
	%(draw_qra: start \n) print_notice pstack
	%on stack will be a line of the type
	%(1A0KM:JN61:comment field)

	coarse_gl_width master_line_width_factor mul 2 mul setlinewidth

	% set default color
	qra_color setrgbcolor

	(:) search
	{
		%(draw_qra: callsign \n) print_notice pstack
		/call_sign exch def 	%can be null
		pop %the `:'
		(:) search
		{
			exch pop % move the `:' to the top and pop it
			dup /grid_square exch def
			%grid_square of station on top of stack
			location_to_lat_lon
			%grid_to_lat_lon
			%lat lon now globals
		}if %`:'
	} if %  `:'

	%(qra: \n) print_notice lon lat call_sign pstack pop pop pop

	qra_font findfont qra_font_size scalefont setfont
	az_dict /qra_font_color known {qra_font_color setrgbcolor} if
	lat lon lat_lon2xy moveto
	call_sign dup stringwidth pop 2 div neg atom 8 mul rmoveto show
	lat lon lat_lon2xy moveto
	draw_qra_symbol

	black setrgbcolor	% restoring color in case some downstream routine doesn't have it set
	%(draw_qra: end \n) print_notice pstack

}def


%--------------------------------------
/take_a_sighting
{
		info_on_other_guy
		{
			draw_distance_bearing_lines
			{
				newpath
				2.5 atom mul setlinewidth
				0 0 moveto
				lat lon lat_lon2xy lineto % rover's location
				stroke
			} if %draw_distance_bearing_lines

			show_bearing
			{
				%go to half way out
				lat lon gc
				%dist bearing on stack
				dup /bearing exch def
				%divide distance by half, and keep copy of dist
				exch dup /dist exch def 2 div exch
				distance_bearing2xy moveto	%go there
				%convert compass origin and direction of rotation to cartesian system
				bearing neg 90 add rotate
				0 10 atom mul rmoveto
				bearing cvi temp_string cvs dup stringwidth pop 2 div neg 0 rmoveto show
				0 10 atom mul neg rmoveto
				bearing 90 sub rotate
			}if %show_bearing

			show_distance
			{
				dist 2 div bearing distance_bearing2xy moveto	%go there
				bearing neg 90 add rotate
				0 30 atom mul neg rmoveto
				%convert deg to km, find string width, offset, show
				dist deg2km cvi temp_string cvs dup stringwidth pop 2 div neg 0 rmoveto show
				( km) show
				0 30 atom mul rmoveto
				bearing 90 sub rotate
			} if %show_distance
		} if %info_on_other_guy
}def %take_a_sighting



%--------------------------------------
/draw_mountain_symbol
{
	%(draw_mountain_symbol: start \n) print_notice
	% mountain symbol is a filled black triangle
	% position on paper is already defined at entry into this routine
	% the distance from the center of an isoceles triangle to the top
	% is cos(30)x 2/3 = 0.577 = tan(30)
	/mountain_symbol_size atom 10 mul def
	%/mountain_symbol_size atom 40 mul def
	newpath
	%black setrgbcolor
	%lat lon (draw_mountain_symbol: start 1 \n) print pstack pop pop
	lat lon lat_lon2xy moveto	% mountain's location
	0 mountain_symbol_size 0.577 mul rmoveto	% to top of triangle
	mountain_symbol_size 0.5 mul neg mountain_symbol_size 0.866 mul neg rlineto	%bottom left
	mountain_symbol_size 0 rlineto	%bottom right
	mountain_symbol_size 0.5 mul neg mountain_symbol_size 0.866 mul rlineto	%top
	closepath %
	fill
	%(draw_mountain_symbol: end \n) print_notice

} def

%--------------------------------------
/draw_mountain
% on stack - a string of the type (Mt. Kearsarge:FN43bj:1500m:)
% 														or  Mt. Kearsarge:FN43bj::
{
	%(mountain: start \n) print_notice pstack
	(:) search
	{
		/top_string exch def
		pop % (:)
		(:) search
		{
			exch pop % the (:)

			location_to_lat_lon

			bad_loc not
				{
					%(mountain: drawing symbol \n) print_notice pstack
					% valid location
					draw_mountain_symbol
					(:) search	%look for elevation string
					{
						exch pop % the (:)
						/bottom_string exch def
						pop % () null string or comments on RHS of (:)
					} if % bottom_string found
				}
				{
					pop	
					%(mountain: bad_loc stack should be empty before exit \n) print_notice pstack
					exit 	%bad location
				} ifelse % valid location

		% print strings
		% put top_string above mountain symbol
		% put elevation (if known) below mountain_symbol
		% rover strings will be put to the left and right of the
		% location, so if a rover is on the mountain, the strings
		% will not overlap.

    		mountain_font findfont mountain_font_size scalefont setfont
		mountain_font_color setrgbcolor

		lat lon lat_lon2xy moveto	% mountain's location
		%offset incase anyone has already drawn a symbol at this spot 
		%(I would hope a mountain takes precedence and is drawn first)

		% decided not to offset mountain symbols
		% don't think likely to have 2 different mountains at the same spot
		% also mountain is not parsed by draw_transmitter

		%0 mountain_font_size number_stations_at_this_grid_locator 1 sub mul 
		%	1.0 mul 
		%	rmoveto
		top_string
    		dup stringwidth pop 2 div neg
    		atom 20 mul rmoveto
		show

		lat lon lat_lon2xy moveto	% mountain's location
		%offset incase anyone has already drawn a symbol at this spot 
		%(I would hope a mountain takes precedence and is drawn first)
		%0 mountain_font_size number_stations_at_this_grid_locator 1 sub mul 
		%	1.0 mul 
		%	rmoveto
		bottom_string
    		dup stringwidth pop 2 div neg
    		atom 40 mul neg rmoveto
		show

		%(mountain: string written \n) print_notice pstack
		take_a_sighting


		} % if (:) infront of grid_locator
		{
		} ifelse % grid_locator
	} % search found a `:', hopefully a name
	{
		% no contenders for a mountain name, print error message
		(error: no mountain name \n) print
	} ifelse % search for :

az_dict /top_string undef
az_dict /bottom_string undef
}def

%--------------------------------------
% VW beetle
/beetle
{
	% alright, alright, so it's a dumb looking beetle...
	% so send me a better one.

	%uses lat lon (globals produced from grid_to_lat_lon)
	/rover_symbol_size atom rover_symbol_rel_size mul def
	rover_symbol_color setrgbcolor  % color in az_ini.ps
	5 rover_symbol_size mul setlinewidth

	%(lat lon) lat lon pstack pop pop pop

	lat	lon lat_lon2xy % rover location on stack
	/rover_y exch def
	/rover_x exch def


	newpath
	% draw front wheel
	rover_x -20 rover_symbol_size mul add rover_y 10 rover_symbol_size mul 0 360 arc
	closepath
	stroke

	% draw back wheel
	newpath
	rover_x 20 rover_symbol_size mul add rover_y 10 rover_symbol_size mul 0 360 arc
	closepath
	stroke

	%hood
	newpath
	rover_x -20 rover_symbol_size mul add rover_y 25 rover_symbol_size mul 75 180 arc
  stroke

	%back end of body
	newpath
	rover_x 10 rover_symbol_size mul add rover_y 40 rover_symbol_size mul 0 90 arc
	-5 rover_symbol_size mul 0 rlineto
	0 30 rover_symbol_size mul rlineto
	0 -30 rover_symbol_size mul rlineto
	-10 rover_symbol_size mul 0 rlineto
	-10 rover_symbol_size mul -10 rover_symbol_size mul rlineto
	stroke
}def

%--------------------------------------
/draw_rover_symbol
{
	beetle    %VW beetle
	%bronco   %(Jun 94) someone want to make up a routine to draw a white Ford Bronco?
} def
%--------------------------------------
/draw_rover
% on stack - a string of the type Mt. Kearsarge:FN43bj:1500m:comment
% 														or  Mt. Kearsarge:FN43bj::
{
	(rover \n) print_notice
	%pstack
	(:) search
	{
		/left_string exch def
		pop % (:)
		(:) search
		{
			grid_to_lat_lon
			bad_loc not
				{
					% valid location
					draw_rover_symbol
					pop % (:)
					(:) search	%look for right_string
					{
						/right_string exch def
						pop % (:)
						pop % comment string
					} if % right_string found
				}
				{
					pop	exit 	%bad location
				} ifelse % valid location

		% print strings
		% put over_name at left or rover symbol
		% put comment (or whatever) to right of rover_symbol
		% mountain strings will be put to the above and below the
		% location, so if a rover is on the mountain, the strings
		% will not overlap.

    		rover_font findfont rover_font_size scalefont setfont
		rover_font_color setrgbcolor

		lat lon lat_lon2xy moveto 	% rover's location
		left_string
    		dup stringwidth pop neg 40 atom mul sub % fix x
		rover_font_size 4 div neg % fix y
    		rmoveto
		show

		lat	lon lat_lon2xy moveto	% rover's location
		right_string
		50 atom mul	%fix x
		rover_font_size 4 div neg % fix y
		rmoveto
		show

		take_a_sighting

		} % if (:) infront of grid_locator
		{
		} ifelse % grid_locator
	} % search found a `:', hopefully a name
	{
		% no contenders for a rover name, print error message
		(error: no rover name \n) print
	} ifelse % search for :
az_dict /left_string undef
az_dict /right_string undef
}def


%--------------------------------------

/halo
{
	% This erases the screen around the annotation, so that it is readable
	% We write the character outlines with a very thick white pen first.
	gsave
	currentpoint 1.0 setgray  5 atom mul setlinewidth
	2 index true charpath stroke moveto
	grestore show
} def

%--------------------------------------

/ffill
{
	gsave 1.0 setgray 0 atom mul setlinewidth stroke grestore fill
} def

%--------------------------------------
/parse_nmea_data
%line on stack like
% - geographic lat lon
%(GLL,4130.34,N,7135.42,W)
% or - bearing origin to dest
%(BOD,120,T, 125,M,####,####)
% or - bearing to waypoint along great circle
%(BWC,235959,4359.00,N,7059.00,W,180,T,185,M,252.5,N,####)
{
	(,) search
	{
		%has commas, probably a valid nmea data line
		{ % loop through all GPS==$GP data types

			dup (GLL) eq
			{
				% is there a (GLL) before the `,'
				% then the line is a Geographic Lat Lot
				% (GLL) is on top of stack
				% (,) is next
				% (the rest of the GLL string) is next
				%
				%(found GLL \n) print_notice
				pop pop
				extract_GLL
				%pop
				exit
			} if % annotate

			dup (BOD) eq
			{
				% is there a (BOD) before the `,'
				% then the line is a Geographic Lat Lot
				% (BOD) is on top of stack
				% (,) is next
				% (the rest of the BOD string) is next
				%
				% (found BOD \n) print_notice
				pop pop
				extract_BOD
				%pop
				exit
			} if % annotate

			dup (BWC) eq
			{
				% is there a (BWC) before the `,'
				% then the line is a Geographic Lat Lot
				% (BWC) is on top of stack
				% (,) is next
				% (the rest of the BWC string) is next
				%
				% (found BWC \n) print_notice
				pop pop
				extract_BWC
				%pop
				exit
			} if % annotate

			% unknown $GP data type
			(unknown $GP data type ignored: )print_notice = pop pop exit


		} loop % look for nmea data types (GLL, BWC, BOD)
	}% if of ifelse of found (,)
	{
		(bad nmea line \n)print_notice
		pop % whole line
		exit %bad nmea line
	}ifelse
}def



%--------------------------------------
/remove_whitespace
%string on stack, remove whitespace, push string back on stack
%this is mainly for stuff input from a keyboard that has blanks at one end
%so is likely to be a real or a string, ie fairly short
{
%(remove_whitespace: start \n) print_notice pstack
/whitespace_dict 20 dict def 
whitespace_dict begin
/temp_string 		20 string def
/index_out 		0 def
/number_of_whitespaces 	0 def
dup /temp_string exch def 
length 1 sub 0 1 3 -1 roll % on stack is 0 1 (length -1)
	{
	%(remove_whitespace: for \n) print_notice pstack
	/index_in exch def
	temp_string index_in 1 getinterval 
	dup dup ( ) eq exch (	) eq or not	%blank or tab
		{
		%(remove_whitespace: start if not whitespace \n) print_notice pstack
		temp_string index_out 3 -1 roll % temp_string index_out retrieved_string
		putinterval 
		index_out 1 add /index_out exch def	
		} 
		{
		pop	% the index
		number_of_whitespaces 1 add /number_of_whitespaces exch def
		}ifelse % not whitespace
	} for % all chars in temp_string 
%chars have been shuffled to the left.
%ie (abc x) will have been changed to (abcxx), 
%and we will know how many of the chars (index_out) to accept.
%just for my madness I will also write out the extra whitespaces 
%(as blanks) to the end of the string
index_out 1 index_out number_of_whitespaces 1 sub add
	{
	temp_string exch ( ) 
	putinterval 
	%temp_string (remove_whitespace: end re-inserting blanks \n) print_notice pstack pop 
	} for
temp_string 0 index_out getinterval /temp_string exch def
temp_string

end % whitespace_dict
%(remove_whitespace: exit \n) print_notice pstack 
} def
%--------------------------------------
/islat
%string on stack which is already known to pass isnum (ie starts with [0..9] || + || -)
%is expected to be in one of the following forms
%(36.10), (+36.10), (-36.10), (36.10N), (36.10 N), (36.10S), (36.10 S)
%string will be converted to a real and pushed back on stack.
%no error checking, number is assumed to be valid at this point.
%because is a logical true is pushed on the top of the stack
{
	%(islat: entering \n) print_notice pstack
	dup
	%is the last letter [nNsS] ?
	%assemble the command "(string) length_of_string 1 getinterval" to look at the last char
	dup length /string_length exch def
	%string_length (islat: string_length \n) print_notice pstack pop
	% index in array starts at 0, therefor decrement string_length
	dup string_length 1 sub 1 getinterval
	dup /last_char exch def
	%last_char (islat: last char \n) print_notice pstack pop
	%dup dup dup dup (n) eq exch (N) eq exch or (s) eq exch or exch (S) eq or
	dup dup dup (n) eq exch (N) eq or exch (s) eq or exch (S) eq or
	{
		%(islat: last letter is one of nNsS \n) print_notice pstack
		%extract all but last letter
		0 string_length 1 sub getinterval cvr
		% real left on stack 
		% test for S or N
		last_char dup (s) eq exch (S) eq or { neg } if
	} % string ends in one of sSnN
	{
		cvr 
	} ifelse % just a string representing a number
	exch pop % the original string
	true
	%(islat: exiting \n) print_notice pstack
%cleanup
az_dict /string_length	undef
az_dict /last_char 	undef
} def %islat
%--------------------------------------
/islon
%string on stack which is already known to pass isnum (ie starts with [0..9] || + || -)
%is expected to be in one of the following forms
%(36.10), (+36.10), (-36.10), (36.10N), (36.10 N), (36.10S), (36.10 S)
%string will be converted to a real and pushed back on stack.
%no error checking, number is assumed to be valid at this point.
%because is a logical true is pushed on the top of the stack
{
	%(islon: entering \n) print_notice pstack
	dup
	%is the last letter [eEwW] ?
	%assemble the command "(string) length_of_string 1 getinterval" to look at the last char
	dup length /string_length exch def
	dup string_length 1 sub 1 getinterval
	dup /last_char exch def
	%(islon: last letter \n) print_notice pstack
	dup dup dup (e) eq exch (E) eq or exch (w) eq or exch (W) eq or
	{
		%(islon: last letter is one of eEwW \n) print_notice pstack
		%extract all but last letter
		0 string_length 1 sub getinterval 
		%(islon: getinterval \n) print_notice pstack
		cvr
		% real left on stack 
		% test for E or W 
		last_char dup (w) eq exch (W) eq or { neg } if
	} % string ends in one of eEwW
	{
		cvr 
	} ifelse % just a string representing a number
	exch pop % the original string
	true
	%(islon: exiting \n) print_notice pstack
%cleanup
az_dict /string_length	undef
az_dict /last_char 	undef
} def % islon
%--------------------------------------
/isnum
%string/char on stack, 
%returns true if num, else false, 
%original string still on stack.
%this is not a particularly rigourous test of numbericity, 
%but will differentiate a gridsquare from a lat or lon
%a string with a '+' infront of letters will pass this test,
%but I'm not going to hunt down every mistake.
{
	%(isnum: entering \n) print_notice pstack
	dup 0 1 getinterval	%get first char of current field (on top of stack)
	%(isnum: first char \n) print_notice pstack
	%is it a number? allow for a '-' or '+' at the beginning of the string 
	dup dup dup (0) ge exch (9) le and exch (-) eq or exch (+) eq or 
	%(let's hope Postscript doesn't short ciruit evaluate the "or" here 
	% or something will be left on the stack)

	%(isnum: exiting \n) print_notice pstack
} def % isnum
%--------------------------------------
/signof
% real on stack, returns +1 if real >= 0.0, else returns -1
{
	dup 0.0 ge { 1 } { -1 } ifelse 
	(signof: exiting \n) print_notice pstack 
} def % signof
%--------------------------------------
/parse_transmitter
% handles BC stations (TV, FM, MW...), beacon, rover, repeater
{
	% on stack, a line of the type
	% (BC)(:)(48.2:WMAR/02:FM19qi:100000:-1:Baltimore,MD,US;comment field ignored by AZ_PROJ)

	% where -
	%BC data type (Broadcast Station)
	%Freq in MHz
	%Call/Ch (channel only if TV station)
	%Gridlocator
	%Power (watts)
	%City,State/Province,Country
	%coment field (not displayed on map)

	exch pop % (:)

	/transmitter_type exch def 	% eg (BC)
	%(parse_transmitter: \n) print_notice transmitter_type pstack pop
	% BC, AM, TV, FM, LF all use the same symbol and routine for mapping

	transmitter_type (FM) eq {(BC) /transmitter_type exch def} if
	transmitter_type (AM) eq {(BC) /transmitter_type exch def} if
	transmitter_type (TV) eq {(BC) /transmitter_type exch def} if
	transmitter_type (LF) eq {(BC) /transmitter_type exch def} if


	(:) search
	{
		exch pop % the (:)
		% (parse_transmitter: freq, MHz \n) print_notice pstack
		% have string on top of stack which is freq possibly followed by +/-/N/Z at end
		% It may be NULL (eg rover.dat in v1.04)
		% Can't convert to int directly. However we're really only interested in the MHz
		% therefore look for numbers before decimal point
		%dup temp_string cvs /freq_string exch def
		dup /freq_string exch def
		%(parse_transmitter: freq_string \n) print_notice freq_string pstack pop
		(.) search
			{
			%roll the MHz down the stack
			3 1 roll
			pop pop % pop the (.) and kHz+/- string
			%cvi /band exch def
			/band exch def
			%(parse_transmitter: freq, integer part \n) print_notice band pstack pop
			}
			{
			%(parse_transmitter: no '.' in freq string, must be integer \n) print_notice pstack
			%must be integer
			%cvi /band exch def
			%Jun 99, now its a string
			/band exch def
			%(parse_transmitter: freq, integer part \n) print_notice band pstack pop
			} ifelse
		%Look at last char in freq_string, incase there is a +/-/N/Z
		freq_string dup length 1 sub 1 getinterval % get last element
		%(parse_transmitter: last char in freq \n) print_notice pstack
		isnum not
		{
			/freq_offset_type exch def
			%(parse_transmitter: freq_offset_type \n) print_notice freq_offset_type pstack pop
		}
		{
			%(parse_transmitter: NO freq_offset \n) print_notice pstack
			pop
			az_dict /freq_offset_type undef  % flags no offset
		} ifelse

		%On top of stack is a string like (WMAR/02:FM19qi:100000:Baltimore,MD,US;comment field)
		%if the entry is plotted, it will be popped off the stack
		%if not plotted, we have to arrange to pop it
		%put a "mark" underneath it on the stack
		mark exch
		bands_plotted
		{
			%pstack % this element of bands_plotted
			%temp_string cvs	%bands_plotted used to be ints,
						%I changed this to strings for some reason I can't remember :-(
			dup band eq exch (*) eq or
			{
				%(parse_transmitter: band OK \n) print_notice pstack
				draw_transmitter
				exit	% don't need to keep looping though rest of array

			}
			{
				%(parse_transmitter: band NOT OK \n) print_notice pstack
			}ifelse % this band

		} forall % bands
		% if not plotted string will still be here
		% pstack
		cleartomark

	} if % search found a `:'
	az_dict /band undef
	az_dict /freq undef
	exit

}def %parse_transmitter
%--------------------------------------
/move_to_pagespace
{
% The map can be moved around by center_offset
% The coordinates are defined in this map space.
% Thus 0,0 is the center of the projection whether it is on the page or not.
% The titles etc which are in page space, cannot be moved around with the
% the map so reverse offset them
%

	center_offset
	{
		lat_center lon_center gc 180 add distance_bearing2xy
		% make neg
		exch neg
		exch neg
		translate
	} if
} def

%--------------------------------------
/parse_label
%a label line
%label:9:44:-90:1:USA call area 9
%
%on stack, the strings
%(label)(:)(9:40:-88:1:USA call area 9)
{
	%(parse_label: \n) print_notice pstack
	pop pop % (label)(:)

	(:) search
	{
		exch pop % the (:)
		%(parse_label: label string \n) print_notice pstack
		% on top of stack, label
		/label exch def

		(:) search
		{
			exch pop % the (:)
			%(draw_label: lat \n) print_notice pstack

			location_to_lat_lon
			%lat lon (draw_label: lat lon \n) print_notice pstack pop pop


			(:) search %look for font_size
			{
				%(draw_label: font_size \n) print_notice pstack
				% may be null or (hopefully not) blank
				dup dup () eq exch ( ) eq or
				{
					/label_font_size_mul 1 def
					pop pop % : and comment
				}  % if null font_size
				{
					cvr /label_font_size_mul exch def
					pop pop % : and comment
				} ifelse
				% scale label_font_size_mul with the map,
				% so that chars get bigger, with smaller map_scale_deg (from az_ini.ps)
				label_font_size_mul
				40 mul map_scale_deg div
				/label_font_size_mul exch def
			} if % (:font_size)
		} if % (:lat/gridsquare)
	%have all the info
	label_color setrgbcolor
	lat lon
	%(parse_label: lat lon \n) print_notice pstack
	lat_lon2xy moveto
	label_font findfont label_font_size label_font_size_mul mul scalefont setfont
	0 label_font_size label_font_size_mul mul 4 div neg rmoveto
	label center_show
	%label centerxy_show

	} % search found a (:)
	{
		% no lable, print error message
		(parse_label error: no : in data line \n) print_notice
	} ifelse % search for :

}def %parse_label

%--------------------------------------
/draw_legend_symbol
% uses global counter, global legend_number
% color is set here for density legend
% walks the box down the right hand side of the page, starting at top right
% write legend_number, draws box of appropriate color
{
	/box_offset 100 def
	/box_width 50 def
	/box_height 50 def
	%draw box for legend_number
	%offset from edge of page, by box_offset atoms, drop box_height atoms each iteration
	%half_width box_offset atom mul sub half_height box_height atom mul sub box_height atom mul counter mul sub

	data_modifier (density) eq
		{
		%(draw_legend_symbol: density \n) print_notice pstack
		%draw box for legend_number
		%offset from edge of page, by box_offset atoms, drop box_height atoms each iteration
		half_width box_offset atom mul sub half_height box_height atom mul sub box_height atom mul counter mul sub
		%save copy of xy on stack, and move there
		2 copy moveto	% one for string and one for symbol
		%allow for stringwidth, for density legend, color is set in calling routine
		legend_number dup stringwidth pop neg 0 rmoveto show
		set_grid_box_color
		1 atom mul setlinewidth
		newpath
		%pop position on stack
		moveto 10 atom mul -5 atom mul rmoveto
		box_width atom mul 0 rlineto
		0 box_height 1 sub atom mul rlineto
		box_width neg atom mul 0 rlineto
		0 box_height 1 sub neg atom mul rlineto
		fill
		%stroke
		} if %density

	data_modifier (population) eq
		{
		%(draw_legend_symbol: population \n) print_notice pstack
		%offset from edge of page, by box_offset atoms, drop box_height atoms each iteration
		half_width box_offset atom mul sub neg half_height box_height atom mul sub box_height atom mul counter mul sub 
		%save copy of xy on stack, and move there 
		2 copy 	% one for string and one for symbol

		%currentpoint is on the stack, 
		%need to move a little bit and then put it back on the stack again
		% I fudged the numbers here till the symbols covered over a previously drawn set of density legend symbols 
		moveto 37.5 atom mul 12.5 atom mul rmoveto currentpoint% move to center of box
		draw_population_center_symbol

		moveto	%copy of currentpoint on stack
		population_center_font_color setrgbcolor
		%allow for stringwidth
		legend_number dup stringwidth pop neg 50 atom mul sub 300 atom mul add 0 rmoveto show
		%(draw_legend_symbol: population symbol exit \n) print_notice pstack
		} if %population

} def % draw_legend_symbol

%--------------------------------------
/parse_legend
%a legend line
%this was originally only used for density, now I've added population (v1.1.1)
%it may be a bit of a mess now
%
/legend_array 16 array def	% create place to put quantities for symbols in legend
				% the code for coloring baxes for density only has 8 colors
				% I couldn't get more colors than this in rainbow order
				% on an 8bit display. 
				% If the density legend has more than 8 entries, I'm not sure what will happen. (crash or ignore?)
%on stack, the strings, 
%(legend)(:)(density:Density of 6m QRA Operators:1,2,4,8,16,32,64,128:comment)
%or
%(legend)(:)(population:urban population:5000000,2000000,1000000,500000,200000,100000,50000,20000,10000,5000,2000,1000:comment)
{
	%(parse_legend: start \n) print_notice pstack
	pop pop % (legend)(:)

	(:) search % for color_table
		{
		exch pop % the (:)
		/data_modifier exch def	% density - pointer in the density_to_color table for the legend
					% or population 

		(:) search
			{
			exch pop % the (:)
			%on top of stack, legend_header
			/legend_header exch def	% density or population
			%(parse_legend: legend header data_modifier \n) print_notice legend_header data_modifier pstack pop pop


			(:) search % look for end of input string (== start of comment)
				{
				exch pop % the (:)
				%the numbers to put next to each legend symbol (box of different color for density, red circle of various sizes for population) in the legend
				%(parse_legend: legend_number_string \n) print_notice pstack
				/legend_number_string exch def % the rest of the yet to be parsed string
				pop % the comment
				} if % (:) end of input string
			%have parsed the legend line
			legend_color setrgbcolor % The color for the text, from az_ini.ps
			legend_font findfont legend_font_size scalefont setfont
			%visible page is centered at 0,0.
			%edges are at +/- half_width, half_height
			data_modifier (density) eq 
				{
				% x position
				half_width legend_header stringwidth pop 20 atom mul add sub
				} 
				{
				half_width 
				%legend_header stringwidth pop 20 atom mul add sub
				neg 
				} ifelse % (population) and all others
			half_height 50 atom mul sub moveto
			legend_header show

			%parse legend_number_string, loop till reach end
			/counter 0 def
			legend_number_string % a string of 8 monotonically increasing numbers like (1,2,4,8,16,32,64,128) for density or monotonically decreasing numbers like (5000000...10000) for population
				{
				/counter counter 1 add def 	% to position legend_string 
								%(needed for density, not for population) 
				%(parse_legend: counter \n) print_notice counter pstack pop
				(,) search
					{
					exch pop % (,)
					/legend_number exch def
					%(parse_legend: legend_number counter \n) print_notice counter legend_number pstack pop pop
					legend_number /legend_quantity exch def
					%legend_number is a string
					legend_array counter 1 sub legend_number cvr put % array starts at zero
					data_modifier (density) eq {draw_legend_symbol} if
					data_modifier (population) eq 
						{
						legend_quantity cvi /urban_agglomeration exch def
						%(parse_legend: population \n) print_notice counter urban_agglomeration pstack pop pop
						az_dict /symbol_radius_enlargement_ratio undef
						test_for_drawing_population_symbol
						az_dict /symbol_radius_enlargement_ratio known
							{
							draw_legend_symbol
							} if
						} if

					%(parse_legend: legend_number end of loop \n) print_notice legend_array pstack pop
					}
					{
					%last legend_number, no more (,)'s
					%(parse_legend: legend_number exit \n) print_notice pstack
					/legend_number exch def
					legend_number /legend_quantity exch def

					data_modifier (density) eq {draw_legend_symbol} if
					data_modifier (population) eq 
						{
						legend_quantity cvi /urban_agglomeration exch def
						az_dict /symbol_radius_enlargement_ratio undef
						test_for_drawing_population_symbol
						az_dict /symbol_radius_enlargement_ratio known
							{
							draw_legend_symbol
							} if
						} if

					%(parse_legend: legend_array \n) print_notice legend_array pstack pop
					exit	%end of legend_strings, pop null string after last search and exit
					}ifelse % (,)
				}loop % legend_number_string
			} if % (:) legend_header
		} % search found a (:) color_table
		{
			% no label, print error message
			(error: no : in data line \n) print_notice
		} ifelse % search for :
		%(parse_legend: end \n) print_notice pstack

}def %parse_legend

%--------------------------------------

/draw_city_symbol
{
	%(draw_city_symbol: \n) print_notice pstack
	% city symbol is a black filled dot
	% position on paper is already defined at entry into this routine
	/city_symbol_size atom 10 mul def
	city_color setrgbcolor
	newpath
	lat lon lat_lon2xy moveto	% city's location
	lat lon lat_lon2xy % city's x,y
	city_symbol_size	% r
	0 360 arc			% arc
	closepath fill
} def

%--------------------------------------
/parse_city % v1.1
%a city line
%on stack, the strings
%(city)(:)(Aalborg,Denmark:57.097:9.85:1:Comment)

%Note: If the city.dat file comes after the wdb files
%then the first city found dumps a whole lot stuff to stdout.
%still the city gets printed on the map, so I don't know what it's about yet.
% Joe Dec 97

{
	%(parse_city: start \n) print_notice pstack
	pop pop % (city)(:)

	(:) search
	{
		%(parse_city: city string \n) print_notice pstack
		exch pop % the (:)
		% on top of stack, city_name
		% This is of the form (town_name, country_or_state_or_county)
		% usually the country is obvious, so pop it
		city_country
		{/city_name exch def} % city_country true
		{
			%(parse_city: city and country \n) print_notice pstack
			(,) search
			{
				%(parse_city: city and country string \n) print_notice pstack
				exch pop % (:)
				/city_name exch def
				pop 	% country
			}% if (,)
			{
			/city_name exch def
			} ifelse % no (,)
		} ifelse % city_country false

		(:) search
		{
			exch pop % the ':'
			%(parse_city: location_to_lat_lon \n) print_notice pstack
			location_to_lat_lon
			%changed handling of location for v1.1.3
			%(parse_city: lat \n) print_notice pstack
			%cvr /lat exch def
			%pop % the (:)

			%(:) search	%look for lon
			%{
			%	%(parse_city: lon \n) print_notice pstack
			%	cvr /lon exch def % lon
			%	pop % (:)

				(:) search %look for font_size
				{
					%(parse_city: font_size \n) print_notice pstack
					% may be null or (hopefully not) blank
					dup dup () eq exch ( ) eq or
					{
						/city_font_size_mul 1 def
						pop pop % : and comment
					}  % if null font_size
					{
						cvr /city_font_size_mul exch def
						pop pop % : and comment
					} ifelse
						%%scale city_font_size_mul with the map,
						%% so that chars get bigger, with smaller map_scale_deg (from az_ini.ps)
				       		%city_font_size_mul
						%40 mul map_scale_deg div
						%/city_font_size_mul exch def
				} if % (:font_size)
			%} if % (:lon)
		} if % (:lat)
	%have all the info
	draw_city_symbol
	city_color setrgbcolor
	lat lon
	%(parse_city: lat lon \n) print_notice pstack
	lat_lon2xy moveto
	0 20 atom mul rmoveto 	% move up above city_symbol
	city_font findfont city_font_size city_font_size_mul mul scalefont setfont
	city_name center_show

	} % search found a (:)
	{
		% no label, print error message
		(error: no : in data line \n) print_notice
	} ifelse % search for :

}def %parse_city
%--------------------------------------
/draw_generic_dot % az_proj v1.1.6
%symbol for anything you like
%will be called with arguments of color (from list in az_ini.ps) and radius (in atoms)
%dot will have black circumference and will be filled with color
%lat/lon are known when this routine is called
%
%Some routines for drawing on the page use the lat/lon, 
%some use the x,y and some have already had "moveto" executed
%It would be nice to pick one.
%
{
	%(generic_dot: start\n) print_notice pstack

	fine_gl_width  master_line_width_factor mul setlinewidth
	lat lon lat_lon2xy 
	%(generic_dot: got here \n) print_notice pstack
	newpath		% if done after setting current point, 
	 		% stops arc from drawing line from center of circle to circumference
	generic_dot_radius 0 360 arc	% arc
	closepath 
	gsave		%save path
	generic_border_color setrgbcolor
	stroke		%draw circumference
	grestore	%restore path of border, restore color
	fill		%fill symbol
} def

%--------------------------------------
/draw_generic_square % az_proj v1.1.6
%symbol for anything you like
%will be called with arguments of color (from list in az_ini.ps) and half side/radius (in atoms)
%square will have black border and will be filled with color
%lat/lon are known when this routine is called
%
%Some routines for drawing on the page use the lat/lon, 
%some use the x,y and some have already had "moveto" executed
%It would be nice to pick one.
%
{
	%(generic_square: start\n) print_notice pstack

	fine_gl_width  master_line_width_factor mul setlinewidth
	newpath		
	lat lon lat_lon2xy moveto 
	%(generic_square: got here \n) print_notice pstack
	generic_square_halfside 0 rmoveto % moveto middle of right side

	%move around the box
	0 generic_square_halfside rlineto
	generic_square_halfside 2 mul neg 0 rlineto
	0 generic_square_halfside 2 mul neg rlineto
	generic_square_halfside 2 mul 0 rlineto
	0 generic_square_halfside rlineto

	closepath 
	gsave		%save path
	generic_border_color setrgbcolor
	stroke		%draw border
	grestore	%restore path of border, restore color
	fill		%fill symbol
} def

%--------------------------------------
/draw_generic_triangle % az_proj v1.1.6
%symbol for anything you like
%will be called with arguments of color (from list in az_ini.ps) and half side/radius (in atoms)
%triangle will have black border and will be filled with color
%lat/lon are known when this routine is called
%
%Some routines for drawing on the page use the lat/lon, 
%some use the x,y and some have already had "moveto" executed
%It would be nice to pick one.
%
{
	%(generic_triangle: start\n) print_notice pstack

	fine_gl_width  master_line_width_factor mul setlinewidth
	newpath		
	lat lon lat_lon2xy moveto 
	%(generic_triangle: got here \n) print_notice pstack
	%vertex is at 0,1.154
	%bottom corners are at +-1.0,0.577
	generic_triangle_halfside generic_triangle_halfside 0.577 mul neg rmoveto % moveto right corner

	%move around the triangle
	generic_triangle_halfside neg generic_triangle_halfside 1.154 mul rlineto % moveto top corner
	generic_triangle_halfside neg generic_triangle_halfside 1.154 mul neg rlineto % moveto left corner
	generic_triangle_halfside 2 mul 0 rlineto % moveto right corner
	closepath 
	gsave		%save path
	generic_border_color setrgbcolor
	stroke		%draw border
	grestore	%restore path of border, restore color
	fill		%fill symbol
} def

%--------------------------------------
/draw_population_center_symbol % az_proj v1.1.1
%requires radius of symbol from symbol_radius_enlargement_ratio
{
	%(draw_population_center_symbol: \n) print_notice pstack
	% population_center symbol is a (red) colored dot with a black circumference
	% position on paper is already defined at entry into this routine

	% the area of the dot proportional to the population.
	% therefore had to calculate the sqrt of the popln to get the radius
	% 10 atoms (ie 10/2000 of a page) is about the minimum sized dot

	/population_center_symbol_size atom 10 mul symbol_radius_enlargement_ratio mul def %

	%newpath
	fine_gl_width  master_line_width_factor mul setlinewidth
	population_center_symbol_circumference_color setrgbcolor
	newpath				% if done after setting current point, 
					% stops arc from drawing line from center of circle to circumference
	population_center_symbol_size	% r
	0 360 arc			% arc
	closepath 
	gsave		%save path
	population_center_symbol_fill_color setrgbcolor
	fill
	grestore	%restore path
	stroke		%draw circumference
} def

%--------------------------------------
/test_for_drawing_population_symbol
% needs urban_agglomeration (population). 
% Will determine whether to plot based on population_threshhold or map_scale_deg
% symbol_radius_enlargement_ratio will be known on exit if symbol is to be plotted
{
	
	% is this big enough to plot or do we discard this input line?
	% determine population to plot from map scale.
	% although the user enters the scale in km/cm, az_proj does its
	% calculations in degrees. 
	
	%map_scale_deg (parse_population_center: map_scale_deg \n) print_notice pstack pop
	% the scale of the map is determined by map_scale_deg
	% map_scale_deg is 	194.219925 for 2000km/cm,
	%			97.1099625 for 1000km/cm
	% the user will expect population cutoffs to be round numbers, eg 2.5M, 1M, 100k
	% we could in principle cutoff the population as a simple (continuous) function of map_scale_deg
	% but then the user will not be expecting a map with a cutoff of say 630,234 people
	% so make a table and choose cutoff from that.
	% leave ratio of popln/cutoff value on stack incase are going to plot point
	
	% remove this and see if we recreate it				
	az_dict /symbol_radius_enlargement_ratio undef
	
	% first try was to do at discrete levels
	% I then realised that since I was going to have a legend with populations and dot sizes, that I could let the program adjust in continuous steps.
	
	%urban_agglomeration 5000000 div dup 1 gt map_scale_deg 200 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 2000 km/cm and >5M people 
	%urban_agglomeration 2500000 div dup 1 gt map_scale_deg 100 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 1000 km/cm and >2.5M people 
	%urban_agglomeration 1250000 div dup 1 gt map_scale_deg 50 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 500 km/cm and >1M people 
	%urban_agglomeration 1000000 div dup 1 gt map_scale_deg 40 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 400 km/cm and >1M people 
	%urban_agglomeration 500000 div dup 1 gt map_scale_deg 20 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 200 km/cm and >0.5M people 
	%urban_agglomeration 250000 div dup 1 gt map_scale_deg 10 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 100 km/cm and >0.25M people 
	%urban_agglomeration 125000 div dup 1 gt map_scale_deg 5 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 50 km/cm and >125kpeople 
	%urban_agglomeration 100000 div dup 1 gt map_scale_deg 4 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 40 km/cm and >100kpeople 
	%urban_agglomeration 50000 div dup 1 gt map_scale_deg 2 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 20 km/cm and >50kpeople 
	%urban_agglomeration 25000 div dup 1 gt map_scale_deg 1 lt and not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse % 10 km/cm and >25kpeople 
		
	
	%plot if more than 25000 people per map_scale_deg
	%urban_agglomeration map_scale_deg div 25000 div dup 1 gt not {pop}{sqrt /symbol_radius_enlargement_ratio exch def} ifelse
	
	%test if by population_threshhold or by scale
	
	az_dict /population_threshhold known 
		{
		%(parse_population_center: plotting by population threshhold - urban_agglomeration population_threshhold \n) print_notice population_threshhold urban_agglomeration pstack pop pop
		urban_agglomeration population_threshhold ge 
			{
			%(parse_population_center: passes threshhold \n) print_notice pstack
			urban_agglomeration population_threshhold div dup 1 ge not 
				{pop}
				{
				sqrt /symbol_radius_enlargement_ratio exch def
				} ifelse
			} if % plot if OK by absolute population_threshhold
		}
		{
		%plot if more than people_per_map_scale_deg (set in az_ini.ps) currently about 50000
		urban_agglomeration map_scale_deg div people_per_map_scale_deg div dup 1 ge not
			{pop}
			{
			%(parse_population_center: population OK by map scale \n) print_notice pstack
			sqrt /symbol_radius_enlargement_ratio exch def
			} ifelse % plot if OK by scale
		} ifelse % plot by threshhold
	
} def

%--------------------------------------
/parse_population_center % for v1.1.1
%a population_center input line
%on stack, the strings
%(population_center)(:)(LUANDA::475328:-8.83:13.25:1:comment ignored by AZ_PROJ)
%
%(the following is true for "city", haven't checked for "population_center")
%Note: If the population_center.dat file comes after the wdb files
%then the first population_center found dumps a whole lot stuff to stdout.
%the population_center gets printed on the map, so I don't know what it's about yet.
% Joe Dec 97

{
	%(parse_population_center: \n) print_notice pstack
	pop pop % (population_center)(:)

	(:) search
	{
		%(parse_population_center: population_center string \n) print_notice pstack
		exch pop % the (:)
		% on top of stack, population_center_name
		% This is of the form (town_name)
		/population_center_name exch def

		% next is city population, which we are going to chuck
		(:) search
		{
			%(parse_population_center: city population \n) print_notice pstack
			exch pop % the (:)
			% on top of stack, city population
			% This is of the form (town_name)
			pop % the city population
			
			% next is population of the urban agglomeration
			(:) search		
			{
				%(parse_population_center: urban agglomeration \n) print_notice pstack
				exch pop % the (:)
				% on top of stack, urban agglomeration population string
				cvi /urban_agglomeration exch def

				test_for_drawing_population_symbol

				%did we decide to plot this one?
				az_dict /symbol_radius_enlargement_ratio known not
				{
					pop exit
				}
				{
					(:) search	% look for lat
					{
						%(parse_population_center: lat \n) print_notice pstack
						cvr /lat exch def
						pop % the (:)

						(:) search	%look for lon
						{
							%(parse_population_center: lon \n) print_notice pstack
							cvr /lon exch def % lon
							pop % (:)

							(:) search %look for font_size
							{
								%(parse_population_center: font_size \n) print_notice pstack
								% may be null or (hopefully not) blank
								dup dup () eq exch ( ) eq or
								{
									/population_center_font_size_mul 1 def
									pop pop % : and comment
								}  % if null font_size
								{
									cvr /population_center_font_size_mul exch def
									pop pop % : and comment
								} ifelse
							%%scale population_center_font_size_mul with the map,
							%% so that chars get bigger, with smaller map_scale_deg (from az_ini.ps)
					       		%population_center_font_size_mul
							%40 mul map_scale_deg div
							%/population_center_font_size_mul exch def
							} if % (:font_size)
						} if % (:lon)
					} if % (:lat)
				} ifelse % plot this point
			} if % (: urban agglomeration population)
		} if % (:city_population)		
	%have all the info
	lat lon lat_lon2xy moveto	% population_center's location
	lat lon lat_lon2xy % population_center's x,y
	draw_population_center_symbol
	population_center_font_color setrgbcolor
	lat lon
	%(parse_population_center: lat lon \n) print_notice pstack
	lat_lon2xy moveto
	0 20 atom mul rmoveto 	% move up above population_center_symbol
	population_center_font findfont population_center_font_size population_center_font_size_mul mul scalefont setfont
	population_center_name center_show

	} % search found a (:) presumably in front of (population_center)
	{
		% no label, print error message
		(error: no : in data line \n) print_notice
	} ifelse % search for :

}def %parse_population_center
%--------------------------------------
/draw_county_symbol % az_proj v1.1.6
%requires radius of symbol from symbol_radius_enlargement_ratio
{
	/symbol_radius_enlargement_ratio 1 def %fake it
	%(draw_county_symbol: x,y on stack \n) print_notice pstack
	% county symbol is a (black) colored dot with a black circumference
	% position on paper is already defined at entry into this routine

	/county_symbol_size atom 10 mul symbol_radius_enlargement_ratio mul def %

	%newpath
	fine_gl_width  master_line_width_factor mul setlinewidth
	county_symbol_circumference_color setrgbcolor
	newpath				% if done after setting current point, 
					% stops arc from drawing line from center of circle to circumference
	county_symbol_size		% radius
	0 360 arc			% arc
	closepath 
	gsave		%save path
	county_symbol_fill_color setrgbcolor
	fill
	grestore	%restore path
	stroke		%draw circumference
} def

%--------------------------------------
/parse_county
{
%there's lots of interesting info here 
%that we're just going to strip and chuck
(:) search
	{
		/county_country exch def
		pop
		%county_country (parse_county \n) print_notice pstack pop
		(:) search
		{
			/county_state exch def
			pop
			%county_state (parse_county \n) print_notice pstack pop
			(:) search
			{
				/county_state_abbreviation exch def
				pop
				%county_state_abbreviation (parse_county \n) print_notice pstack pop
				(:) search
				{
					/county_name exch def
					pop
					%county_name (parse_county \n) print_notice pstack pop
					(:) search
					{
						cvr /lat exch def
						pop 
						%lat (parse_county \n) print_notice pstack pop
						(:) search
						{
							cvr /lon exch def
							pop
							%lon (parse_county \n) print_notice pstack pop
							pop pstack % the rest of the header
							%lon lat county_name (parse_county \n) print_notice pstack pop pop pop
							%have all the info

							%don't think a symbol is needed
							%a county is an area and not a spot
							%hopefully the name will inside the area enough to tell which county it is associated with
	 						%lat lon lat_lon2xy moveto       % county's center's location
							%lat lon lat_lon2xy % county center's x,y
							%draw_county_symbol

							%draw county_name
							%scale county_font_size_mul with the map,
							%so that chars get bigger, with smaller map_scale_deg (from az_ini.ps)
							%abitary scaling (change here to make bigger/smaller)
							%in data lines like (city) this is in as a factor in the data line.
							%map_scale_deg in az_ini.ps = 50 is 4.7 by the time it gets here
							map_scale_deg 3 le
								{
								%map_scale_deg (map_scale_deg \n) print_notice pstack pop
								%county_font_size_mul bigger for bigger name
								/county_font_size_mul 2 def 
								county_font_size_mul 1 mul map_scale_deg div /county_font_size_mul exch def
								county_font findfont county_font_size county_font_size_mul mul scalefont setfont
								county_font_color setrgbcolor
								lat lon lat_lon2xy moveto
								county_name center_show	
								} if %scale is local enough
	
						} if
					} if
				} if
			} if
		} if
	} if % search for (:)
} def %parse_county

%--------------------------------------
/draw_qra_symbol
{
	%(draw_qra_symbol: \n) print_notice pstack
	% qra symbol is a black filled dot
	% position on paper is already defined at entry into this routine
	/qra_symbol_size atom 10 mul def
      	qra_symbol_color setrgbcolor  % color in az_ini.ps
	%black setrgbcolor
	newpath
	lat lon lat_lon2xy moveto	% qra's location
	lat lon lat_lon2xy % qra's x,y
	qra_symbol_size	% r
	0 360 arc			% arc
	closepath fill
} def
%--------------------------------------
/string_2_array
	{
	% on stack, string like ( 0 0 0 0 0 )
	% at return on stack array like [ 0 0 0 0 0 ]

		[ exch % push a start of array mark below the stringified version of the array
		{
			%(string_2_array before token \n) print_notice pstack 
			token
			%(string_2_array after token \n) print_notice pstack 
			%if token finds something, it leaves true on top of stack
			not {exit} if
			% push the elevation number (now an int) below the string
			exch
		} loop %more numbers in string
		]

	%(string_2_array on exit \n) print_notice pstack 
	} def
%--------------------------------------
/parse_data_type
%line on stack like (repeater)(:)(147.105+   NV3Z      FM18rx	100	270)
{
	{
		%(parse_data_type: start \n) print_notice pstack
		dup (grid) eq %grid squares, version2, needs AZ_PROJ v1.04
		%
		% a typical grid.dat line is
		% grid-modifier:50:F2:FM19:comment field ignored by AZ_PROJ
		% where -
		% grid: symbol to show that following data is a worked grid
		% modifier: see above explanation
		% 50: band the grid was worked on
		% F2: propagation mode, F2, Es, EME, Au, Ms, TEP, or unknown ()
		% FM19 grid worked
		% comment field of anything at all (ignored for plotting)
%
		% at this stage the line is parsed to
		% (grid)(:)(50:F2:FM19:comment field)

		{
			pop pop	% (grid) (:)
			%(parse_data_type: grid \n) print_notice pstack
			%pstack

			%special handling if data_modifier==density
			az_dict /data_modifier known
			{
			data_modifier (density) eq
				{
				%(parse_data_type: data_modifier is density \n) print_notice data_modifier pstack pop
				%for (density) an extra field (at the moment contains the number of OM's in the grid) is in the data line
				(:) search
					{
					exch pop % (:)
					/legend_quantity exch def
					%(parse_data_type: legend_quantity \n) print_notice legend_quantity pstack pop
					} if %(:)
				}if %data_modifier == density

			data_modifier (etopo5) eq
				{
				%(parse_data_type: data_modifier is etopo5 \n) print_notice data_modifier pstack pop
				%orig data was
				%grid-etopo5:PN23aw:      0      0      0      0      0      0      0      0      0      0      0      0
				%now have 
				%(PN23aw:      0      0      0      0      0      0      0      0      0      0      0      0)
				(:) search
					{
					exch pop % (:)
					/etopo5_grid_square exch def
					%(parse_data_type: etopo5 grid_square \n) print_notice etopo5_grid_square pstack pop
					%data on stack as string of elevation data eg ( 0 0 0 ... 0 )
					string_2_array 

					/elevation_array exch def

					%(parse_data_type: elevation_array \n) print_notice elevation_array pstack pop
					etopo5_grid_square grid_to_lat_lon
					%a 5 min square is 2 6char gridsquares
					lat_incr 2 mul /lat_incr exch def
					%(etopo5 lat lon \n) print_notice lat_start lon_start lat lon lat_incr lon_incr pstack pop pop pop pop pop pop
					
					0 1 11
						{
						/temp exch def
						elevation_array temp get /legend_quantity exch def
						%set colors according to modifiers
						%worked_grid_square_color setrgbcolor % default
						set_grid_box_color
						%kludge, dont draw anything if elevation_array == 0
						%the alternative is to draw white, 
						%which will obliterate what's under it 
						%(there is no transparent in postscript)
						0 legend_quantity lt {draw_grid_box} if
						lon_start 1 12 div add /lon_start exch def
						} for 
					exit
					black setrgbcolor
					} if %(:)
				}if %data_modifier == etopo5

			}if %data_modifier known


			(:) search
			{
				%(parse_data_type: band \n) print_notice pstack
				%band can be a zero length string
				%unlike other languages where a zero length string is a string
				%Postscript regards this string as undefined and attempts to test for it will crash
				%cvi /band exch def	%used to convert to integer, now can be a null or string too
				/band exch def
				pop % the `:'
				%
				%(parse_data_type: extracted band \n) print_notice band pstack pop
				%On top of stack is a string like (Au:FN09:comment)
				%if the entry is plotted, it will be popped off the stack
				%if not plotted, it will not be popped off the stack
				%we have to arrange to pop it, even if it isn't plotted
				%put a "mark" underneath it on the stack
				mark exch
				%(parse_data_type: draw grid square - mark \n) print_notice pstack 
				%band can be null () or a string (10, 10G, 2.3)
				%it will be matched against strings in /bands_plotted (az_ini.ps or your config file)
				%ignore_band is set in az_ini.ps
				%if it is set and the data_modifier is 
				%the frequency indept density or etop5 type
				%then plot the gridsquare anyhow, ignoring the freq
				%(for etopo5 and density, the freq field can be null)

				%for other data_modifiers, plot by freq (ie ignore ignore_band)

				%logic is wierd here as postscript doesn't shortcircuit evaluate the conditional.
				%have 3 types of data_modifier
					%known - etopo5/density
					%known - other types, eg qso
					%unknown
				%have 6 way truth table here
				%so you have to test if data_modifier is known before you test for the data_modifier type
				/freq_ignored false def

				az_dict /data_modifier known
				{
					ignore_band
					data_modifier (density) eq 
					data_modifier (etopo5) eq or 
					and
					{
						% plot gridsquare if it's (etopo5 or density) and ignore_band is true
						%(parse_data_type: draw grid square - ignore_band \n) print_notice band pstack pop
						/freq_ignored true def 
						draw_worked_grid_square
						%(parse_data_type: draw grid square - after ignore_band \n) print_notice band pstack pop
					} if % is etopo5 or density	
				}if %data_modifier known

				
				freq_ignored not
				{
					bands_plotted
					{
						dup (*) eq exch % wild card in /bands_plotted?
						band eq or
						() band eq or
						{
							%(parse_data_type: draw grid square - band \r) print_notice band pstack pop
							draw_worked_grid_square
						}
						{
							%(parse_data_type: don't draw grid square - band \n) print_notice band pstack pop
						}ifelse % this band
					} forall % entries in /bands_plotted
				}if % datatype to be checked for freq
				%(parse_data_type: draw grid square - exit mark \n) print_notice pstack 
				cleartomark
			} %if % search found a `:'
			{
				(parse_data_type: no ':' found - data_modifier \n) print_notice data_modifier pstack pop
				pop % chuck the line 
			} ifelse % search found a ':'
			az_dict /band undef
			exit
		} if % grid

		%If we get here, we have found a .dat file which is not
		%a worked grid dat file (grid.dat). This is one of the
		%places where we can draw grid square labels and borders.
		%Did we choose to do so?

		grid_square_labels_on_paper
		not
		draw_grid_square_borders_and_labels_before_regular_dat_files
		and
		{
			draw_compass_distance_lines_grid_square_labels_borders_outer_border
			/grid_square_labels_on_paper true def
		}if 	% we haven't already drawn the labels
			% and we want to do it before drawing .dat file data

		dup (annotate) eq
		{
			%(parse_data_type: annotation comment \n) print_notice pstack
			% is there a `annotate' before the `:'
			% then the line is an annotation
			% (annotate) is on top of stack
			% (:) is next
			% (the whole annotation string) is next
			pop pop
			%(annotation \r) print_notice pstack
			%(annotation \r) print_notice
			%(annotation \n) print_notice pstack
			extract_annotation
			exit
		} if % annotate

		dup (city) eq
		{
			%(parse_data_type: city comment \n) print_notice pstack
			% is there a `city' before the `:'
			% then the line is an city
			% (city) is on top of stack
			% (:) is next
			% (the whole city string) is next
			%pop pop
			%(city \r) print_notice pstack
			%(city \r) print_notice
			parse_city
			exit
		} if % city

		dup (population_center) eq
		{
			%(parse_data_type: population_center \n) print_notice pstack
			% is there a `population_center' before the `:'
			% then the line is an population_center
			% (population_center) is on top of stack
			% (:) is next
			% (the whole population_center string) is next
			%pop pop
			%(population_center \r) print_notice pstack
			%(population_center \r) print_notice
			parse_population_center
			exit
		} if % population_center


		dup (AM) eq %AM Broadcast station 550-1630kHz, needs AZ_PROJ v1.04
		{parse_transmitter} if % AM

		dup (BC) eq %BC Broadcast station 550-1630kHz, needs AZ_PROJ v1.04
		{parse_transmitter} if % BC

		dup (FM) eq %FM Broadcast station 88-108MHz, needs AZ_PROJ v1.04
		{parse_transmitter} if % FM

		dup (TV) eq %TV Broadcast station, needs AZ_PROJ v1.04
		{parse_transmitter} if % TV

		dup (beacon) eq
		{
			%(parse_data_type: beacon \n) print_notice
			parse_transmitter
			%should there be an "exit" here?
			%exit
		}if % beacon

%		dup (BEACON) eq
%		{
%			pop pop
%			/beacon_color {beacon_special_color} def
%			/mark_beacon {beacon_special} def
%			(BEACON \r) print_notice
%			extract_beacon
%			exit
%		} if % BEACON

		dup (county) eq
		{
			%county header
			%only data for US at the moment
			%counties are headers with name information 
			%and the location of the center of the county (for labelling)
			pop pop
			%(county \n) print_notice pstack
			parse_county
			exit
		} if % county

		dup (dxcc) eq
		{
			% dxcc country
			pop pop
			%pstack
			/dxcc_line exch def	%going to hack this line, need to be able to recover original later
			/big_D false def
			(dxcc \r) print_notice
			dxcc_special_country
			extract_band_mode
			exit
		} if % dxcc

		dup (DXCC) eq
		{
			% dxcc special country
			pop pop
			/dxcc_line exch def	%going to hack this line, need to be able to recover original later
			/big_D true def
			(DXCC \r) print_notice
			dxcc_special_country_2
			extract_band_mode
			exit
		} if % DXCC


		dup (label) eq
		{
			%(parse_data_type: label \n) print_notice pstack
			% (label) is on top of stack
			% (:) is next
			% (string:lat:lon:font_size:comment) is next
			%(label \r) print_notice pstack
			%(label \r) print_notice
			%(label \n) print_notice pstack
			parse_label
			exit
		} if % label

		dup (legend) eq
		{

			% on stack, a string of type
			% (legend)(:)(density:QRA density:1:22:333:;comment ignored by AZ_PROJ)
			%(parse_data_type: legend \n) print_notice pstack
			gsave
			%legend is in page space, not map space
			move_to_pagespace
			parse_legend
			grestore
			exit
		} if % legend

		dup (mountain) eq %
		{
			pop pop
			% on stack - a string of the type "Mt. Kearsarge:FN43bj:1500m:"
			/info_on_other_guy off def % must be defined
			mountain_symbol_color setrgbcolor  % color in az_ini.ps
			%(parse_data_type: mountain detected \n) print_notice pstack
			%(mountain \r) print_notice
			draw_mountain
			%(parse_data_type: mountain drawn \n) print_notice pstack
			exit
		} if % mountain


		dup (MOUNTAIN) eq %
		{
			pop pop
			/info_on_other_guy on def
			% on stack - a string of the type "Mt. Kearsarge:FN43bj:1500m:"
			mountain_symbol_special_color setrgbcolor  % color in az_ini.ps
			%(parse_data_type: MOUNTAIN detected \n) print_notice pstack
			%(MOUNTAIN \r) print_notice
			draw_mountain
			%(parse_data_type: MOUNTAIN drawn \n) print_notice pstack
			/info_on_other_guy off def
			exit
		} if % mountain

		dup (qra) eq %
		% line format is
		% qra:50:1A0KM:JN61:comment

		{
			pop pop
			% on stack - a string of the type "50:1A0KM:JN61:comment"
			%(parse_data_type: qra detected \n) print_notice pstack
			(:) search
			{
				%cvi /band exch def
				%now string Jun 99
				/band exch def
				pop % the `:'

				%On top of stack is a string like
				% (1A0KM:JN61:comment)
				%if the entry is plotted, it will be popped off the stack
				%if not plotted, it will not be popped off the stack
				%we have to arrange to pop it, even if it isn't plotted
				%put a "mark" underneath it on the stack
				mark exch
				bands_plotted
				{
					dup band eq exch (*) eq or
					{
						%(going to subroutine \n) print_notice
						%(qra: \r) print_notice
						draw_qra
					} if % this band
				} forall % bands
				cleartomark
			} if % search found a `:'
			%(parse_data_type: qra drawn \n) print_notice pstack
			exit
		} if % qra

		dup (qso) eq %qso
		% line format is
		% qso:50:w3abc:EM85:n2xy:FN00

		{
			%(found qso \n) print_notice pstack

			pop pop
			(:) search
			{
				%cvi /band exch def
				%band is now a string
				/band exch def
				pop % the `:'

				%On top of stack is a string like
				% (144::AD00::AM00:comment)
				%if the entry is plotted, it will be popped off the stack
				%if not plotted, it will not be popped off the stack
				%we have to arrange to pop it, even if it isn't plotted
				%put a "mark" underneath it on the stack
				mark exch
				bands_plotted
				{
					dup band eq exch (*) eq or
					{
						%(going to subroutine \n) print_notice
						%(qso \r) print_notice
						draw_qso
					} % this band
					{
						%(qso not this band \n) print_notice pstack
					} ifelse % not this band
				} forall % bands
				cleartomark
			} if % search found a `:'
			exit
		} if % qso

		dup (qth) eq %qth, v1.04

		% line format is
		% qth-n:fm19gq
		% where n is 1-n, qth-0 is defined to be the center of the projection
		% on stack (qth)(:)(grid_locator)
		% in addition, data_modifier will have a value of 1-n
		% currently n is coded to 9

		{
			pop pop % (:)
			% on stack (grid_locator:comment string)
			%(parse_data_type/qth: found qth type \n) print_notice data_modifier pstack pop

			(:) search
			{
				exch pop
				/grid_locator_qth exch def
				pop % the comment string
				%(parse_data_type/qth: grid_locator_qth data_modifier \n) print_notice grid_locator_qth data_modifier pstack pop pop
				{
					%(parse_data_type/qth: grid_locator_qth data_modifier \n) print_notice grid_locator_qth data_modifier pstack pop pop
					grid_locator_qth
					data_modifier (1) eq
					{
						/grid_locator_qth_1 exch def
						%(parse_data_type: grid_locator_qth_1 \n) print_notice grid_locator_qth_1 pstack pop
						exit
					} if
					data_modifier (2) eq {/grid_locator_qth_2 exch def exit} if
					data_modifier (3) eq {/grid_locator_qth_3 exch def exit} if
					data_modifier (4) eq {/grid_locator_qth_4 exch def exit} if
					data_modifier (5) eq {/grid_locator_qth_5 exch def exit} if
					data_modifier (6) eq {/grid_locator_qth_6 exch def exit} if
					data_modifier (7) eq {/grid_locator_qth_7 exch def exit} if
					data_modifier (8) eq {/grid_locator_qth_8 exch def exit} if
					data_modifier (9) eq {/grid_locator_qth_9 exch def exit} if
					%(parse_data_type: unknown qth data_modifier \n) print_notice data_modifier pstack pop
				} loop
			} if % (:) found
		%(parse_data_type/qth: grid_locator_qth_1 exit \n) print_notice grid_locator_qth_1 pstack pop
		exit
		} if % qth

		%code for v1.04
		dup (repeater) eq
		{parse_transmitter} if % repeater

%		dup (REPEATER) eq
%		{
%			pop pop
%			/repeater_color {repeater_special_color} def
%			/mark_repeater {repeater_special} def
%			(REPEATER \r) print_notice
%			extract_repeater
%			exit
%		} if %REPEATER


		%code for v1.04
		dup (rover) eq	{parse_transmitter} if % rover

		dup (token) eq % reading a token line
		%this allows putting a postscript instruction
		%(such as changing the color) into a data file
		%I haven't found anything useful to do with this yet JM Jul 96
		{
			pop pop
			%(found token \n) print_notice pstack
			% on stack - a string of the type (red setrgbcolor)
			token
				{
					%(found token \n) print_notice pstack
					cvx exec pop
				}if
			exit
		} if % token



		% If loop falls through to here, then this line is an unknown data type
		(Error: unknown data type: ) print pstack pop pop pop exit

	} loop % look for data types (repeaters, beacons etc)
}def

%--------------------------------------
% Get each line until EOF
%
%/linebuf 1024 string def
/linebuf 256 string def			% 256 makes debugging dumps easier to handle - Joe

/line_cnt 0 def

/get_line
{
	{
		%(get_line: newfile \n) print_notice pstack

		% loop until we run out of file names
		next_file not
		{
			%(next_file not \n) print_notice
			Termination
			exit
		} if %not next_file

		%(pre BigBang \n) print_notice
		/BigBang save def	% Snapshot of memory state saved at each file
					% saved state is stored as BigBang
					% When we restore VM goes back to its
					% condition at 'BigBang'

		{

			%(get_line: about to readline \n) print_notice pstack
			data_file linebuf readline
			{
				{
					%(get_line: line found \n) print_notice pstack
					(%) anchorsearch % looking for (%) at start of line - ie comment
					{
						%(get_line: found line with % \n) print_notice pstack
						pop % (%)
						%found comment line - ignore
						%pstack (comment \n) print
						pop % rest of comment
						%pop % original copy of comment
						%pstack (comment \n) print
						exit
					}if % (%) found at start of line

					($GP) anchorsearch % looking for ($GP) at start of line - ie GPS NMEA data
					{
						pop % $GP string
						%found NMEA data
						%pstack (NMEA line \n) print
						parse_nmea_data
						%pop %original copy of string that was duplicated
						exit
					}	if % ($) found at start of line

					%default of case like statement
					%{
						%pop % remove dup'ed copy of line
						%(get_line: non comment \n) print
						% line does not start with (%)
						% does it have a (:) in the line?
						% if the input line contains a ':' we treat the line as special text -
						% eg annotation, beacon, dxcc, ...
						% if no (:) we treat the line as a path line.
						% Thus we can concatonate the path (wdb) and the test files
						% and pass them as one stream of standard input

						(:) search
						{
							%(get_line: line with ":" \n) print_notice pstack
							% there is a (:) in the line
							% on stack (data_type)(:)(data)
							% in v1.04 data_type can have modifiers
							% eg grid-l, is a "grid" type with the "l" modifier
							(-) search
							{
								%(get_line: modifier found \n) print_notice pstack
								3 1 roll
								pop % the (-)
								%(get_line: modifier \n) print_notice pstack
								/data_modifier exch def
								%(get_line: data_modifier \n) print_notice data_modifier pstack pop
								% data_type is left on stack
							} % if data_modifier found
							{
								%() /data_modifier exch def
								az_dict /data_modifier undef
							} ifelse % no data_modifier
							%(get_line: modifiers parsed \n) print_notice pstack
							parse_data_type
							az_dict /data_modifier known {az_dict /data_modifier undef}if

						} % search finds (:)
						{
							% default assumes a wdb map line
							%(get_line: wdb map line \n) print_notice pstack
							%we've found a map line,
							%if we haven't printed the grid square borders etc
							%then check if we're supposed to.

							grid_square_labels_on_paper
							not
							draw_grid_square_borders_and_labels_before_maps
							and
								{
								%(grid_square_labels_on_paper) pstack pop
								draw_compass_distance_lines_grid_square_labels_borders_outer_border
								/grid_square_labels_on_paper true def
								%if we just change /grid_square_labels_on_paper here it will
								%be blown away by the restore below, so push it on the stack
								%before restoring (see restore below)
								}if % we haven't already drawn the labels
										% and we want to do it before drawing .wdb file data

							%(get_line: about to extract_coord \n) print_notice pstack
							% on stack a string of type
							% ( integer lat lon      )
							% where the integer is either a wdb number (>1000) or else the resolution of the map point (1..5)
							dup 1 5 getinterval cvi
						    	dup 5 gt	{
									pop % is wdb_path
									/resolution 5 def % set first point to lowest resolution so it's always included
									extract_coord
									}
									{
									/resolution exch def
									%(get_line: resolution \n) print_notice resolution map_scale_km pstack pop pop
									% is the scale fine enough for a point of this resoltion to be drawn?
									resolution 5 ge map_scale_km scale_to_include_resolution_5 le and
									resolution 4 ge map_scale_km scale_to_include_resolution_4 le and or
									resolution 3 ge map_scale_km scale_to_include_resolution_3 le and or
									resolution 2 ge map_scale_km scale_to_include_resolution_2 le and or
									resolution 1 ge map_scale_km scale_to_include_resolution_1 le and or
										{
										%(get_line: resolution \n) print_notice resolution map_scale_km pstack pop pop
										extract_coord
										}{
										%(get_line: point too high resolution for this scale \n) print_notice pstack
										pop % line
										} ifelse
									} ifelse

						} ifelse % no (:) presumably is wdb file
					exit
					%} ifelse % no (%) at start of line - normal data line
%	%				line_cnt 500 ge
%	%				{
						% We recover memory after 500 paths (not input lines)
						% We don't realise that we have exceeded our quota of
						% paths until the beginning of the next path, so we
						% need to save that first point of the (next) path from
						% being destroyed


%	%					0 ini 0 lat 0 lon

%	%					%push the name /grid_square_labels_on_paper on the stack
%	%					/grid_square_labels_on_paper
%	%					%then its value
%	%					grid_square_labels_on_paper
%	%					%then restore (which doesn't change the stack)
%	%					BigBang restore
%	%					%then pop the value off the stack
%	%					def
%	%					/BigBang save def
%	%					[ 4 1 roll ] coord 0 3 -1 roll put /i 1 def
%	%					/line_cnt 0 def
%	%				} if %line_cnt > 500
				}loop
			}% if of ifelse of input line
			{
				clear exit
			} ifelse %no input line
		} loop % readline
		coord 0 get null ne
		{
			%(get_line: about to crunch_path \n) print_notice
			crunch_path
		} if

		%To recover variables from inside the save/restore loop
		%you have to push the value and name on the stack
		%then restore (which doesn't affect the stack)
		%then def after the restore

		%Check
		%(Before restore \n) print_notice
		%waypoint_distance = (waypoint_distance \n) print_notice
		%waypoint_bearing = (waypoint_bearing \n) print_notice
		%hour = (BWC_hour \n) print_notice
		%minute = (BWC_min \n) print_notice
		%lat_QTH = (lat_QTH \n) print_notice
		%lon_QTH = (lon_QTH \n) print_notice
		%grid_square_labels_on_paper	= (grid_square_labels_on_paper \n) print_notice

		/grid_square_labels_on_paper	%push the variable name on the stack
		grid_square_labels_on_paper	%then its value
		/lat_QTH lat_QTH		%similarly
		/lon_QTH lon_QTH
		/hour hour
		%/minute minute

		BigBang restore			%then restore (which doesn't change the stack)
		def def def def
		%def def def

		%Check
		%(After restore \n) print_notice
		%hour = (hour \n) print_notice
		%minute = (minute \n) print_notice
		%lat_QTH = (lat_QTH \n) print_notice
		%lon_QTH = (lon_QTH \n) print_notice
		%grid_square_labels_on_paper = (grid_square_labels_on_paper \n) print_notice

	} loop % get_line

az_dict /minute undef
} def % get_line



%--------------------------------------
/check_for_greyline
{

draw_greyline_by_timedate
	{
	calculate_sun_position
	az_dict /sun_lat known
	az_dict /sun_lon known
	and
		{
		draw_sun_symbol
		greyline
		}
		{
			% date/time/sun_lat/sun_lon not entered in az_ini.ps
			% or no NMEA.DAT file
			(Greyline: sun_lat and/or sun_lon info can't be calculated \n) print_notice
		}ifelse % sun_lat, sun_lon not found
	} if

}def

%--------------------------------------
/draw_compass_distance_lines_grid_square_labels_borders_outer_border

{
mark

%lat_QTH = (lat_QTH draw_compass... \n) print_notice
%lon_QTH = (lon_QTH draw_compass... \n) print_notice


/ground_state save def
		% We can reclaim a lot of VMemory after the preliminaries are over
		% A lot of memory is used up in the Letter/Number grid routines

grid_locator_labelling_style (az_proj) eq
	{
	% setup distances to position and size labels

	%letters
	%used in /grid_locator_letters_show
	/grid_locator_letter_square_lon_offset 4 def 
		% letter square labels are offset in lat 
		% 4 deg to left and right of center of square

	%used in /grid_locator_letter_font_scale
	%empirical factor to get font right size
	/grid_locator_letter_font_scale_fudge_factor 45 def

	%numbers
	%used in /grid_locator_numbers_show
	/grid_locator_number_square_lon_offset 0.4 def 
		% letter square labels are offset in lat 
		% 4 deg to left and right of center of square

	%used in /grid_locator_number_font_scale
	%empirical factor to get font right size
	/grid_locator_number_font_scale_fudge_factor 1 def

	/grid_locator_number_square_lat_center 0.5 def
	/grid_locator_number_square_lon_center 1 def

	} if


grid_locator_labelling_style (arrl) eq
	{
	% setup distances to position and size labels

	%used in /grid_locator_letters_show
	/grid_locator_letter_square_lon_offset 1 def 
		% letter square labels are offset in lon 
		% 1 deg to left and right of center of square

	%used in /grid_locator_letter_font_scale
	%empirical factor to get font right size
	%/grid_locator_letter_font_scale_fudge_factor 5 def
	/grid_locator_letter_font_scale_fudge_factor 10 def


	%numbers
	%used in /grid_locator_numbers_show
	/grid_locator_number_square_lon_offset 0.2 def 
		% letter square labels are offset in lat 
		% 4 deg to left and right of center of square

	%used in /grid_locator_number_font_scale
	%empirical factor to get font right size
	%is based on grid_locator_letter_font_scale_fudge_factor
	%if you decrease that number, then the ..number_font size will decrease by the same amount
	/grid_locator_number_font_scale_fudge_factor 4 def

	% location of letters is different in "down under" mode
	orientation dup (orthographic-portrait) eq exch (orthographic-landscape) eq or
		{
		%down under mode

		%(draw_compass_distance_lines_grid_square_labels_borders_outer_border: arrl mode \n) print_notice pstack
		/grid_locator_number_square_lat_center 0.75 def
		/grid_locator_number_square_lon_center 1.5 def
		}
		{
		%northern hemisphere mode
		/grid_locator_number_square_lat_center 0.25 def
		/grid_locator_number_square_lon_center 0.5 def
		} ifelse

	} if


draw_lat_lon_lines
	{
	%lat_lon lines are drawn by /draw_letter_square_borders
	%but at a spacing of /alternate_lat_spacing /alternate_lon_spacing
	/draw_letter_square_borders on	def

	% if drawing lat/lon lines,
	% then have to turn a few other things off
	/draw_letter_square_labels  off	def
	/draw_number_square_borders off	def
	/draw_number_square_labels  off	def
	} if


%draw_number_square_borders map_scale_deg number_square_turnoff lt and
draw_number_square_borders
	{
		% 0.2 x 0.1 deg lat, lon lines
		grid_locator_fine
	} if

%draw_number_square_labels map_scale_deg number_square_turnoff lt and
draw_number_square_labels
	{
		% labels for 0.2 x 0.1 lines
		grid_locator_numbers_show
	} if

draw_letter_square_borders
	{
		% 2 x 1 deg lat, lon lines
		%save
		grid_locator_coarse
		%restore
	} if

draw_letter_square_labels
	{
		% labels for 2 x 1 deg lines
		grid_locator_letters_show
	} if

distance_circles (distance_circles \n) print_notice pstack pop
draw_compass_circumference (draw_compass_circumference \n) print_notice pstack pop
draw_compass_spokes (draw_compass_spokes \n) print_notice pstack pop
distance_circles (none) eq
	{
		%kludge to turn off all compasses, distance cirles, and spokes.
		%in the standalone version, I let people turn all of these on and off independantly.
		%In the server version people only have the choice of none, distance circles or compasses.
		%the "none" choice has not been available in one command before 
		%(you had to turn everything off one at a time).
		
		% if all_circles is false then turn everything off
		% otherwise let through whatever is on
		% note that having distance_circles on, turns off some of the compass stuff

		/draw_compass_circumference 	off def
		/draw_compass_spokes		off def
		/distance_circles		off def
		
	} if

distance_circles (distance_circles) eq
	{	
		%draw distance circles
		distances_plotted
		{
			draw_distance_circles
		} forall % circle distances
		% rad is calculated in draw_distance_circles
		% unless of course you've left the array distances_plotted empty
		% and you aren't plotting anything at all

		az_dict /rad known
		{
			%draw_spokes

			rad compass_rose
			rad label_compass_directions
			/draw_compass_circumference	off def
			/draw_compass_spokes		off def
		} if

		% run this a second time so that distance labels
		% are replotted after drawing spokes just above
		distances_plotted
		{
			draw_distance_circles
		} forall % circle distances
		% rad is calculated in draw_distance_circles
		% unless of course you've left the array distances_plotted empty
		% and you aren't plotting anything at all
	} if

%mess :-(
%originally had a compass with the option of drawing the circumference, and/or the spokes.
%Then I added distance circles.
%I determined which to run by looking at distances_circles. 
%if it was false, I drew the compass (and then looked at draw_compass_circumference and
%draw_compass_spokes to determine which part of the compass to draw).
%The was acceptable when configuring by editing az_ini.ps
%Now I would like the server to offer none, compass or distance_circles.
%This means I need a 3 value (rather than true/false for distance_circles)
  
distance_circles (compass) eq
	{
	%draw_compass_spokes draw_compass_circumference distance_circles (draw_compass_distance_lines_grid_square_labels_borders_outer_border: draw_compass_circumference on: distance_circles draw_compass_circumference draw_compass_spokes \n) print_notice pstack pop pop pop
	%draw compass rose and optionally compass spokes

	% Must draw spokes before circumference,
	% as circumference routine labels the directions.
	% The numbers in the direction labels
	% will be covered by the spokes if the spokes are drawn afterwards.

	%however won't know rad till circumference is drawn.
	%so draw circumference, then spokes, then circumference again.
	draw_compass_circumference {draw_bearing_rose} if

	%v1.1.6beta4, fix bug in beta3 server version from WN7T, 
	%who couldn't generate a compass in the long form 
	%(but could in the short form - where it's the default).
	% This compass logic is buggy.

	%just incase drawing spokes to antipodes with no compass circumference
	%draw_compass_spokes compass_spokes_to_antipodes and
	draw_compass_spokes
	{
		draw_spokes
		/draw_compass_spokes off def
	} if

	%in v1.1beta13 changed to draw circumference as well.
	%if draw_compass_spokes true but draw_compass_circumference false.
	%currently the spokes will not be drawn unless draw_compass_circumference is true.
	%this change allows someone on the server site to turn on
	%only just draw_compass_spokes and still get a compass
	%draw_compass_circumference {draw_bearing_rose} if
	%draw_compass_circumference draw_compass_spokes or {draw_bearing_rose} if
	%so if we get here we have to draw the rose
	
	%hmm (4 Jan 2001), bug report from Jonathon G4KLX/HB9DRD
	%can't turn off compass rose with /draw_compass_circumference off def
	%old
	%draw_bearing_rose
	%new
	draw_compass_circumference {draw_bearing_rose} if


	%draw_compass_spokes {draw_spokes} if

	%draw_compass_circumference
	%	{
	%		(draw_compass_circumference \n) print_notice
	%		rad label_compass_directions
	%	} if

	%draw_compass_circumference {rad label_compass_directions } if

	} if


calculate_sunrise_sunset
draw_analemma {analemma} if

% circular border representing the antipodes
%draw edge of the world whether it is off scale or not
draw_outer_border {outer_border} if

% draw a little vertical cross (+) at QTH
QTH_marker
	{
	red setrgbcolor
	QTH_marker_gl_width master_line_width_factor mul setlinewidth
	0 1 3
		{
		newpath
		%apparently we're at 0 0 already, I guess it's been so long ago that I wrote this stuff that I'd forgotten
		%lat_QTH lon_QTH lat_lon2xy moveto

		0 0 moveto
		%(X) show
		0 atom mul 20 atom mul rmoveto
		0 atom mul 40 atom mul rlineto
		stroke
		90 rotate
		}for % all directions
	}if %QTH_marker

ground_state restore	% return memory to the earlier state
cleartomark
} def

%--------------------------------------

/Termination
{

	grid_square_labels_on_paper
	not
	{
		draw_compass_distance_lines_grid_square_labels_borders_outer_border
	}if % we haven't already drawn the labels
	/grid_square_labels_on_paper false def 	%just in case we add a routine after termination
						%conceptually this seems difficult to do, 
						%but I'd better be ready - someone will want it.
						%(you could put the code after the get_line instruction).

	% The title (across the top of the page) and the copyright stuff (at the bottom left)
	% can be covered up by the night time area and/or some random piece of the map
	% they're redrawn here, in case this has happened
	% well why draw these labels twice? Well the labels appearing
	% early in the drawing of the picture help to make sure I'm
	% drawing the right map without having to wait till the end.


	gsave
	move_to_pagespace
	label_scale	%relabel at end of run
	grestore



	pstack		% This is a 'heads up', since there should not be
						% any garbage on the stack.
	%(elapsed time = ) print_notice
	%usertime starttime sub 1000 div 10 string cvs print_notice
	%( seconds ) =
	(Cleaning up (will take a while if generating printer file).\n) print_notice pstack
	showpage
		% do whatever we do at EOF
} def

%--------------------------------------

/label_scale
{

	newpath
	black setrgbcolor

	az_dict /Title known
		{
		/Helvetica findfont footer_label_height 2 mul scalefont setfont
		%header_label_height in az_ini.ps
		0 half_height header_label_height sub moveto
		Title
		stringwidth pop 2 div neg 0 rmoveto
		Title show


		%This modification was needed when I wanted to
		%make a Title by overlaying words in different colors
		%
		% The strings I used in az_ini.ps were

		%/Title  (6m      and      Contacts by W3EP)	def
		%/Title2 (     Es                                          )	def
		%/Title3 (           F2                        )	def

		%0 half_height footer_label_height 3 mul sub moveto
		%red setrgbcolor
		%Title2
		%stringwidth pop 2 div neg 0 rmoveto
		%Title2 show

		%0 half_height footer_label_height 3 mul sub moveto
		%lightblue setrgbcolor
		%Title3
		%stringwidth pop 2 div neg 0 rmoveto
		%Title3 show

		%black setrgbcolor

		az_dict /Title1 known
			{
			0 half_height footer_label_height 8 mul sub moveto
			red setrgbcolor
			Title1
			stringwidth pop 2 div neg 0 rmoveto
			Title1 show

			black setrgbcolor
			}if % Title1

		az_dict /Title2 known
			{
			0 half_height footer_label_height 8 mul sub moveto
			yellow setrgbcolor
			Title2
			stringwidth pop 2 div neg 0 rmoveto
			Title2 show

			black setrgbcolor
			}if % Title2

		az_dict /Title3 known
			{
			0 half_height footer_label_height 8 mul sub moveto
			green setrgbcolor
			Title3
			stringwidth pop 2 div neg 0 rmoveto
			Title3 show

			black setrgbcolor
			}if % Title3

		az_dict /Title4 known
			{
			0 half_height footer_label_height 8 mul sub moveto
			cyan setrgbcolor
			Title4
			stringwidth pop 2 div neg 0 rmoveto
			Title4 show

			black setrgbcolor
			}if % Title4

		az_dict /Title5 known
			{
			0 half_height footer_label_height 8 mul sub moveto
			black setrgbcolor
			Title5
			stringwidth pop 2 div neg 0 rmoveto
			Title5 show

			black setrgbcolor
			}if % Title5

		} if


	/Helvetica findfont header_label_height scalefont setfont
	half_width neg 8 add	half_height footer_label_height 7 mul sub neg moveto
	currentpoint (How far is it from Amsterdam Version 0.1) show

	/Helvetica findfont footer_label_height scalefont setfont

        greymedium setrgbcolor

	footer_label_height 1 mul sub moveto currentpoint (Azimuthal Equidistant Projection from ) show QTH_name show

%	footer_label_height sub moveto currentpoint (From ) show QTH_name show

	%footer_label_height 2 mul sub moveto currentpoint (Radial scale: ) show

	footer_label_height 1 mul sub moveto currentpoint (Radial scale: ) show
	map_scale_deg short_side_in_cm div 90 div 10000 mul
	0.5 add				% for roundoff error
	cvi 10 string cvs show
	(km/cm) show
	
	footer_label_height 1 mul sub moveto currentpoint
        darkblue setrgbcolor

	(Find your location, and using the concentric red circles as a reference,) show 
	footer_label_height 1 mul sub moveto currentpoint
	(determine your distance from Cape Town) show 
	%(foo)show 

        black setrgbcolor
	/Helvetica findfont footer_label_height 1.1 mul scalefont setfont
	footer_label_height 1.2 mul sub moveto

%	(AZ_PROJ v1.1.6beta4, Jun 2001, (C) 1994-2001 Joseph Mack NA3T, Michael Katzmann NV3Z) show
	(Created using AZ_PROJ by Daniel M German (dmg@uvic.ca). Dec 2015a) show

}def

%--------------------------------------

/setup_dimensions
{

% find bounding box (fit to printable area)

	clippath pathbbox printer_fiddle
	3 -1 roll dup /yborder exch def	sub 2 div /ysize exch def
	exch dup /xborder exch def sub 2 div /xsize exch def

	xsize xborder add ysize yborder add translate
		% 0 0 is now in the centre
	xsize ysize lt { xsize }{ ysize } ifelse

	dup 72 div 2.54 mul /short_side_in_cm exch def
		% cm for map_scale_deg
		% scale map so it is map_scale_deg degrees accross + a bit for a border
		% short side is on stack

	az_dict /kms_per_cm known
	{
		kms_per_cm short_side_in_cm mul
		90 mul 10000 div		% thanks to Napoleon
		/map_scale_deg exch def
	} if

	map_scale_deg div
	dup scale				% from centre to edge

	/order_of_mag map_scale_deg deg2km log cvi 10 exch exp def

				% create a variable that's independent of scale
	clippath pathbbox	% This gives the bounding box to
	/half_height exch def	% the printable area
	/half_width  exch def
	pop pop
	/atom half_height 1000 div def	% this is a fraction of the screen
				% we use as a size variable
} def

%--------------------------------------
% The body of the program
%

(\n\naz_proj.ps v1.1.6beta4, Jun 2001 Jun 00)print_notice
(\nCopyright(C) 1994-2001 Michael Katzmann NV3Z & Joseph Mack NA3T)print_notice
(\nThis program comes with ABSOLUTELY NO WARRANTY\n\n)print_notice

process_options_manual	%manual

%input locations can be of the form of
%
%lat,lon (real, num or int depending how it was entered)
%or
%gridsquare (string).
%
%Historically throughout the development of AZ_PROJ, locations have
%been entered in one of these two ways, and the method has depended
%on what either na3t or nv3z thought was most appropriate for that 
%of entry is usually preferred (eg you would designate a gridsquare
%name eg FM19, if you wanted to color that gridsquare), but you should
%now be able to enter the other form instead (eg any lat/lon pair within FM19).
%
%The location comes from
%a .dat file.
%or
%lat/lon entered in az_ini.ps (or it's equivalent, eg the input form
%from the cgi script on the server, or a config.ps type file)
%
%In the case a of a .dat file the input line could look like one of the following

%mountain:Dennis Hill:FN31jw::
%mountain:Dennis Hill:34.5:-73.2::

%The information is each field of the record is parsed according to the pre-define format of the record
%However now we've allowed the location to be a number (real) or a gridsquare (string),
%so a mechanism is needed to handle either type of input.
%At the time the fields are read, they are all strings.
%Fields which are supposed to contain numbers are converted to reals.
%Fields which are supposed to contain strings are just used as they are.
%Note:
%if the location is input as a gridsquare, there is one location field
%if the location is input as a lat/lon, there are two location fields
%The routine which processes the line will check for a number or a gridsquare
%by looking at the first char in the field.
%If a letter is found, the field will be processed as a gridsquare and converted to lat/lon.
%If a number is found, the value will be assume to be lat, and the next field will be read in as lon.
%
%
%In the lat and lon case, reading from az_ini.ps (or its equivalents),
%Things are a little different. lat/lon etc are already are variables which
%have been assigned a real value, eg
% /lat 43.3 def
%We can't have someone on a server put in a gridsquare value here like
% /lat FM05lw def
%as the FM05lw will be treated as a variable name and not a string.
%We would have to ask people on the server to enter parens to make it a string. eg
% /lat (FM05lw) def
%This is a bit much to ask of people entering a form. The code should handle it.
%
%If a gridsquare is entered, it will be assigned to the variable lat which
%now holds a string, rather than a real. lon will be assigned a default
%value that will be ignored. lat will be tested to see if it is a string.
%If so, the value of lat/lon will be determined and placed in lat/lon.
%If lat is not a string, it will be assumed to be a valid real == lat.

%strip blanks (blanks will result in detection of a real as a string,
%and strings with blanks will crash grid_to_lat_lon)

lat_QTH remove_whitespace /lat_QTH exch def
lon_QTH remove_whitespace /lon_QTH exch def
 
%%leading blanks
%{lat_QTH ( ) anchorsearch { pop /lat_QTH exch def }{pop exit} ifelse }loop %through lat_QTH
%{lon_QTH ( ) anchorsearch { pop /lon_QTH exch def }{pop exit} ifelse }loop %through lon_QTH
%%trailing blanks
%{lat_QTH ( ) search {/lat_QTH exch def pop pop}{pop exit} ifelse }loop %through lat_QTH
%{lon_QTH ( ) search {/lon_QTH exch def pop pop}{pop exit} ifelse }loop %through lon_QTH



% check if first char is a letter or number
%lat_QTH (main: checking for lat/lon or gridsquare \n) print_notice pstack pop

%lat_QTH
%dup 0 1 getinterval		%get first char of current field (on top of stack)
%dup dup (0) ge exch (9) le and exch (-) eq or %is it a number?
%	{
%	cvr /lat_QTH exch def
%	%lat_QTH (main: found lat \n) print pstack pop
%	%long is a string, convert to real
%	lon_QTH cvr /lon_QTH exch def
%	%lon_QTH (main: found lon \n) print pstack pop
%	%if have found lat/lon, set bad_loc to show that lat/loc is OK
%	/bad_loc false def
%	}
%	{
%	grid_to_lat_lon
%	/lat_QTH lat def
%	/lon_QTH lon def
%	%lat_QTH lon_QTH (main: found gridsquare \n) print pstack pop pop
%	} ifelse % lat/lon or gridsquare

% if lat_QTH lon_QTH are numbers feed both to location_to_lat_lon
% else if lat_QTH is really a gridsquare, just feed it

lat_QTH isnum
	{
	pop	% pop number from isnum
	lon_QTH lat_QTH location_to_lat_lon
	}
	{
	%isnum returns false (already pop'ed), then the gridlocator
	location_to_lat_lon
	} ifelse
lat /lat_QTH exch def
lon /lon_QTH exch def

%condition inputs which can be out of range
lat_QTH mod_90 /lat_QTH exch def
lon_QTH mod_180 /lon_QTH exch def
%lat_QTH lon_QTH (main: lat_QTH lon_QTH \n) print pstack pop pop


center_offset
	{
	%lat_center lon_center (main: center offset, lat_center lon_center \n) print_notice pstack pop pop
	%strip blanks (blanks will result in detection of a real as a string,
	%and strings with blanks will crash grid_to_lat_lon)

        %leading blanks
        {lat_center ( ) anchorsearch { pop /lat_center exch def }{pop exit} ifelse }loop %through lat_center
        {lon_center ( ) anchorsearch { pop /lon_center exch def }{pop exit} ifelse }loop %through lon_center
	%trailing blanks
	{lat_center ( ) search {/lat_center exch def pop pop}{pop exit} ifelse }loop %through lat_center
        {lon_center ( ) search {/lon_center exch def pop pop}{pop exit} ifelse }loop %through lon_center

	% check if first char is a letter or number
	%(main: pstack \n) print_notice pstack
	%lat_center (main: center_offset - lat_center \n) print_notice pstack pop
        lat_center
        dup 0 1 getinterval		%get first char of current field (on top of stack)
        dup dup (0) ge exch (9) le and exch (-) eq or %is it a number?
        	{
		cvr /lat_center exch def
        	%long is a string, convert to real
        	lon_center cvr /lon_center exch def
        	%lat_center lon_center (main: center_offset lat/lon entered \n) print pstack pop pop
        	%if have found lat/lon, set bad_loc to show that lat/loc is OK
		/bad_loc false def
		}
        	{
        	grid_to_lat_lon
        	/lat_center lat def
        	/lon_center lon def
		%lat_center lon_center (main: center_offset, gridsquare entered \n) print pstack pop pop
		} ifelse % lat/lon or gridsquare

        %condition inputs which can be out of range
        lat_center mod_90 /lat_center exch def
        lon_center mod_180 /lon_center exch def
	%lat_center lon_center (main: center_offset, lat_center lon_center \n) print_notice pstack pop pop
	}
        {
        	/lat_center lat_QTH def
        	/lon_center lon_QTH def
		%lat_center lon_center (main: no center_offset, center at QTH \n) print_notice pstack pop pop
        } ifelse % center_offset

%are we in antipodes mode?
%v1.1beta8
draw_antipodes_mode
	{
	lat_QTH neg /lat_QTH exch def
	lon_QTH 180 add mod_180 /lon_QTH exch def
	lat_center neg /lat_center exch def
	lon_center 180 add mod_180 /lon_center exch def
	%lat_QTH lon_QTH lat_center lon_center pstack (antipodes: lat_QTH lon_QTH lat_center lon_center) print_notice pop pop pop pop
	}
	{
	%lat_QTH lon_QTH lat_center lon_center pstack (antipodes is off: lat_QTH lon_QTH lat_center lon_center) print_notice pop pop pop pop
	}ifelse

%pstack
{
	orientation (portrait) eq {(Orientation: portrait\n) print_notice exit} if
	orientation (orthographic-portrait) eq {(Orientation: orthographic-portrait \n) print_notice exit} if
	orientation (landscape) eq {(Orientation: landscape\n) print_notice 90 rotate exit} if
	orientation (orthographic-landscape) eq {(Orientation: orthographic-landscape \n) print_notice 90 rotate exit} if
	(Orientation: type unknown, portrait assumed \n) print_notice orientation pstack pop exit
}loop

setup_specific
setup_dimensions

% Print Legend before do center offset or else it will
% print in wrong spot (maybe off screen)

label_scale

% move centre to centre of interest
center_offset
{
	lat_center lon_center gc 180 add distance_bearing2xy translate
} if

1.0 setmiterlimit	% looks better for rugged coastlines


check_for_greyline

% Read Data (from file or stdin)
% When sending to a real postscript printer
% (not a program in a computer which outputs the printer's native code)
% OR where there is no ARGUMENT given in ghostscript,
% the script (ie data eg .wdb file(s), dxcc, annotations & beacons  )
% must follow the instruction 'get_line'.
% i.e. the data must be concatenated onto this file (with say an editor).
% Otherwise give the names of data files as arguements to ghostscript
% or your postscript interpreter and let it handle the whole thing.

% Important: Whatever you feed the Postscipt printer, it must end with an EOF
% (always a ^D). Otherwise the printer will wait until it times out.
% You can concatenate the file contrld.ps onto the end of the data files
% if you have no other way of doing this or the spooler doesn't do it for you.
%
get_line
%--------------------------------------az_proj.ps
